
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>brontide: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/lightningnetwork/lnd/brontide/conn.go (0.0%)</option>
				
				<option value="file1">github.com/lightningnetwork/lnd/brontide/listener.go (0.0%)</option>
				
				<option value="file2">github.com/lightningnetwork/lnd/brontide/noise.go (0.5%)</option>
				
				<option value="file3">github.com/lightningnetwork/lnd/build/config.go (0.0%)</option>
				
				<option value="file4">github.com/lightningnetwork/lnd/build/config_prod.go (0.0%)</option>
				
				<option value="file5">github.com/lightningnetwork/lnd/build/deployment.go (0.0%)</option>
				
				<option value="file6">github.com/lightningnetwork/lnd/build/handler_sets.go (0.0%)</option>
				
				<option value="file7">github.com/lightningnetwork/lnd/build/handlers.go (0.0%)</option>
				
				<option value="file8">github.com/lightningnetwork/lnd/build/log.go (15.8%)</option>
				
				<option value="file9">github.com/lightningnetwork/lnd/build/log_shutdown.go (0.0%)</option>
				
				<option value="file10">github.com/lightningnetwork/lnd/build/logrotator.go (0.0%)</option>
				
				<option value="file11">github.com/lightningnetwork/lnd/build/sub_logger.go (0.0%)</option>
				
				<option value="file12">github.com/lightningnetwork/lnd/build/version.go (22.7%)</option>
				
				<option value="file13">github.com/lightningnetwork/lnd/input/input.go (0.0%)</option>
				
				<option value="file14">github.com/lightningnetwork/lnd/input/mocks.go (0.0%)</option>
				
				<option value="file15">github.com/lightningnetwork/lnd/input/musig2.go (0.0%)</option>
				
				<option value="file16">github.com/lightningnetwork/lnd/input/musig2_session_manager.go (0.0%)</option>
				
				<option value="file17">github.com/lightningnetwork/lnd/input/script_desc.go (0.0%)</option>
				
				<option value="file18">github.com/lightningnetwork/lnd/input/script_utils.go (0.6%)</option>
				
				<option value="file19">github.com/lightningnetwork/lnd/input/signdescriptor.go (0.0%)</option>
				
				<option value="file20">github.com/lightningnetwork/lnd/input/size.go (0.0%)</option>
				
				<option value="file21">github.com/lightningnetwork/lnd/input/taproot.go (0.0%)</option>
				
				<option value="file22">github.com/lightningnetwork/lnd/input/test_utils.go (0.0%)</option>
				
				<option value="file23">github.com/lightningnetwork/lnd/input/txout.go (0.0%)</option>
				
				<option value="file24">github.com/lightningnetwork/lnd/input/witnessgen.go (0.0%)</option>
				
				<option value="file25">github.com/lightningnetwork/lnd/internal/musig2v040/context.go (0.0%)</option>
				
				<option value="file26">github.com/lightningnetwork/lnd/internal/musig2v040/keys.go (0.0%)</option>
				
				<option value="file27">github.com/lightningnetwork/lnd/internal/musig2v040/nonces.go (0.0%)</option>
				
				<option value="file28">github.com/lightningnetwork/lnd/internal/musig2v040/sign.go (0.0%)</option>
				
				<option value="file29">github.com/lightningnetwork/lnd/keychain/btcwallet.go (0.0%)</option>
				
				<option value="file30">github.com/lightningnetwork/lnd/keychain/derivation.go (0.0%)</option>
				
				<option value="file31">github.com/lightningnetwork/lnd/keychain/ecdh.go (0.0%)</option>
				
				<option value="file32">github.com/lightningnetwork/lnd/keychain/signer.go (0.0%)</option>
				
				<option value="file33">github.com/lightningnetwork/lnd/lntypes/channel_party.go (0.0%)</option>
				
				<option value="file34">github.com/lightningnetwork/lnd/lntypes/hash.go (0.0%)</option>
				
				<option value="file35">github.com/lightningnetwork/lnd/lntypes/preimage.go (0.0%)</option>
				
				<option value="file36">github.com/lightningnetwork/lnd/lntypes/txsize.go (0.0%)</option>
				
				<option value="file37">github.com/lightningnetwork/lnd/lnutils/chan.go (0.0%)</option>
				
				<option value="file38">github.com/lightningnetwork/lnd/lnutils/errors.go (0.0%)</option>
				
				<option value="file39">github.com/lightningnetwork/lnd/lnutils/fs.go (0.0%)</option>
				
				<option value="file40">github.com/lightningnetwork/lnd/lnutils/log.go (0.0%)</option>
				
				<option value="file41">github.com/lightningnetwork/lnd/lnutils/memory.go (0.0%)</option>
				
				<option value="file42">github.com/lightningnetwork/lnd/lnutils/stream.go (0.0%)</option>
				
				<option value="file43">github.com/lightningnetwork/lnd/lnutils/sync_map.go (0.0%)</option>
				
				<option value="file44">github.com/lightningnetwork/lnd/lnwallet/chainfee/estimator.go (0.0%)</option>
				
				<option value="file45">github.com/lightningnetwork/lnd/lnwallet/chainfee/filtermanager.go (0.0%)</option>
				
				<option value="file46">github.com/lightningnetwork/lnd/lnwallet/chainfee/log.go (66.7%)</option>
				
				<option value="file47">github.com/lightningnetwork/lnd/lnwallet/chainfee/minfeemanager.go (0.0%)</option>
				
				<option value="file48">github.com/lightningnetwork/lnd/lnwallet/chainfee/mocks.go (0.0%)</option>
				
				<option value="file49">github.com/lightningnetwork/lnd/lnwallet/chainfee/rates.go (0.0%)</option>
				
				<option value="file50">github.com/lightningnetwork/lnd/lnwire/accept_channel.go (0.0%)</option>
				
				<option value="file51">github.com/lightningnetwork/lnd/lnwire/announcement_signatures.go (0.0%)</option>
				
				<option value="file52">github.com/lightningnetwork/lnd/lnwire/announcement_signatures_2.go (0.0%)</option>
				
				<option value="file53">github.com/lightningnetwork/lnd/lnwire/channel_announcement.go (0.0%)</option>
				
				<option value="file54">github.com/lightningnetwork/lnd/lnwire/channel_announcement_2.go (0.0%)</option>
				
				<option value="file55">github.com/lightningnetwork/lnd/lnwire/channel_id.go (0.0%)</option>
				
				<option value="file56">github.com/lightningnetwork/lnd/lnwire/channel_ready.go (0.0%)</option>
				
				<option value="file57">github.com/lightningnetwork/lnd/lnwire/channel_reestablish.go (0.0%)</option>
				
				<option value="file58">github.com/lightningnetwork/lnd/lnwire/channel_type.go (0.0%)</option>
				
				<option value="file59">github.com/lightningnetwork/lnd/lnwire/channel_update.go (0.0%)</option>
				
				<option value="file60">github.com/lightningnetwork/lnd/lnwire/channel_update_2.go (0.0%)</option>
				
				<option value="file61">github.com/lightningnetwork/lnd/lnwire/closing_complete.go (0.0%)</option>
				
				<option value="file62">github.com/lightningnetwork/lnd/lnwire/closing_sig.go (0.0%)</option>
				
				<option value="file63">github.com/lightningnetwork/lnd/lnwire/closing_signed.go (0.0%)</option>
				
				<option value="file64">github.com/lightningnetwork/lnd/lnwire/commit_sig.go (0.0%)</option>
				
				<option value="file65">github.com/lightningnetwork/lnd/lnwire/custom.go (0.0%)</option>
				
				<option value="file66">github.com/lightningnetwork/lnd/lnwire/custom_records.go (0.0%)</option>
				
				<option value="file67">github.com/lightningnetwork/lnd/lnwire/dyn_ack.go (0.0%)</option>
				
				<option value="file68">github.com/lightningnetwork/lnd/lnwire/dyn_propose.go (0.0%)</option>
				
				<option value="file69">github.com/lightningnetwork/lnd/lnwire/dyn_reject.go (0.0%)</option>
				
				<option value="file70">github.com/lightningnetwork/lnd/lnwire/encoding.go (0.0%)</option>
				
				<option value="file71">github.com/lightningnetwork/lnd/lnwire/error.go (0.0%)</option>
				
				<option value="file72">github.com/lightningnetwork/lnd/lnwire/extra_bytes.go (0.0%)</option>
				
				<option value="file73">github.com/lightningnetwork/lnd/lnwire/features.go (0.0%)</option>
				
				<option value="file74">github.com/lightningnetwork/lnd/lnwire/funding_created.go (0.0%)</option>
				
				<option value="file75">github.com/lightningnetwork/lnd/lnwire/funding_signed.go (0.0%)</option>
				
				<option value="file76">github.com/lightningnetwork/lnd/lnwire/gossip_timestamp_range.go (0.0%)</option>
				
				<option value="file77">github.com/lightningnetwork/lnd/lnwire/init_message.go (0.0%)</option>
				
				<option value="file78">github.com/lightningnetwork/lnd/lnwire/kickoff_sig.go (0.0%)</option>
				
				<option value="file79">github.com/lightningnetwork/lnd/lnwire/lnwire.go (0.0%)</option>
				
				<option value="file80">github.com/lightningnetwork/lnd/lnwire/message.go (0.0%)</option>
				
				<option value="file81">github.com/lightningnetwork/lnd/lnwire/msat.go (0.0%)</option>
				
				<option value="file82">github.com/lightningnetwork/lnd/lnwire/musig2.go (0.0%)</option>
				
				<option value="file83">github.com/lightningnetwork/lnd/lnwire/netaddress.go (0.0%)</option>
				
				<option value="file84">github.com/lightningnetwork/lnd/lnwire/node_announcement.go (0.0%)</option>
				
				<option value="file85">github.com/lightningnetwork/lnd/lnwire/onion_error.go (0.0%)</option>
				
				<option value="file86">github.com/lightningnetwork/lnd/lnwire/opaque_addrs.go (0.0%)</option>
				
				<option value="file87">github.com/lightningnetwork/lnd/lnwire/open_channel.go (0.0%)</option>
				
				<option value="file88">github.com/lightningnetwork/lnd/lnwire/partial_sig.go (0.0%)</option>
				
				<option value="file89">github.com/lightningnetwork/lnd/lnwire/ping.go (0.0%)</option>
				
				<option value="file90">github.com/lightningnetwork/lnd/lnwire/pong.go (0.0%)</option>
				
				<option value="file91">github.com/lightningnetwork/lnd/lnwire/query_channel_range.go (0.0%)</option>
				
				<option value="file92">github.com/lightningnetwork/lnd/lnwire/query_options.go (0.0%)</option>
				
				<option value="file93">github.com/lightningnetwork/lnd/lnwire/query_short_chan_ids.go (0.0%)</option>
				
				<option value="file94">github.com/lightningnetwork/lnd/lnwire/reply_channel_range.go (0.0%)</option>
				
				<option value="file95">github.com/lightningnetwork/lnd/lnwire/reply_short_chan_ids_end.go (0.0%)</option>
				
				<option value="file96">github.com/lightningnetwork/lnd/lnwire/revoke_and_ack.go (0.0%)</option>
				
				<option value="file97">github.com/lightningnetwork/lnd/lnwire/short_channel_id.go (0.0%)</option>
				
				<option value="file98">github.com/lightningnetwork/lnd/lnwire/shutdown.go (0.0%)</option>
				
				<option value="file99">github.com/lightningnetwork/lnd/lnwire/signature.go (0.0%)</option>
				
				<option value="file100">github.com/lightningnetwork/lnd/lnwire/stfu.go (0.0%)</option>
				
				<option value="file101">github.com/lightningnetwork/lnd/lnwire/test_message.go (0.0%)</option>
				
				<option value="file102">github.com/lightningnetwork/lnd/lnwire/test_utils.go (0.0%)</option>
				
				<option value="file103">github.com/lightningnetwork/lnd/lnwire/timestamps.go (0.0%)</option>
				
				<option value="file104">github.com/lightningnetwork/lnd/lnwire/typed_delivery_addr.go (0.0%)</option>
				
				<option value="file105">github.com/lightningnetwork/lnd/lnwire/typed_fee.go (0.0%)</option>
				
				<option value="file106">github.com/lightningnetwork/lnd/lnwire/typed_lease_expiry.go (0.0%)</option>
				
				<option value="file107">github.com/lightningnetwork/lnd/lnwire/update_add_htlc.go (0.0%)</option>
				
				<option value="file108">github.com/lightningnetwork/lnd/lnwire/update_fail_htlc.go (0.0%)</option>
				
				<option value="file109">github.com/lightningnetwork/lnd/lnwire/update_fail_malformed_htlc.go (0.0%)</option>
				
				<option value="file110">github.com/lightningnetwork/lnd/lnwire/update_fee.go (0.0%)</option>
				
				<option value="file111">github.com/lightningnetwork/lnd/lnwire/update_fulfill_htlc.go (0.0%)</option>
				
				<option value="file112">github.com/lightningnetwork/lnd/lnwire/warning.go (0.0%)</option>
				
				<option value="file113">github.com/lightningnetwork/lnd/lnwire/writer.go (0.0%)</option>
				
				<option value="file114">github.com/lightningnetwork/lnd/multimutex/multimutex.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package brontide

import (
        "bytes"
        "io"
        "math"
        "net"
        "time"

        "github.com/btcsuite/btcd/btcec/v2"
        "github.com/lightningnetwork/lnd/keychain"
        "github.com/lightningnetwork/lnd/lnwire"
        "github.com/lightningnetwork/lnd/tor"
)

// Conn is an implementation of net.Conn which enforces an authenticated key
// exchange and message encryption protocol dubbed "Brontide" after initial TCP
// connection establishment. In the case of a successful handshake, all
// messages sent via the .Write() method are encrypted with an AEAD cipher
// along with an encrypted length-prefix. See the Machine struct for
// additional details w.r.t to the handshake and encryption scheme.
type Conn struct {
        conn net.Conn

        noise *Machine

        readBuf bytes.Buffer
}

// A compile-time assertion to ensure that Conn meets the net.Conn interface.
var _ net.Conn = (*Conn)(nil)

// Dial attempts to establish an encrypted+authenticated connection with the
// remote peer located at address which has remotePub as its long-term static
// public key. In the case of a handshake failure, the connection is closed and
// a non-nil error is returned.
func Dial(local keychain.SingleKeyECDH, netAddr *lnwire.NetAddress,
        timeout time.Duration, dialer tor.DialFunc) (*Conn, error) <span class="cov0" title="0">{

        ipAddr := netAddr.Address.String()
        var conn net.Conn
        var err error
        conn, err = dialer("tcp", ipAddr, timeout)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">b := &amp;Conn{
                conn:  conn,
                noise: NewBrontideMachine(true, local, netAddr.IdentityKey),
        }

        // Initiate the handshake by sending the first act to the receiver.
        actOne, err := b.noise.GenActOne()
        if err != nil </span><span class="cov0" title="0">{
                b.conn.Close()
                return nil, err
        }</span>
        <span class="cov0" title="0">if _, err := conn.Write(actOne[:]); err != nil </span><span class="cov0" title="0">{
                b.conn.Close()
                return nil, err
        }</span>

        // We'll ensure that we get ActTwo from the remote peer in a timely
        // manner. If they don't respond within handshakeReadTimeout, then
        // we'll kill the connection.
        <span class="cov0" title="0">err = conn.SetReadDeadline(time.Now().Add(handshakeReadTimeout))
        if err != nil </span><span class="cov0" title="0">{
                b.conn.Close()
                return nil, err
        }</span>

        // If the first act was successful (we know that address is actually
        // remotePub), then read the second act after which we'll be able to
        // send our static public key to the remote peer with strong forward
        // secrecy.
        <span class="cov0" title="0">var actTwo [ActTwoSize]byte
        if _, err := io.ReadFull(conn, actTwo[:]); err != nil </span><span class="cov0" title="0">{
                b.conn.Close()
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := b.noise.RecvActTwo(actTwo); err != nil </span><span class="cov0" title="0">{
                b.conn.Close()
                return nil, err
        }</span>

        // Finally, complete the handshake by sending over our encrypted static
        // key and execute the final ECDH operation.
        <span class="cov0" title="0">actThree, err := b.noise.GenActThree()
        if err != nil </span><span class="cov0" title="0">{
                b.conn.Close()
                return nil, err
        }</span>
        <span class="cov0" title="0">if _, err := conn.Write(actThree[:]); err != nil </span><span class="cov0" title="0">{
                b.conn.Close()
                return nil, err
        }</span>

        // We'll reset the deadline as it's no longer critical beyond the
        // initial handshake.
        <span class="cov0" title="0">err = conn.SetReadDeadline(time.Time{})
        if err != nil </span><span class="cov0" title="0">{
                b.conn.Close()
                return nil, err
        }</span>

        <span class="cov0" title="0">return b, nil</span>
}

// ReadNextMessage uses the connection in a message-oriented manner, instructing
// it to read the next _full_ message with the brontide stream. This function
// will block until the read of the header and body succeeds.
//
// NOTE: This method SHOULD NOT be used in the case that the connection may be
// adversarial and induce long delays. If the caller needs to set read deadlines
// appropriately, it is preferred that they use the split ReadNextHeader and
// ReadNextBody methods so that the deadlines can be set appropriately on each.
func (c *Conn) ReadNextMessage() ([]byte, error) <span class="cov0" title="0">{
        return c.noise.ReadMessage(c.conn)
}</span>

// ReadNextHeader uses the connection to read the next header from the brontide
// stream. This function will block until the read of the header succeeds and
// return the packet length (including MAC overhead) that is expected from the
// subsequent call to ReadNextBody.
func (c *Conn) ReadNextHeader() (uint32, error) <span class="cov0" title="0">{
        return c.noise.ReadHeader(c.conn)
}</span>

// ReadNextBody uses the connection to read the next message body from the
// brontide stream. This function will block until the read of the body succeeds
// and return the decrypted payload. The provided buffer MUST be the packet
// length returned by the preceding call to ReadNextHeader.
func (c *Conn) ReadNextBody(buf []byte) ([]byte, error) <span class="cov0" title="0">{
        return c.noise.ReadBody(c.conn, buf)
}</span>

// Read reads data from the connection.  Read can be made to time out and
// return an Error with Timeout() == true after a fixed time limit; see
// SetDeadline and SetReadDeadline.
//
// Part of the net.Conn interface.
func (c *Conn) Read(b []byte) (n int, err error) <span class="cov0" title="0">{
        // In order to reconcile the differences between the record abstraction
        // of our AEAD connection, and the stream abstraction of TCP, we
        // maintain an intermediate read buffer. If this buffer becomes
        // depleted, then we read the next record, and feed it into the
        // buffer. Otherwise, we read directly from the buffer.
        if c.readBuf.Len() == 0 </span><span class="cov0" title="0">{
                plaintext, err := c.noise.ReadMessage(c.conn)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>

                <span class="cov0" title="0">if _, err := c.readBuf.Write(plaintext); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
        }

        <span class="cov0" title="0">return c.readBuf.Read(b)</span>
}

// Write writes data to the connection.  Write can be made to time out and
// return an Error with Timeout() == true after a fixed time limit; see
// SetDeadline and SetWriteDeadline.
//
// Part of the net.Conn interface.
func (c *Conn) Write(b []byte) (n int, err error) <span class="cov0" title="0">{
        // If the message doesn't require any chunking, then we can go ahead
        // with a single write.
        if len(b) &lt;= math.MaxUint16 </span><span class="cov0" title="0">{
                err = c.noise.WriteMessage(b)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">return c.noise.Flush(c.conn)</span>
        }

        // If we need to split the message into fragments, then we'll write
        // chunks which maximize usage of the available payload.
        <span class="cov0" title="0">chunkSize := math.MaxUint16

        bytesToWrite := len(b)
        bytesWritten := 0
        for bytesWritten &lt; bytesToWrite </span><span class="cov0" title="0">{
                // If we're on the last chunk, then truncate the chunk size as
                // necessary to avoid an out-of-bounds array memory access.
                if bytesWritten+chunkSize &gt; len(b) </span><span class="cov0" title="0">{
                        chunkSize = len(b) - bytesWritten
                }</span>

                // Slice off the next chunk to be written based on our running
                // counter and next chunk size.
                <span class="cov0" title="0">chunk := b[bytesWritten : bytesWritten+chunkSize]
                if err := c.noise.WriteMessage(chunk); err != nil </span><span class="cov0" title="0">{
                        return bytesWritten, err
                }</span>

                <span class="cov0" title="0">n, err := c.noise.Flush(c.conn)
                bytesWritten += n
                if err != nil </span><span class="cov0" title="0">{
                        return bytesWritten, err
                }</span>
        }

        <span class="cov0" title="0">return bytesWritten, nil</span>
}

// WriteMessage encrypts and buffers the next message p for the connection. The
// ciphertext of the message is prepended with an encrypt+auth'd length which
// must be used as the AD to the AEAD construction when being decrypted by the
// other side.
//
// NOTE: This DOES NOT write the message to the wire, it should be followed by a
// call to Flush to ensure the message is written.
func (c *Conn) WriteMessage(b []byte) error <span class="cov0" title="0">{
        return c.noise.WriteMessage(b)
}</span>

// Flush attempts to write a message buffered using WriteMessage to the
// underlying connection. If no buffered message exists, this will result in a
// NOP. Otherwise, it will continue to write the remaining bytes, picking up
// where the byte stream left off in the event of a partial write. The number of
// bytes returned reflects the number of plaintext bytes in the payload, and
// does not account for the overhead of the header or MACs.
//
// NOTE: It is safe to call this method again iff a timeout error is returned.
func (c *Conn) Flush() (int, error) <span class="cov0" title="0">{
        return c.noise.Flush(c.conn)
}</span>

// Close closes the connection. Any blocked Read or Write operations will be
// unblocked and return errors.
//
// Part of the net.Conn interface.
func (c *Conn) Close() error <span class="cov0" title="0">{
        // TODO(roasbeef): reset brontide state?
        return c.conn.Close()
}</span>

// LocalAddr returns the local network address.
//
// Part of the net.Conn interface.
func (c *Conn) LocalAddr() net.Addr <span class="cov0" title="0">{
        return c.conn.LocalAddr()
}</span>

// RemoteAddr returns the remote network address.
//
// Part of the net.Conn interface.
func (c *Conn) RemoteAddr() net.Addr <span class="cov0" title="0">{
        return c.conn.RemoteAddr()
}</span>

// SetDeadline sets the read and write deadlines associated with the
// connection. It is equivalent to calling both SetReadDeadline and
// SetWriteDeadline.
//
// Part of the net.Conn interface.
func (c *Conn) SetDeadline(t time.Time) error <span class="cov0" title="0">{
        return c.conn.SetDeadline(t)
}</span>

// SetReadDeadline sets the deadline for future Read calls. A zero value for t
// means Read will not time out.
//
// Part of the net.Conn interface.
func (c *Conn) SetReadDeadline(t time.Time) error <span class="cov0" title="0">{
        return c.conn.SetReadDeadline(t)
}</span>

// SetWriteDeadline sets the deadline for future Write calls. Even if write
// times out, it may return n &gt; 0, indicating that some of the data was
// successfully written. A zero value for t means Write will not time out.
//
// Part of the net.Conn interface.
func (c *Conn) SetWriteDeadline(t time.Time) error <span class="cov0" title="0">{
        return c.conn.SetWriteDeadline(t)
}</span>

// RemotePub returns the remote peer's static public key.
func (c *Conn) RemotePub() *btcec.PublicKey <span class="cov0" title="0">{
        return c.noise.remoteStatic
}</span>

// LocalPub returns the local peer's static public key.
func (c *Conn) LocalPub() *btcec.PublicKey <span class="cov0" title="0">{
        return c.noise.localStatic.PubKey()
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package brontide

import (
        "errors"
        "fmt"
        "io"
        "net"
        "time"

        "github.com/btcsuite/btcd/btcec/v2"
        "github.com/lightningnetwork/lnd/keychain"
)

// defaultHandshakes is the maximum number of handshakes that can be done in
// parallel.
const defaultHandshakes = 50

// Listener is an implementation of a net.Conn which executes an authenticated
// key exchange and message encryption protocol dubbed "Machine" after
// initial connection acceptance. See the Machine struct for additional
// details w.r.t the handshake and encryption scheme used within the
// connection.
type Listener struct {
        localStatic keychain.SingleKeyECDH

        tcp *net.TCPListener

        // shouldAccept is a closure that determines if we should accept the
        // incoming connection or not based on its public key.
        shouldAccept func(*btcec.PublicKey) (bool, error)

        handshakeSema chan struct{}
        conns         chan maybeConn
        quit          chan struct{}
}

// A compile-time assertion to ensure that Conn meets the net.Listener interface.
var _ net.Listener = (*Listener)(nil)

// NewListener returns a new net.Listener which enforces the Brontide scheme
// during both initial connection establishment and data transfer.
func NewListener(localStatic keychain.SingleKeyECDH, listenAddr string,
        shouldAccept func(*btcec.PublicKey) (bool, error)) (*Listener, error) <span class="cov0" title="0">{

        addr, err := net.ResolveTCPAddr("tcp", listenAddr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">l, err := net.ListenTCP("tcp", addr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">brontideListener := &amp;Listener{
                localStatic:   localStatic,
                tcp:           l,
                shouldAccept:  shouldAccept,
                handshakeSema: make(chan struct{}, defaultHandshakes),
                conns:         make(chan maybeConn),
                quit:          make(chan struct{}),
        }

        for i := 0; i &lt; defaultHandshakes; i++ </span><span class="cov0" title="0">{
                brontideListener.handshakeSema &lt;- struct{}{}
        }</span>

        <span class="cov0" title="0">go brontideListener.listen()

        return brontideListener, nil</span>
}

// listen accepts connection from the underlying tcp conn, then performs
// the brontinde handshake procedure asynchronously. A maximum of
// defaultHandshakes will be active at any given time.
//
// NOTE: This method must be run as a goroutine.
func (l *Listener) listen() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-l.handshakeSema:<span class="cov0" title="0"></span>
                case &lt;-l.quit:<span class="cov0" title="0">
                        return</span>
                }

                <span class="cov0" title="0">conn, err := l.tcp.Accept()
                if err != nil </span><span class="cov0" title="0">{
                        l.rejectConn(err)
                        l.handshakeSema &lt;- struct{}{}
                        continue</span>
                }

                <span class="cov0" title="0">go l.doHandshake(conn)</span>
        }
}

// rejectedConnErr is a helper function that prepends the remote address of the
// failed connection attempt to the original error message.
func rejectedConnErr(err error, remoteAddr string) error <span class="cov0" title="0">{
        return fmt.Errorf("unable to accept connection from %v: %w", remoteAddr,
                err)
}</span>

// doHandshake asynchronously performs the brontide handshake, so that it does
// not block the main accept loop. This prevents peers that delay writing to the
// connection from block other connection attempts.
func (l *Listener) doHandshake(conn net.Conn) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{ l.handshakeSema &lt;- struct{}{} }</span>()

        <span class="cov0" title="0">select </span>{
        case &lt;-l.quit:<span class="cov0" title="0">
                return</span>
        default:<span class="cov0" title="0"></span>
        }

        <span class="cov0" title="0">remoteAddr := conn.RemoteAddr().String()

        brontideConn := &amp;Conn{
                conn:  conn,
                noise: NewBrontideMachine(false, l.localStatic, nil),
        }

        // We'll ensure that we get ActOne from the remote peer in a timely
        // manner. If they don't respond within handshakeReadTimeout, then
        // we'll kill the connection.
        err := conn.SetReadDeadline(time.Now().Add(handshakeReadTimeout))
        if err != nil </span><span class="cov0" title="0">{
                brontideConn.conn.Close()
                l.rejectConn(rejectedConnErr(err, remoteAddr))
                return
        }</span>

        // Attempt to carry out the first act of the handshake protocol. If the
        // connecting node doesn't know our long-term static public key, then
        // this portion will fail with a non-nil error.
        <span class="cov0" title="0">var actOne [ActOneSize]byte
        if _, err := io.ReadFull(conn, actOne[:]); err != nil </span><span class="cov0" title="0">{
                brontideConn.conn.Close()
                l.rejectConn(rejectedConnErr(err, remoteAddr))
                return
        }</span>
        <span class="cov0" title="0">if err := brontideConn.noise.RecvActOne(actOne); err != nil </span><span class="cov0" title="0">{
                brontideConn.conn.Close()
                l.rejectConn(rejectedConnErr(err, remoteAddr))
                return
        }</span>

        // Next, progress the handshake processes by sending over our ephemeral
        // key for the session along with an authenticating tag.
        <span class="cov0" title="0">actTwo, err := brontideConn.noise.GenActTwo()
        if err != nil </span><span class="cov0" title="0">{
                brontideConn.conn.Close()
                l.rejectConn(rejectedConnErr(err, remoteAddr))
                return
        }</span>
        <span class="cov0" title="0">if _, err := conn.Write(actTwo[:]); err != nil </span><span class="cov0" title="0">{
                brontideConn.conn.Close()
                l.rejectConn(rejectedConnErr(err, remoteAddr))
                return
        }</span>

        <span class="cov0" title="0">select </span>{
        case &lt;-l.quit:<span class="cov0" title="0">
                return</span>
        default:<span class="cov0" title="0"></span>
        }

        // We'll ensure that we get ActTwo from the remote peer in a timely
        // manner. If they don't respond within handshakeReadTimeout, then
        // we'll kill the connection.
        <span class="cov0" title="0">err = conn.SetReadDeadline(time.Now().Add(handshakeReadTimeout))
        if err != nil </span><span class="cov0" title="0">{
                brontideConn.conn.Close()
                l.rejectConn(rejectedConnErr(err, remoteAddr))
                return
        }</span>

        // Finally, finish the handshake processes by reading and decrypting
        // the connection peer's static public key. If this succeeds then both
        // sides have mutually authenticated each other.
        <span class="cov0" title="0">var actThree [ActThreeSize]byte
        if _, err := io.ReadFull(conn, actThree[:]); err != nil </span><span class="cov0" title="0">{
                brontideConn.conn.Close()
                l.rejectConn(rejectedConnErr(err, remoteAddr))
                return
        }</span>
        <span class="cov0" title="0">if err := brontideConn.noise.RecvActThree(actThree); err != nil </span><span class="cov0" title="0">{
                brontideConn.conn.Close()
                l.rejectConn(rejectedConnErr(err, remoteAddr))
                return
        }</span>

        // We'll reset the deadline as it's no longer critical beyond the
        // initial handshake.
        <span class="cov0" title="0">err = conn.SetReadDeadline(time.Time{})
        if err != nil </span><span class="cov0" title="0">{
                brontideConn.conn.Close()
                l.rejectConn(rejectedConnErr(err, remoteAddr))
                return
        }</span>

        // Call the shouldAccept closure to see if the remote node's public key
        // is allowed according to our banning heuristic. This is here because
        // we do not learn the remote node's public static key until we've
        // received and validated Act 3.
        <span class="cov0" title="0">remoteKey := brontideConn.RemotePub()
        if remoteKey == nil </span><span class="cov0" title="0">{
                connErr := fmt.Errorf("no remote pubkey")
                brontideConn.conn.Close()
                l.rejectConn(rejectedConnErr(connErr, remoteAddr))

                return
        }</span>

        <span class="cov0" title="0">accepted, acceptErr := l.shouldAccept(remoteKey)
        if !accepted </span><span class="cov0" title="0">{
                // Reject the connection.
                brontideConn.conn.Close()
                l.rejectConn(rejectedConnErr(acceptErr, remoteAddr))

                return
        }</span>

        <span class="cov0" title="0">l.acceptConn(brontideConn)</span>
}

// maybeConn holds either a brontide connection or an error returned from the
// handshake.
type maybeConn struct {
        conn *Conn
        err  error
}

// acceptConn returns a connection that successfully performed a handshake.
func (l *Listener) acceptConn(conn *Conn) <span class="cov0" title="0">{
        select </span>{
        case l.conns &lt;- maybeConn{conn: conn}:<span class="cov0" title="0"></span>
        case &lt;-l.quit:<span class="cov0" title="0"></span>
        }
}

// rejectConn returns any errors encountered during connection or handshake.
func (l *Listener) rejectConn(err error) <span class="cov0" title="0">{
        select </span>{
        case l.conns &lt;- maybeConn{err: err}:<span class="cov0" title="0"></span>
        case &lt;-l.quit:<span class="cov0" title="0"></span>
        }
}

// Accept waits for and returns the next connection to the listener. All
// incoming connections are authenticated via the three act Brontide
// key-exchange scheme. This function will fail with a non-nil error in the
// case that either the handshake breaks down, or the remote peer doesn't know
// our static public key.
//
// Part of the net.Listener interface.
func (l *Listener) Accept() (net.Conn, error) <span class="cov0" title="0">{
        select </span>{
        case result := &lt;-l.conns:<span class="cov0" title="0">
                return result.conn, result.err</span>
        case &lt;-l.quit:<span class="cov0" title="0">
                return nil, errors.New("brontide connection closed")</span>
        }
}

// Close closes the listener.  Any blocked Accept operations will be unblocked
// and return errors.
//
// Part of the net.Listener interface.
func (l *Listener) Close() error <span class="cov0" title="0">{
        select </span>{
        case &lt;-l.quit:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0">
                close(l.quit)</span>
        }

        <span class="cov0" title="0">return l.tcp.Close()</span>
}

// Addr returns the listener's network address.
//
// Part of the net.Listener interface.
func (l *Listener) Addr() net.Addr <span class="cov0" title="0">{
        return l.tcp.Addr()
}</span>

// DisabledBanClosure is used in places that NewListener is invoked to bypass
// the ban-scoring.
func DisabledBanClosure(p *btcec.PublicKey) (bool, error) <span class="cov0" title="0">{
        return true, nil
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package brontide

import (
        "crypto/cipher"
        "crypto/sha256"
        "encoding/binary"
        "errors"
        "fmt"
        "io"
        "math"
        "time"

        "github.com/btcsuite/btcd/btcec/v2"
        "github.com/lightningnetwork/lnd/keychain"
        "golang.org/x/crypto/chacha20poly1305"
        "golang.org/x/crypto/hkdf"
)

const (
        // protocolName is the precise instantiation of the Noise protocol
        // handshake at the center of Brontide. This value will be used as part
        // of the prologue. If the initiator and responder aren't using the
        // exact same string for this value, along with prologue of the Bitcoin
        // network, then the initial handshake will fail.
        protocolName = "Noise_XK_secp256k1_ChaChaPoly_SHA256"

        // macSize is the length in bytes of the tags generated by poly1305.
        macSize = 16

        // lengthHeaderSize is the number of bytes used to prefix encode the
        // length of a message payload.
        lengthHeaderSize = 2

        // encHeaderSize is the number of bytes required to hold an encrypted
        // header and it's MAC.
        encHeaderSize = lengthHeaderSize + macSize

        // keyRotationInterval is the number of messages sent on a single
        // cipher stream before the keys are rotated forwards.
        keyRotationInterval = 1000

        // handshakeReadTimeout is a read timeout that will be enforced when
        // waiting for data payloads during the various acts of Brontide. If
        // the remote party fails to deliver the proper payload within this
        // time frame, then we'll fail the connection.
        handshakeReadTimeout = time.Second * 5
)

var (
        // ErrMaxMessageLengthExceeded is returned when a message to be written to
        // the cipher session exceeds the maximum allowed message payload.
        ErrMaxMessageLengthExceeded = errors.New("the generated payload exceeds " +
                "the max allowed message length of (2^16)-1")

        // ErrMessageNotFlushed signals that the connection cannot accept a new
        // message because the prior message has not been fully flushed.
        ErrMessageNotFlushed = errors.New("prior message not flushed")

        // lightningPrologue is the noise prologue that is used to initialize
        // the brontide noise handshake.
        lightningPrologue = []byte("lightning")

        // ephemeralGen is the default ephemeral key generator, used to derive a
        // unique ephemeral key for each brontide handshake.
        ephemeralGen = func() (*btcec.PrivateKey, error) <span class="cov0" title="0">{
                return btcec.NewPrivateKey()
        }</span>
)

// TODO(roasbeef): free buffer pool?

// ecdh performs an ECDH operation between pub and priv. The returned value is
// the sha256 of the compressed shared point.
func ecdh(pub *btcec.PublicKey, priv keychain.SingleKeyECDH) ([]byte, error) <span class="cov0" title="0">{
        hash, err := priv.ECDH(pub)
        return hash[:], err
}</span>

// cipherState encapsulates the state for the AEAD which will be used to
// encrypt+authenticate any payloads sent during the handshake, and messages
// sent once the handshake has completed.
type cipherState struct {
        // nonce is the nonce passed into the chacha20-poly1305 instance for
        // encryption+decryption. The nonce is incremented after each successful
        // encryption/decryption.
        //
        // TODO(roasbeef): this should actually be 96 bit
        nonce uint64

        // secretKey is the shared symmetric key which will be used to
        // instantiate the cipher.
        //
        // TODO(roasbeef): m-lock??
        secretKey [32]byte

        // salt is an additional secret which is used during key rotation to
        // generate new keys.
        salt [32]byte

        // cipher is an instance of the ChaCha20-Poly1305 AEAD construction
        // created using the secretKey above.
        cipher cipher.AEAD
}

// Encrypt returns a ciphertext which is the encryption of the plainText
// observing the passed associatedData within the AEAD construction.
func (c *cipherState) Encrypt(associatedData, cipherText, plainText []byte) []byte <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                c.nonce++

                if c.nonce == keyRotationInterval </span><span class="cov0" title="0">{
                        c.rotateKey()
                }</span>
        }()

        <span class="cov0" title="0">var nonce [12]byte
        binary.LittleEndian.PutUint64(nonce[4:], c.nonce)

        return c.cipher.Seal(cipherText, nonce[:], plainText, associatedData)</span>
}

// Decrypt attempts to decrypt the passed ciphertext observing the specified
// associatedData within the AEAD construction. In the case that the final MAC
// check fails, then a non-nil error will be returned.
func (c *cipherState) Decrypt(associatedData, plainText, cipherText []byte) ([]byte, error) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                c.nonce++

                if c.nonce == keyRotationInterval </span><span class="cov0" title="0">{
                        c.rotateKey()
                }</span>
        }()

        <span class="cov0" title="0">var nonce [12]byte
        binary.LittleEndian.PutUint64(nonce[4:], c.nonce)

        return c.cipher.Open(plainText, nonce[:], cipherText, associatedData)</span>
}

// InitializeKey initializes the secret key and AEAD cipher scheme based off of
// the passed key.
func (c *cipherState) InitializeKey(key [32]byte) <span class="cov0" title="0">{
        c.secretKey = key
        c.nonce = 0

        // Safe to ignore the error here as our key is properly sized
        // (32-bytes).
        c.cipher, _ = chacha20poly1305.New(c.secretKey[:])
}</span>

// InitializeKeyWithSalt is identical to InitializeKey however it also sets the
// cipherState's salt field which is used for key rotation.
func (c *cipherState) InitializeKeyWithSalt(salt, key [32]byte) <span class="cov0" title="0">{
        c.salt = salt
        c.InitializeKey(key)
}</span>

// rotateKey rotates the current encryption/decryption key for this cipherState
// instance. Key rotation is performed by ratcheting the current key forward
// using an HKDF invocation with the cipherState's salt as the salt, and the
// current key as the input.
func (c *cipherState) rotateKey() <span class="cov0" title="0">{
        var (
                info    []byte
                nextKey [32]byte
        )

        oldKey := c.secretKey
        h := hkdf.New(sha256.New, oldKey[:], c.salt[:], info)

        // hkdf(ck, k, zero)
        // |
        // | \
        // |  \
        // ck  k'
        h.Read(c.salt[:])
        h.Read(nextKey[:])

        c.InitializeKey(nextKey)
}</span>

// symmetricState encapsulates a cipherState object and houses the ephemeral
// handshake digest state. This struct is used during the handshake to derive
// new shared secrets based off of the result of ECDH operations. Ultimately,
// the final key yielded by this struct is the result of an incremental
// Triple-DH operation.
type symmetricState struct {
        cipherState

        // chainingKey is used as the salt to the HKDF function to derive a new
        // chaining key as well as a new tempKey which is used for
        // encryption/decryption.
        chainingKey [32]byte

        // tempKey is the latter 32 bytes resulted from the latest HKDF
        // iteration. This key is used to encrypt/decrypt any handshake
        // messages or payloads sent until the next DH operation is executed.
        tempKey [32]byte

        // handshakeDigest is the cumulative hash digest of all handshake
        // messages sent from start to finish. This value is never transmitted
        // to the other side, but will be used as the AD when
        // encrypting/decrypting messages using our AEAD construction.
        handshakeDigest [32]byte
}

// mixKey implements a basic HKDF-based key ratchet. This method is called
// with the result of each DH output generated during the handshake process.
// The first 32 bytes extract from the HKDF reader is the next chaining key,
// then latter 32 bytes become the temp secret key using within any future AEAD
// operations until another DH operation is performed.
func (s *symmetricState) mixKey(input []byte) <span class="cov0" title="0">{
        var info []byte

        secret := input
        salt := s.chainingKey
        h := hkdf.New(sha256.New, secret, salt[:], info)

        // hkdf(ck, input, zero)
        // |
        // | \
        // |  \
        // ck  k
        h.Read(s.chainingKey[:])
        h.Read(s.tempKey[:])

        // cipher.k = temp_key
        s.InitializeKey(s.tempKey)
}</span>

// mixHash hashes the passed input data into the cumulative handshake digest.
// The running result of this value (h) is used as the associated data in all
// decryption/encryption operations.
func (s *symmetricState) mixHash(data []byte) <span class="cov0" title="0">{
        h := sha256.New()
        h.Write(s.handshakeDigest[:])
        h.Write(data)

        copy(s.handshakeDigest[:], h.Sum(nil))
}</span>

// EncryptAndHash returns the authenticated encryption of the passed plaintext.
// When encrypting the handshake digest (h) is used as the associated data to
// the AEAD cipher.
func (s *symmetricState) EncryptAndHash(plaintext []byte) []byte <span class="cov0" title="0">{
        ciphertext := s.Encrypt(s.handshakeDigest[:], nil, plaintext)

        s.mixHash(ciphertext)

        return ciphertext
}</span>

// DecryptAndHash returns the authenticated decryption of the passed
// ciphertext. When encrypting the handshake digest (h) is used as the
// associated data to the AEAD cipher.
func (s *symmetricState) DecryptAndHash(ciphertext []byte) ([]byte, error) <span class="cov0" title="0">{
        plaintext, err := s.Decrypt(s.handshakeDigest[:], nil, ciphertext)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">s.mixHash(ciphertext)

        return plaintext, nil</span>
}

// InitializeSymmetric initializes the symmetric state by setting the handshake
// digest (h) and the chaining key (ck) to protocol name.
func (s *symmetricState) InitializeSymmetric(protocolName []byte) <span class="cov0" title="0">{
        var empty [32]byte

        s.handshakeDigest = sha256.Sum256(protocolName)
        s.chainingKey = s.handshakeDigest
        s.InitializeKey(empty)
}</span>

// handshakeState encapsulates the symmetricState and keeps track of all the
// public keys (static and ephemeral) for both sides during the handshake
// transcript. If the handshake completes successfully, then two instances of a
// cipherState are emitted: one to encrypt messages from initiator to
// responder, and the other for the opposite direction.
type handshakeState struct {
        symmetricState

        initiator bool

        localStatic    keychain.SingleKeyECDH
        localEphemeral keychain.SingleKeyECDH // nolint (false positive)

        remoteStatic    *btcec.PublicKey
        remoteEphemeral *btcec.PublicKey
}

// newHandshakeState returns a new instance of the handshake state initialized
// with the prologue and protocol name. If this is the responder's handshake
// state, then the remotePub can be nil.
func newHandshakeState(initiator bool, prologue []byte,
        localKey keychain.SingleKeyECDH,
        remotePub *btcec.PublicKey) handshakeState <span class="cov0" title="0">{

        h := handshakeState{
                initiator:    initiator,
                localStatic:  localKey,
                remoteStatic: remotePub,
        }

        // Set the current chaining key and handshake digest to the hash of the
        // protocol name, and additionally mix in the prologue. If either sides
        // disagree about the prologue or protocol name, then the handshake
        // will fail.
        h.InitializeSymmetric([]byte(protocolName))
        h.mixHash(prologue)

        // In Noise_XK, the initiator should know the responder's static
        // public key, therefore we include the responder's static key in the
        // handshake digest. If the initiator gets this value wrong, then the
        // handshake will fail.
        if initiator </span><span class="cov0" title="0">{
                h.mixHash(remotePub.SerializeCompressed())
        }</span> else<span class="cov0" title="0"> {
                h.mixHash(localKey.PubKey().SerializeCompressed())
        }</span>

        <span class="cov0" title="0">return h</span>
}

// EphemeralGenerator is a functional option that allows callers to substitute
// a custom function for use when generating ephemeral keys for ActOne or
// ActTwo. The function closure returned by this function can be passed into
// NewBrontideMachine as a function option parameter.
func EphemeralGenerator(gen func() (*btcec.PrivateKey, error)) func(*Machine) <span class="cov10" title="2">{
        return func(m *Machine) </span><span class="cov0" title="0">{
                m.ephemeralGen = gen
        }</span>
}

// Machine is a state-machine which implements Brontide: an
// Authenticated-key Exchange in Three Acts. Brontide is derived from the Noise
// framework, specifically implementing the Noise_XK handshake. Once the
// initial 3-act handshake has completed all messages are encrypted with a
// chacha20 AEAD cipher. On the wire, all messages are prefixed with an
// authenticated+encrypted length field. Additionally, the encrypted+auth'd
// length prefix is used as the AD when encrypting+decryption messages. This
// construction provides confidentiality of packet length, avoids introducing
// a padding-oracle, and binds the encrypted packet length to the packet
// itself.
//
// The acts proceeds the following order (initiator on the left):
//
//        GenActOne()   -&gt;
//                          RecvActOne()
//                      &lt;-  GenActTwo()
//        RecvActTwo()
//        GenActThree() -&gt;
//                          RecvActThree()
//
// This exchange corresponds to the following Noise handshake:
//
//        &lt;- s
//        ...
//        -&gt; e, es
//        &lt;- e, ee
//        -&gt; s, se
type Machine struct {
        sendCipher cipherState
        recvCipher cipherState

        ephemeralGen func() (*btcec.PrivateKey, error)

        handshakeState

        // nextCipherHeader is a static buffer that we'll use to read in the
        // next ciphertext header from the wire. The header is a 2 byte length
        // (of the next ciphertext), followed by a 16 byte MAC.
        nextCipherHeader [encHeaderSize]byte

        // nextHeaderSend holds a reference to the remaining header bytes to
        // write out for a pending message. This allows us to tolerate timeout
        // errors that cause partial writes.
        nextHeaderSend []byte

        // nextBodySend holds a reference to the remaining body bytes to write
        // out for a pending message. This allows us to tolerate timeout errors
        // that cause partial writes.
        nextBodySend []byte
}

// NewBrontideMachine creates a new instance of the brontide state-machine. If
// the responder (listener) is creating the object, then the remotePub should
// be nil. The handshake state within brontide is initialized using the ascii
// string "lightning" as the prologue. The last parameter is a set of variadic
// arguments for adding additional options to the brontide Machine
// initialization.
func NewBrontideMachine(initiator bool, localKey keychain.SingleKeyECDH,
        remotePub *btcec.PublicKey, options ...func(*Machine)) *Machine <span class="cov0" title="0">{

        handshake := newHandshakeState(
                initiator, lightningPrologue, localKey, remotePub,
        )

        m := &amp;Machine{
                handshakeState: handshake,
                ephemeralGen:   ephemeralGen,
        }

        // With the default options established, we'll now process all the
        // options passed in as parameters.
        for _, option := range options </span><span class="cov0" title="0">{
                option(m)
        }</span>

        <span class="cov0" title="0">return m</span>
}

const (
        // HandshakeVersion is the expected version of the brontide handshake.
        // Any messages that carry a different version will cause the handshake
        // to abort immediately.
        HandshakeVersion = byte(0)

        // ActOneSize is the size of the packet sent from initiator to
        // responder in ActOne. The packet consists of a handshake version, an
        // ephemeral key in compressed format, and a 16-byte poly1305 tag.
        //
        // 1 + 33 + 16
        ActOneSize = 50

        // ActTwoSize is the size the packet sent from responder to initiator
        // in ActTwo. The packet consists of a handshake version, an ephemeral
        // key in compressed format and a 16-byte poly1305 tag.
        //
        // 1 + 33 + 16
        ActTwoSize = 50

        // ActThreeSize is the size of the packet sent from initiator to
        // responder in ActThree. The packet consists of a handshake version,
        // the initiators static key encrypted with strong forward secrecy and
        // a 16-byte poly1035 tag.
        //
        // 1 + 33 + 16 + 16
        ActThreeSize = 66
)

// GenActOne generates the initial packet (act one) to be sent from initiator
// to responder. During act one the initiator generates a fresh ephemeral key,
// hashes it into the handshake digest, and performs an ECDH between this key
// and the responder's static key. Future payloads are encrypted with a key
// derived from this result.
//
//        -&gt; e, es
func (b *Machine) GenActOne() ([ActOneSize]byte, error) <span class="cov0" title="0">{
        var actOne [ActOneSize]byte

        // e
        localEphemeral, err := b.ephemeralGen()
        if err != nil </span><span class="cov0" title="0">{
                return actOne, err
        }</span>
        <span class="cov0" title="0">b.localEphemeral = &amp;keychain.PrivKeyECDH{
                PrivKey: localEphemeral,
        }

        ephemeral := localEphemeral.PubKey().SerializeCompressed()
        b.mixHash(ephemeral)

        // es
        s, err := ecdh(b.remoteStatic, b.localEphemeral)
        if err != nil </span><span class="cov0" title="0">{
                return actOne, err
        }</span>
        <span class="cov0" title="0">b.mixKey(s[:])

        authPayload := b.EncryptAndHash([]byte{})

        actOne[0] = HandshakeVersion
        copy(actOne[1:34], ephemeral)
        copy(actOne[34:], authPayload)

        return actOne, nil</span>
}

// RecvActOne processes the act one packet sent by the initiator. The responder
// executes the mirrored actions to that of the initiator extending the
// handshake digest and deriving a new shared secret based on an ECDH with the
// initiator's ephemeral key and responder's static key.
func (b *Machine) RecvActOne(actOne [ActOneSize]byte) error <span class="cov0" title="0">{
        var (
                err error
                e   [33]byte
                p   [16]byte
        )

        // If the handshake version is unknown, then the handshake fails
        // immediately.
        if actOne[0] != HandshakeVersion </span><span class="cov0" title="0">{
                return fmt.Errorf("act one: invalid handshake version: %v, "+
                        "only %v is valid, msg=%x", actOne[0], HandshakeVersion,
                        actOne[:])
        }</span>

        <span class="cov0" title="0">copy(e[:], actOne[1:34])
        copy(p[:], actOne[34:])

        // e
        b.remoteEphemeral, err = btcec.ParsePubKey(e[:])
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">b.mixHash(b.remoteEphemeral.SerializeCompressed())

        // es
        s, err := ecdh(b.remoteEphemeral, b.localStatic)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">b.mixKey(s)

        // If the initiator doesn't know our static key, then this operation
        // will fail.
        _, err = b.DecryptAndHash(p[:])
        return err</span>
}

// GenActTwo generates the second packet (act two) to be sent from the
// responder to the initiator. The packet for act two is identical to that of
// act one, but then results in a different ECDH operation between the
// initiator's and responder's ephemeral keys.
//
//        &lt;- e, ee
func (b *Machine) GenActTwo() ([ActTwoSize]byte, error) <span class="cov0" title="0">{
        var actTwo [ActTwoSize]byte

        // e
        localEphemeral, err := b.ephemeralGen()
        if err != nil </span><span class="cov0" title="0">{
                return actTwo, err
        }</span>
        <span class="cov0" title="0">b.localEphemeral = &amp;keychain.PrivKeyECDH{
                PrivKey: localEphemeral,
        }

        ephemeral := localEphemeral.PubKey().SerializeCompressed()
        b.mixHash(localEphemeral.PubKey().SerializeCompressed())

        // ee
        s, err := ecdh(b.remoteEphemeral, b.localEphemeral)
        if err != nil </span><span class="cov0" title="0">{
                return actTwo, err
        }</span>
        <span class="cov0" title="0">b.mixKey(s)

        authPayload := b.EncryptAndHash([]byte{})

        actTwo[0] = HandshakeVersion
        copy(actTwo[1:34], ephemeral)
        copy(actTwo[34:], authPayload)

        return actTwo, nil</span>
}

// RecvActTwo processes the second packet (act two) sent from the responder to
// the initiator. A successful processing of this packet authenticates the
// initiator to the responder.
func (b *Machine) RecvActTwo(actTwo [ActTwoSize]byte) error <span class="cov0" title="0">{
        var (
                err error
                e   [33]byte
                p   [16]byte
        )

        // If the handshake version is unknown, then the handshake fails
        // immediately.
        if actTwo[0] != HandshakeVersion </span><span class="cov0" title="0">{
                return fmt.Errorf("act two: invalid handshake version: %v, "+
                        "only %v is valid, msg=%x", actTwo[0], HandshakeVersion,
                        actTwo[:])
        }</span>

        <span class="cov0" title="0">copy(e[:], actTwo[1:34])
        copy(p[:], actTwo[34:])

        // e
        b.remoteEphemeral, err = btcec.ParsePubKey(e[:])
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">b.mixHash(b.remoteEphemeral.SerializeCompressed())

        // ee
        s, err := ecdh(b.remoteEphemeral, b.localEphemeral)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">b.mixKey(s)

        _, err = b.DecryptAndHash(p[:])
        return err</span>
}

// GenActThree creates the final (act three) packet of the handshake. Act three
// is to be sent from the initiator to the responder. The purpose of act three
// is to transmit the initiator's public key under strong forward secrecy to
// the responder. This act also includes the final ECDH operation which yields
// the final session.
//
//        -&gt; s, se
func (b *Machine) GenActThree() ([ActThreeSize]byte, error) <span class="cov0" title="0">{
        var actThree [ActThreeSize]byte

        ourPubkey := b.localStatic.PubKey().SerializeCompressed()
        ciphertext := b.EncryptAndHash(ourPubkey)

        s, err := ecdh(b.remoteEphemeral, b.localStatic)
        if err != nil </span><span class="cov0" title="0">{
                return actThree, err
        }</span>
        <span class="cov0" title="0">b.mixKey(s)

        authPayload := b.EncryptAndHash([]byte{})

        actThree[0] = HandshakeVersion
        copy(actThree[1:50], ciphertext)
        copy(actThree[50:], authPayload)

        // With the final ECDH operation complete, derive the session sending
        // and receiving keys.
        b.split()

        return actThree, nil</span>
}

// RecvActThree processes the final act (act three) sent from the initiator to
// the responder. After processing this act, the responder learns of the
// initiator's static public key. Decryption of the static key serves to
// authenticate the initiator to the responder.
func (b *Machine) RecvActThree(actThree [ActThreeSize]byte) error <span class="cov0" title="0">{
        var (
                err error
                s   [33 + 16]byte
                p   [16]byte
        )

        // If the handshake version is unknown, then the handshake fails
        // immediately.
        if actThree[0] != HandshakeVersion </span><span class="cov0" title="0">{
                return fmt.Errorf("act three: invalid handshake version: %v, "+
                        "only %v is valid, msg=%x", actThree[0], HandshakeVersion,
                        actThree[:])
        }</span>

        <span class="cov0" title="0">copy(s[:], actThree[1:33+16+1])
        copy(p[:], actThree[33+16+1:])

        // s
        remotePub, err := b.DecryptAndHash(s[:])
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">b.remoteStatic, err = btcec.ParsePubKey(remotePub)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // se
        <span class="cov0" title="0">se, err := ecdh(b.remoteStatic, b.localEphemeral)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">b.mixKey(se)

        if _, err := b.DecryptAndHash(p[:]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // With the final ECDH operation complete, derive the session sending
        // and receiving keys.
        <span class="cov0" title="0">b.split()

        return nil</span>
}

// split is the final wrap-up act to be executed at the end of a successful
// three act handshake. This function creates two internal cipherState
// instances: one which is used to encrypt messages from the initiator to the
// responder, and another which is used to encrypt message for the opposite
// direction.
func (b *Machine) split() <span class="cov0" title="0">{
        var (
                empty   []byte
                sendKey [32]byte
                recvKey [32]byte
        )

        h := hkdf.New(sha256.New, empty, b.chainingKey[:], empty)

        // If we're the initiator the first 32 bytes are used to encrypt our
        // messages and the second 32-bytes to decrypt their messages. For the
        // responder the opposite is true.
        if b.initiator </span><span class="cov0" title="0">{
                h.Read(sendKey[:])
                b.sendCipher = cipherState{}
                b.sendCipher.InitializeKeyWithSalt(b.chainingKey, sendKey)

                h.Read(recvKey[:])
                b.recvCipher = cipherState{}
                b.recvCipher.InitializeKeyWithSalt(b.chainingKey, recvKey)
        }</span> else<span class="cov0" title="0"> {
                h.Read(recvKey[:])
                b.recvCipher = cipherState{}
                b.recvCipher.InitializeKeyWithSalt(b.chainingKey, recvKey)

                h.Read(sendKey[:])
                b.sendCipher = cipherState{}
                b.sendCipher.InitializeKeyWithSalt(b.chainingKey, sendKey)
        }</span>
}

// WriteMessage encrypts and buffers the next message p. The ciphertext of the
// message is prepended with an encrypt+auth'd length which must be used as the
// AD to the AEAD construction when being decrypted by the other side.
//
// NOTE: This DOES NOT write the message to the wire, it should be followed by a
// call to Flush to ensure the message is written.
func (b *Machine) WriteMessage(p []byte) error <span class="cov0" title="0">{
        // The total length of each message payload including the MAC size
        // payload exceed the largest number encodable within a 16-bit unsigned
        // integer.
        if len(p) &gt; math.MaxUint16 </span><span class="cov0" title="0">{
                return ErrMaxMessageLengthExceeded
        }</span>

        // If a prior message was written but it hasn't been fully flushed,
        // return an error as we only support buffering of one message at a
        // time.
        <span class="cov0" title="0">if len(b.nextHeaderSend) &gt; 0 || len(b.nextBodySend) &gt; 0 </span><span class="cov0" title="0">{
                return ErrMessageNotFlushed
        }</span>

        // The full length of the packet is only the packet length, and does
        // NOT include the MAC.
        <span class="cov0" title="0">fullLength := uint16(len(p))

        var pktLen [2]byte
        binary.BigEndian.PutUint16(pktLen[:], fullLength)

        // First, generate the encrypted+MAC'd length prefix for the packet.
        b.nextHeaderSend = b.sendCipher.Encrypt(nil, nil, pktLen[:])

        // Finally, generate the encrypted packet itself.
        b.nextBodySend = b.sendCipher.Encrypt(nil, nil, p)

        return nil</span>
}

// Flush attempts to write a message buffered using WriteMessage to the provided
// io.Writer. If no buffered message exists, this will result in a NOP.
// Otherwise, it will continue to write the remaining bytes, picking up where
// the byte stream left off in the event of a partial write. The number of bytes
// returned reflects the number of plaintext bytes in the payload, and does not
// account for the overhead of the header or MACs.
//
// NOTE: It is safe to call this method again iff a timeout error is returned.
func (b *Machine) Flush(w io.Writer) (int, error) <span class="cov0" title="0">{
        // First, write out the pending header bytes, if any exist. Any header
        // bytes written will not count towards the total amount flushed.
        if len(b.nextHeaderSend) &gt; 0 </span><span class="cov0" title="0">{
                // Write any remaining header bytes and shift the slice to point
                // to the next segment of unwritten bytes. If an error is
                // encountered, we can continue to write the header from where
                // we left off on a subsequent call to Flush.
                n, err := w.Write(b.nextHeaderSend)
                b.nextHeaderSend = b.nextHeaderSend[n:]
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
        }

        // Next, write the pending body bytes, if any exist. Only the number of
        // bytes written that correspond to the ciphertext will be included in
        // the total bytes written, bytes written as part of the MAC will not be
        // counted.
        <span class="cov0" title="0">var nn int
        if len(b.nextBodySend) &gt; 0 </span><span class="cov0" title="0">{
                // Write out all bytes excluding the mac and shift the body
                // slice depending on the number of actual bytes written.
                n, err := w.Write(b.nextBodySend)
                b.nextBodySend = b.nextBodySend[n:]

                // If we partially or fully wrote any of the body's MAC, we'll
                // subtract that contribution from the total amount flushed to
                // preserve the abstraction of returning the number of plaintext
                // bytes written by the connection.
                //
                // There are three possible scenarios we must handle to ensure
                // the returned value is correct. In the first case, the write
                // straddles both payload and MAC bytes, and we must subtract
                // the number of MAC bytes written from n. In the second, only
                // payload bytes are written, thus we can return n unmodified.
                // The final scenario pertains to the case where only MAC bytes
                // are written, none of which count towards the total.
                //
                //                 |-----------Payload------------|----MAC----|
                // Straddle:       S---------------------------------E--------0
                // Payload-only:   S------------------------E-----------------0
                // MAC-only:                                        S-------E-0
                start, end := n+len(b.nextBodySend), len(b.nextBodySend)
                switch </span>{

                // Straddles payload and MAC bytes, subtract number of MAC bytes
                // written from the actual number written.
                case start &gt; macSize &amp;&amp; end &lt;= macSize:<span class="cov0" title="0">
                        nn = n - (macSize - end)</span>

                // Only payload bytes are written, return n directly.
                case start &gt; macSize &amp;&amp; end &gt; macSize:<span class="cov0" title="0">
                        nn = n</span>

                // Only MAC bytes are written, return 0 bytes written.
                default:<span class="cov0" title="0"></span>
                }

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return nn, err
                }</span>
        }

        <span class="cov0" title="0">return nn, nil</span>
}

// ReadMessage attempts to read the next message from the passed io.Reader. In
// the case of an authentication error, a non-nil error is returned.
func (b *Machine) ReadMessage(r io.Reader) ([]byte, error) <span class="cov0" title="0">{
        pktLen, err := b.ReadHeader(r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">buf := make([]byte, pktLen)
        return b.ReadBody(r, buf)</span>
}

// ReadHeader attempts to read the next message header from the passed
// io.Reader. The header contains the length of the next body including
// additional overhead of the MAC. In the case of an authentication error, a
// non-nil error is returned.
//
// NOTE: This method SHOULD NOT be used in the case that the io.Reader may be
// adversarial and induce long delays. If the caller needs to set read deadlines
// appropriately, it is preferred that they use the split ReadHeader and
// ReadBody methods so that the deadlines can be set appropriately on each.
func (b *Machine) ReadHeader(r io.Reader) (uint32, error) <span class="cov0" title="0">{
        _, err := io.ReadFull(r, b.nextCipherHeader[:])
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        // Attempt to decrypt+auth the packet length present in the stream.
        //
        // By passing in `nextCipherHeader` as the destination, we avoid making
        // the library allocate a new buffer to decode the plaintext.
        <span class="cov0" title="0">pktLenBytes, err := b.recvCipher.Decrypt(
                nil, b.nextCipherHeader[:0], b.nextCipherHeader[:],
        )
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        // Compute the packet length that we will need to read off the wire.
        <span class="cov0" title="0">pktLen := uint32(binary.BigEndian.Uint16(pktLenBytes)) + macSize

        return pktLen, nil</span>
}

// ReadBody attempts to ready the next message body from the passed io.Reader.
// The provided buffer MUST be the length indicated by the packet length
// returned by the preceding call to ReadHeader. In the case of an
// authentication error, a non-nil error is returned.
func (b *Machine) ReadBody(r io.Reader, buf []byte) ([]byte, error) <span class="cov0" title="0">{
        // Next, using the length read from the packet header, read the
        // encrypted packet itself into the buffer allocated by the read
        // pool.
        _, err := io.ReadFull(r, buf)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Finally, decrypt the message held in the buffer, and return a new
        // byte slice containing the plaintext.
        //
        // By passing in the buf (the ciphertext) as the first argument, we end
        // up re-using it as we don't force the library to allocate a new
        // buffer to decode the plaintext.
        <span class="cov0" title="0">return b.recvCipher.Decrypt(nil, buf[:0], buf)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package build

import (
        "fmt"

        "github.com/btcsuite/btclog/v2"
)

const (
        callSiteOff   = "off"
        callSiteShort = "short"
        callSiteLong  = "long"

        defaultLogCompressor = Gzip

        // DefaultMaxLogFiles is the default maximum number of log files to
        // keep.
        DefaultMaxLogFiles = 10

        // DefaultMaxLogFileSize is the default maximum log file size in MB.
        DefaultMaxLogFileSize = 20
)

// LogConfig holds logging configuration options.
//
//nolint:ll
type LogConfig struct {
        Console      *consoleLoggerCfg `group:"console" namespace:"console" description:"The logger writing to stdout and stderr."`
        File         *FileLoggerConfig `group:"file" namespace:"file" description:"The logger writing to LND's standard log file."`
        NoCommitHash bool              `long:"no-commit-hash" description:"If set, the commit-hash of the current build will not be included in log lines by default."`
}

// Validate validates the LogConfig struct values.
func (c *LogConfig) Validate() error <span class="cov0" title="0">{
        if !SupportedLogCompressor(c.File.Compressor) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid log compressor: %v",
                        c.File.Compressor)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// LoggerConfig holds options for a particular logger.
//
//nolint:ll
type LoggerConfig struct {
        Disable      bool   `long:"disable" description:"Disable this logger."`
        NoTimestamps bool   `long:"no-timestamps" description:"Omit timestamps from log lines."`
        CallSite     string `long:"call-site" description:"Include the call-site of each log line." choice:"off" choice:"short" choice:"long"`
}

// DefaultLogConfig returns the default logging config options.
func DefaultLogConfig() *LogConfig <span class="cov0" title="0">{
        return &amp;LogConfig{
                Console: defaultConsoleLoggerCfg(),
                File: &amp;FileLoggerConfig{
                        Compressor:     defaultLogCompressor,
                        MaxLogFiles:    DefaultMaxLogFiles,
                        MaxLogFileSize: DefaultMaxLogFileSize,
                        LoggerConfig: &amp;LoggerConfig{
                                CallSite: callSiteOff,
                        },
                },
        }
}</span>

// HandlerOptions returns the set of btclog.HandlerOptions that the state of the
// config struct translates to.
func (cfg *LoggerConfig) HandlerOptions() []btclog.HandlerOption <span class="cov0" title="0">{
        opts := []btclog.HandlerOption{
                // We wrap the logger provided by the logging library with
                // another layer of abstraction with the handlerSet, and so we
                // need to increase the default skip depth by 1.
                btclog.WithCallSiteSkipDepth(btclog.DefaultSkipDepth + 1),
        }

        if cfg.NoTimestamps </span><span class="cov0" title="0">{
                opts = append(opts, btclog.WithNoTimestamp())
        }</span>

        <span class="cov0" title="0">switch cfg.CallSite </span>{
        case callSiteShort:<span class="cov0" title="0">
                opts = append(opts, btclog.WithCallerFlags(btclog.Lshortfile))</span>
        case callSiteLong:<span class="cov0" title="0">
                opts = append(opts, btclog.WithCallerFlags(btclog.Llongfile))</span>
        }

        <span class="cov0" title="0">return opts</span>
}

// FileLoggerConfig extends LoggerConfig with specific log file options.
//
//nolint:ll
type FileLoggerConfig struct {
        *LoggerConfig  `yaml:",inline"`
        Compressor     string `long:"compressor" description:"Compression algorithm to use when rotating logs." choice:"gzip" choice:"zstd"`
        MaxLogFiles    int    `long:"max-files" description:"Maximum logfiles to keep (0 for no rotation)"`
        MaxLogFileSize int    `long:"max-file-size" description:"Maximum logfile size in MB"`
}
</pre>
		
		<pre class="file" id="file4" style="display: none">//go:build !dev
// +build !dev

package build

// consoleLoggerCfg embeds the LoggerConfig struct along with any extensions
// specific to a production deployment.
//
//nolint:ll
type consoleLoggerCfg struct {
        *LoggerConfig `yaml:",inline"`
}

// defaultConsoleLoggerCfg returns the default consoleLoggerCfg for the prod
// console logger.
func defaultConsoleLoggerCfg() *consoleLoggerCfg <span class="cov0" title="0">{
        return &amp;consoleLoggerCfg{
                LoggerConfig: &amp;LoggerConfig{
                        CallSite: callSiteOff,
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package build

// DeploymentType is an enum specifying the deployment to compile.
type DeploymentType byte

const (
        // Development is a deployment that includes extra testing hooks and
        // logging configurations.
        Development DeploymentType = iota

        // Production is a deployment that strips out testing logic and uses
        // Default logging.
        Production
)

// String returns a human readable name for a build type.
func (b DeploymentType) String() string <span class="cov0" title="0">{
        switch b </span>{
        case Development:<span class="cov0" title="0">
                return "development"</span>
        case Production:<span class="cov0" title="0">
                return "production"</span>
        default:<span class="cov0" title="0">
                return "unknown"</span>
        }
}

// IsProdBuild returns true if this is a production build.
func IsProdBuild() bool <span class="cov0" title="0">{
        return Deployment == Production
}</span>

// IsDevBuild returns true if this is a development build.
func IsDevBuild() bool <span class="cov0" title="0">{
        return Deployment == Development
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package build

import (
        "context"
        "log/slog"

        btclogv1 "github.com/btcsuite/btclog"
        "github.com/btcsuite/btclog/v2"
)

// handlerSet is an implementation of Handler that abstracts away multiple
// Handlers.
type handlerSet struct {
        level btclogv1.Level
        set   []btclog.Handler
}

// newHandlerSet constructs a new HandlerSet.
func newHandlerSet(level btclogv1.Level, set ...btclog.Handler) *handlerSet <span class="cov0" title="0">{
        h := &amp;handlerSet{
                set:   set,
                level: level,
        }
        h.SetLevel(level)

        return h
}</span>

// Enabled reports whether the handler handles records at the given level.
//
// NOTE: this is part of the slog.Handler interface.
func (h *handlerSet) Enabled(ctx context.Context, level slog.Level) bool <span class="cov0" title="0">{
        for _, handler := range h.set </span><span class="cov0" title="0">{
                if !handler.Enabled(ctx, level) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

// Handle handles the Record.
//
// NOTE: this is part of the slog.Handler interface.
func (h *handlerSet) Handle(ctx context.Context, record slog.Record) error <span class="cov0" title="0">{
        for _, handler := range h.set </span><span class="cov0" title="0">{
                if err := handler.Handle(ctx, record); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// WithAttrs returns a new Handler whose attributes consist of both the
// receiver's attributes and the arguments.
//
// NOTE: this is part of the slog.Handler interface.
func (h *handlerSet) WithAttrs(attrs []slog.Attr) slog.Handler <span class="cov0" title="0">{
        newSet := &amp;reducedSet{set: make([]slog.Handler, len(h.set))}
        for i, handler := range h.set </span><span class="cov0" title="0">{
                newSet.set[i] = handler.WithAttrs(attrs)
        }</span>

        <span class="cov0" title="0">return newSet</span>
}

// WithGroup returns a new Handler with the given group appended to the
// receiver's existing groups.
//
// NOTE: this is part of the slog.Handler interface.
func (h *handlerSet) WithGroup(name string) slog.Handler <span class="cov0" title="0">{
        newSet := &amp;reducedSet{set: make([]slog.Handler, len(h.set))}
        for i, handler := range h.set </span><span class="cov0" title="0">{
                newSet.set[i] = handler.WithGroup(name)
        }</span>

        <span class="cov0" title="0">return newSet</span>
}

// SubSystem creates a new Handler with the given sub-system tag.
//
// NOTE: this is part of the Handler interface.
func (h *handlerSet) SubSystem(tag string) btclog.Handler <span class="cov0" title="0">{
        newSet := &amp;handlerSet{set: make([]btclog.Handler, len(h.set))}
        for i, handler := range h.set </span><span class="cov0" title="0">{
                newSet.set[i] = handler.SubSystem(tag)
        }</span>

        <span class="cov0" title="0">return newSet</span>
}

// SetLevel changes the logging level of the Handler to the passed
// level.
//
// NOTE: this is part of the btclog.Handler interface.
func (h *handlerSet) SetLevel(level btclogv1.Level) <span class="cov0" title="0">{
        for _, handler := range h.set </span><span class="cov0" title="0">{
                handler.SetLevel(level)
        }</span>
        <span class="cov0" title="0">h.level = level</span>
}

// Level returns the current logging level of the Handler.
//
// NOTE: this is part of the btclog.Handler interface.
func (h *handlerSet) Level() btclogv1.Level <span class="cov0" title="0">{
        return h.level
}</span>

// WithPrefix returns a copy of the Handler but with the given string prefixed
// to each log message.
//
// NOTE: this is part of the btclog.Handler interface.
func (h *handlerSet) WithPrefix(prefix string) btclog.Handler <span class="cov0" title="0">{
        newSet := &amp;handlerSet{set: make([]btclog.Handler, len(h.set))}
        for i, handler := range h.set </span><span class="cov0" title="0">{
                newSet.set[i] = handler.WithPrefix(prefix)
        }</span>

        <span class="cov0" title="0">return newSet</span>
}

// A compile-time check to ensure that handlerSet implements btclog.Handler.
var _ btclog.Handler = (*handlerSet)(nil)

// reducedSet is an implementation of the slog.Handler interface which is
// itself backed by multiple slog.Handlers. This is used by the handlerSet
// WithGroup and WithAttrs methods so that we can apply the WithGroup and
// WithAttrs to the underlying handlers in the set. These calls, however,
// produce slog.Handlers and not btclog.Handlers. So the reducedSet represents
// the resulting set produced.
type reducedSet struct {
        set []slog.Handler
}

// Enabled reports whether the handler handles records at the given level.
//
// NOTE: this is part of the slog.Handler interface.
func (r *reducedSet) Enabled(ctx context.Context, level slog.Level) bool <span class="cov0" title="0">{
        for _, handler := range r.set </span><span class="cov0" title="0">{
                if !handler.Enabled(ctx, level) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

// Handle handles the Record.
//
// NOTE: this is part of the slog.Handler interface.
func (r *reducedSet) Handle(ctx context.Context, record slog.Record) error <span class="cov0" title="0">{
        for _, handler := range r.set </span><span class="cov0" title="0">{
                if err := handler.Handle(ctx, record); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// WithAttrs returns a new Handler whose attributes consist of both the
// receiver's attributes and the arguments.
//
// NOTE: this is part of the slog.Handler interface.
func (r *reducedSet) WithAttrs(attrs []slog.Attr) slog.Handler <span class="cov0" title="0">{
        newSet := &amp;reducedSet{set: make([]slog.Handler, len(r.set))}
        for i, handler := range r.set </span><span class="cov0" title="0">{
                newSet.set[i] = handler.WithAttrs(attrs)
        }</span>

        <span class="cov0" title="0">return newSet</span>
}

// WithGroup returns a new Handler with the given group appended to the
// receiver's existing groups.
//
// NOTE: this is part of the slog.Handler interface.
func (r *reducedSet) WithGroup(name string) slog.Handler <span class="cov0" title="0">{
        newSet := &amp;reducedSet{set: make([]slog.Handler, len(r.set))}
        for i, handler := range r.set </span><span class="cov0" title="0">{
                newSet.set[i] = handler.WithGroup(name)
        }</span>

        <span class="cov0" title="0">return newSet</span>
}

// A compile-time check to ensure that handlerSet implements slog.Handler.
var _ slog.Handler = (*reducedSet)(nil)

// subLogGenerator implements the SubLogCreator backed by a Handler.
type subLogGenerator struct {
        handler btclog.Handler
}

// newSubLogGenerator constructs a new subLogGenerator from a Handler.
func newSubLogGenerator(handler btclog.Handler) *subLogGenerator <span class="cov0" title="0">{
        return &amp;subLogGenerator{
                handler: handler,
        }
}</span>

// Logger returns a new logger for a particular sub-system.
//
// NOTE: this is part of the SubLogCreator interface.
func (b *subLogGenerator) Logger(subsystemTag string) btclog.Logger <span class="cov0" title="0">{
        handler := b.handler.SubSystem(subsystemTag)

        return btclog.NewSLogger(handler)
}</span>

// A compile-time check to ensure that handlerSet implements slog.Handler.
var _ SubLogCreator = (*subLogGenerator)(nil)
</pre>
		
		<pre class="file" id="file7" style="display: none">package build

import (
        "os"

        "github.com/btcsuite/btclog/v2"
)

// NewDefaultLogHandlers returns the standard console logger and rotating log
// writer handlers that we generally want to use. It also applies the various
// config options to the loggers.
func NewDefaultLogHandlers(cfg *LogConfig,
        rotator *RotatingLogWriter) []btclog.Handler <span class="cov0" title="0">{

        var handlers []btclog.Handler

        consoleLogHandler := btclog.NewDefaultHandler(
                os.Stdout, cfg.Console.HandlerOptions()...,
        )
        logFileHandler := btclog.NewDefaultHandler(
                rotator, cfg.File.HandlerOptions()...,
        )

        maybeAddLogger := func(cmdOptionDisable bool, handler btclog.Handler) </span><span class="cov0" title="0">{
                if !cmdOptionDisable </span><span class="cov0" title="0">{
                        handlers = append(handlers, handler)
                }</span>
        }
        <span class="cov0" title="0">switch LoggingType </span>{
        case LogTypeStdOut:<span class="cov0" title="0">
                maybeAddLogger(cfg.Console.Disable, consoleLogHandler)</span>
        case LogTypeDefault:<span class="cov0" title="0">
                maybeAddLogger(cfg.Console.Disable, consoleLogHandler)
                maybeAddLogger(cfg.File.Disable, logFileHandler)</span>
        }

        <span class="cov0" title="0">return handlers</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package build

import (
        "os"

        "github.com/btcsuite/btclog/v2"
)

// LogType is an indicating the type of logging specified by the build flag.
type LogType byte

const (
        // LogTypeNone indicates no logging.
        LogTypeNone LogType = iota

        // LogTypeStdOut all logging is written directly to stdout.
        LogTypeStdOut

        // LogTypeDefault logs to both stdout and a given io.PipeWriter.
        LogTypeDefault
)

// String returns a human readable identifier for the logging type.
func (t LogType) String() string <span class="cov0" title="0">{
        switch t </span>{
        case LogTypeNone:<span class="cov0" title="0">
                return "none"</span>
        case LogTypeStdOut:<span class="cov0" title="0">
                return "stdout"</span>
        case LogTypeDefault:<span class="cov0" title="0">
                return "default"</span>
        default:<span class="cov0" title="0">
                return "unknown"</span>
        }
}

// Declare the supported log file compressors as exported consts for easier use
// from other projects.
const (
        // Gzip is the default compressor.
        Gzip = "gzip"

        // Zstd is a modern compressor that compresses better than Gzip, in less
        // time.
        Zstd = "zstd"
)

// logCompressors maps the identifier for each supported compression algorithm
// to the extension used for the compressed log files.
var logCompressors = map[string]string{
        Gzip: "gz",
        Zstd: "zst",
}

// SupportedLogCompressor returns whether or not logCompressor is a supported
// compression algorithm for log files.
func SupportedLogCompressor(logCompressor string) bool <span class="cov0" title="0">{
        _, ok := logCompressors[logCompressor]

        return ok
}</span>

// NewSubLogger constructs a new subsystem log from the current LogWriter
// implementation. This is primarily intended for use with stdlog, as the actual
// writer is shared amongst all instantiations.
func NewSubLogger(subsystem string,
        genSubLogger func(string) btclog.Logger) btclog.Logger <span class="cov8" title="1">{

        switch Deployment </span>{

        // For production builds, generate a new subsystem logger from the
        // primary log backend. If no function is provided, logging will be
        // disabled.
        case Production:<span class="cov8" title="1">
                if genSubLogger != nil </span><span class="cov0" title="0">{
                        return genSubLogger(subsystem)
                }</span>

        // For development builds, we must handle two distinct types of logging:
        // unit tests and running the live daemon, e.g. for integration testing.
        case Development:<span class="cov0" title="0">
                switch LoggingType </span>{

                // Default logging is used when running the standalone daemon.
                // We'll use the optional sublogger constructor to mimic the
                // production behavior.
                case LogTypeDefault:<span class="cov0" title="0">
                        if genSubLogger != nil </span><span class="cov0" title="0">{
                                return genSubLogger(subsystem)
                        }</span>

                // Logging to stdout is used in unit tests. It is not important
                // that they share the same backend, since all output is written
                // to std out.
                case LogTypeStdOut:<span class="cov0" title="0">
                        backend := btclog.NewDefaultHandler(os.Stdout)
                        logger := btclog.NewSLogger(
                                backend.SubSystem(subsystem),
                        )

                        // Set the logging level of the stdout logger to use the
                        // configured logging level specified by build flags.
                        level, _ := btclog.LevelFromString(LogLevel)
                        logger.SetLevel(level)

                        return logger</span>
                }
        }

        // For any other configurations, we'll disable logging.
        <span class="cov8" title="1">return btclog.Disabled</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package build

import (
        "context"

        "github.com/btcsuite/btclog/v2"
)

// ShutdownLogger wraps an existing logger with a shutdown function which will
// be called on Critical/Criticalf to prompt shutdown.
type ShutdownLogger struct {
        btclog.Logger
        shutdown func()
}

// NewShutdownLogger creates a shutdown logger for the log provided which will
// use the signal package to request shutdown on critical errors.
func NewShutdownLogger(logger btclog.Logger, shutdown func()) *ShutdownLogger <span class="cov0" title="0">{
        return &amp;ShutdownLogger{
                Logger:   logger,
                shutdown: shutdown,
        }
}</span>

// Criticalf formats message according to format specifier and writes to
// log with LevelCritical. It will then call the shutdown logger's shutdown
// function to prompt safe shutdown.
//
// Note: it is part of the btclog.Logger interface.
func (s *ShutdownLogger) Criticalf(format string, params ...interface{}) <span class="cov0" title="0">{
        s.Logger.Criticalf(format, params...)
        s.Logger.Info("Sending request for shutdown")
        s.shutdown()
}</span>

// Critical formats message using the default formats for its operands
// and writes to log with LevelCritical. It will then call the shutdown
// logger's shutdown function to prompt safe shutdown.
//
// Note: it is part of the btclog.Logger interface.
func (s *ShutdownLogger) Critical(v ...interface{}) <span class="cov0" title="0">{
        s.Logger.Critical(v)
        s.Logger.Info("Sending request for shutdown")
        s.shutdown()
}</span>

// CriticalS writes a structured log with the given message and key-value pair
// attributes with LevelCritical to the log. It will then call the shutdown
// logger's shutdown function to prompt safe shutdown.
//
// Note: it is part of the btclog.Logger interface.
func (s *ShutdownLogger) CriticalS(ctx context.Context, msg string, err error,
        attr ...interface{}) <span class="cov0" title="0">{

        s.Logger.CriticalS(ctx, msg, err, attr...)
        s.Logger.Info("Sending request for shutdown")
        s.shutdown()
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package build

import (
        "compress/gzip"
        "fmt"
        "io"
        "os"
        "path/filepath"

        "github.com/jrick/logrotate/rotator"
        "github.com/klauspost/compress/zstd"
)

// RotatingLogWriter is a wrapper around the LogWriter that supports log file
// rotation.
type RotatingLogWriter struct {
        // pipe is the write-end pipe for writing to the log rotator.
        pipe *io.PipeWriter

        rotator *rotator.Rotator
}

// NewRotatingLogWriter creates a new file rotating log writer.
//
// NOTE: `InitLogRotator` must be called to set up log rotation after creating
// the writer.
func NewRotatingLogWriter() *RotatingLogWriter <span class="cov0" title="0">{
        return &amp;RotatingLogWriter{}
}</span>

// InitLogRotator initializes the log file rotator to write logs to logFile and
// create roll files in the same directory. It should be called as early on
// startup and possible and must be closed on shutdown by calling `Close`.
func (r *RotatingLogWriter) InitLogRotator(cfg *FileLoggerConfig,
        logFile string) error <span class="cov0" title="0">{

        logDir, _ := filepath.Split(logFile)
        err := os.MkdirAll(logDir, 0700)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create log directory: %w", err)
        }</span>

        <span class="cov0" title="0">r.rotator, err = rotator.New(
                logFile, int64(cfg.MaxLogFileSize*1024), false, cfg.MaxLogFiles,
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create file rotator: %w", err)
        }</span>

        // Reject unknown compressors.
        <span class="cov0" title="0">if !SupportedLogCompressor(cfg.Compressor) </span><span class="cov0" title="0">{
                return fmt.Errorf("unknown log compressor: %v", cfg.Compressor)
        }</span>

        <span class="cov0" title="0">var c rotator.Compressor
        switch cfg.Compressor </span>{
        case Gzip:<span class="cov0" title="0">
                c = gzip.NewWriter(nil)</span>

        case Zstd:<span class="cov0" title="0">
                c, err = zstd.NewWriter(nil)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create zstd compressor: "+
                                "%w", err)
                }</span>
        }

        // Apply the compressor and its file suffix to the log rotator.
        <span class="cov0" title="0">r.rotator.SetCompressor(c, logCompressors[cfg.Compressor])

        // Run rotator as a goroutine now but make sure we catch any errors
        // that happen in case something with the rotation goes wrong during
        // runtime (like running out of disk space or not being allowed to
        // create a new logfile for whatever reason).
        pr, pw := io.Pipe()
        go func() </span><span class="cov0" title="0">{
                err := r.rotator.Run(pr)
                if err != nil </span><span class="cov0" title="0">{
                        _, _ = fmt.Fprintf(os.Stderr,
                                "failed to run file rotator: %v\n", err)
                }</span>
        }()

        <span class="cov0" title="0">r.pipe = pw

        return nil</span>
}

// Write writes the byte slice to the log rotator, if present.
func (r *RotatingLogWriter) Write(b []byte) (int, error) <span class="cov0" title="0">{
        if r.rotator != nil </span><span class="cov0" title="0">{
                return r.rotator.Write(b)
        }</span>

        <span class="cov0" title="0">return len(b), nil</span>
}

// Close closes the underlying log rotator if it has already been created.
func (r *RotatingLogWriter) Close() error <span class="cov0" title="0">{
        if r.rotator != nil </span><span class="cov0" title="0">{
                return r.rotator.Close()
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package build

import (
        "fmt"
        "sort"
        "strings"
        "sync"

        "github.com/btcsuite/btclog/v2"
)

// SubLogCreator can be used to create a new logger for a particular subsystem.
type SubLogCreator interface {
        // Logger returns a new logger for a particular subsystem.
        Logger(subsystemTag string) btclog.Logger
}

// SubLoggerManager manages a set of subsystem loggers. Level updates will be
// applied to all the loggers managed by the manager.
type SubLoggerManager struct {
        genLogger SubLogCreator

        loggers SubLoggers
        mu      sync.Mutex
}

// A compile time check to ensure SubLoggerManager implements the
// LeveledSubLogger interface.
var _ LeveledSubLogger = (*SubLoggerManager)(nil)

// NewSubLoggerManager constructs a new SubLoggerManager.
func NewSubLoggerManager(handlers ...btclog.Handler) *SubLoggerManager <span class="cov0" title="0">{
        return &amp;SubLoggerManager{
                loggers: make(SubLoggers),
                genLogger: newSubLogGenerator(
                        newHandlerSet(btclog.LevelInfo, handlers...),
                ),
        }
}</span>

// GenSubLogger creates a new sub-logger and adds it to the set managed by the
// SubLoggerManager. A shutdown callback function is provided to be able to shut
// down in case of a critical error.
func (r *SubLoggerManager) GenSubLogger(subsystem string,
        shutdown func()) btclog.Logger <span class="cov0" title="0">{

        // Create a new logger with the given subsystem tag.
        logger := r.genLogger.Logger(subsystem)

        // Wrap the new logger in a Shutdown logger so that the shutdown
        // call back is called if a critical log is ever written via this new
        // logger.
        l := NewShutdownLogger(logger, shutdown)

        r.RegisterSubLogger(subsystem, l)

        return l
}</span>

// RegisterSubLogger registers the given logger under the given subsystem name.
func (r *SubLoggerManager) RegisterSubLogger(subsystem string,
        logger btclog.Logger) <span class="cov0" title="0">{

        // Add the new logger to the set of loggers managed by the manager.
        r.mu.Lock()
        r.loggers[subsystem] = logger
        r.mu.Unlock()
}</span>

// SubLoggers returns all currently registered subsystem loggers for this log
// writer.
//
// NOTE: This is part of the LeveledSubLogger interface.
func (r *SubLoggerManager) SubLoggers() SubLoggers <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()

        return r.loggers
}</span>

// SupportedSubsystems returns a sorted string slice of all keys in the
// subsystems map, corresponding to the names of the subsystems.
//
// NOTE: This is part of the LeveledSubLogger interface.
func (r *SubLoggerManager) SupportedSubsystems() []string <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()

        // Convert the subsystemLoggers map keys to a string slice.
        subsystems := make([]string, 0, len(r.loggers))
        for subsysID := range r.loggers </span><span class="cov0" title="0">{
                subsystems = append(subsystems, subsysID)
        }</span>

        // Sort the subsystems for stable display.
        <span class="cov0" title="0">sort.Strings(subsystems)

        return subsystems</span>
}

// SetLogLevel sets the logging level for provided subsystem. Invalid
// subsystems are ignored. Uninitialized subsystems are dynamically created as
// needed.
//
// NOTE: This is part of the LeveledSubLogger interface.
func (r *SubLoggerManager) SetLogLevel(subsystemID string, logLevel string) <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()

        r.setLogLevelUnsafe(subsystemID, logLevel)
}</span>

// setLogLevelUnsafe sets the logging level for provided subsystem. Invalid
// subsystems are ignored. Uninitialized subsystems are dynamically created as
// needed.
//
// NOTE: the SubLoggerManager mutex must be held before calling this method.
func (r *SubLoggerManager) setLogLevelUnsafe(subsystemID string,
        logLevel string) <span class="cov0" title="0">{

        // Ignore invalid subsystems.
        logger, ok := r.loggers[subsystemID]
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        // Defaults to info if the log level is invalid.
        <span class="cov0" title="0">level, _ := btclog.LevelFromString(logLevel)

        logger.SetLevel(level)</span>
}

// SetLogLevels sets the log level for all subsystem loggers to the passed
// level. It also dynamically creates the subsystem loggers as needed, so it
// can be used to initialize the logging system.
//
// NOTE: This is part of the LeveledSubLogger interface.
func (r *SubLoggerManager) SetLogLevels(logLevel string) <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()

        // Configure all sub-systems with the new logging level. Dynamically
        // create loggers as needed.
        for subsystemID := range r.loggers </span><span class="cov0" title="0">{
                r.setLogLevelUnsafe(subsystemID, logLevel)
        }</span>
}

// SubLoggers is a type that holds a map of subsystem loggers keyed by their
// subsystem name.
type SubLoggers map[string]btclog.Logger

// LeveledSubLogger provides the ability to retrieve the subsystem loggers of
// a logger and set their log levels individually or all at once.
type LeveledSubLogger interface {
        // SubLoggers returns the map of all registered subsystem loggers.
        SubLoggers() SubLoggers

        // SupportedSubsystems returns a slice of strings containing the names
        // of the supported subsystems. Should ideally correspond to the keys
        // of the subsystem logger map and be sorted.
        SupportedSubsystems() []string

        // SetLogLevel assigns an individual subsystem logger a new log level.
        SetLogLevel(subsystemID string, logLevel string)

        // SetLogLevels assigns all subsystem loggers the same new log level.
        SetLogLevels(logLevel string)
}

// ParseAndSetDebugLevels attempts to parse the specified debug level and set
// the levels accordingly on the given logger. An appropriate error is returned
// if anything is invalid.
func ParseAndSetDebugLevels(level string, logger LeveledSubLogger) error <span class="cov0" title="0">{
        // Split at the delimiter.
        levels := strings.Split(level, ",")
        if len(levels) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid log level: %v", level)
        }</span>

        // If the first entry has no =, treat is as the log level for all
        // subsystems.
        <span class="cov0" title="0">globalLevel := levels[0]
        if !strings.Contains(globalLevel, "=") </span><span class="cov0" title="0">{
                // Validate debug log level.
                if !validLogLevel(globalLevel) </span><span class="cov0" title="0">{
                        str := "the specified debug level [%v] is invalid"

                        return fmt.Errorf(str, globalLevel)
                }</span>

                // Change the logging level for all subsystems.
                <span class="cov0" title="0">logger.SetLogLevels(globalLevel)

                // The rest will target specific subsystems.
                levels = levels[1:]</span>
        }

        // Go through the subsystem/level pairs while detecting issues and
        // update the log levels accordingly.
        <span class="cov0" title="0">for _, logLevelPair := range levels </span><span class="cov0" title="0">{
                if !strings.Contains(logLevelPair, "=") </span><span class="cov0" title="0">{
                        str := "the specified debug level contains an " +
                                "invalid subsystem/level pair [%v]"

                        return fmt.Errorf(str, logLevelPair)
                }</span>

                // Extract the specified subsystem and log level.
                <span class="cov0" title="0">fields := strings.Split(logLevelPair, "=")
                if len(fields) != 2 </span><span class="cov0" title="0">{
                        str := "the specified debug level has an invalid " +
                                "format [%v] -- use format subsystem1=level1," +
                                "subsystem2=level2"

                        return fmt.Errorf(str, logLevelPair)
                }</span>
                <span class="cov0" title="0">subsysID, logLevel := fields[0], fields[1]
                subLoggers := logger.SubLoggers()

                // Validate subsystem.
                if _, exists := subLoggers[subsysID]; !exists </span><span class="cov0" title="0">{
                        str := "the specified subsystem [%v] is invalid -- " +
                                "supported subsystems are %v"

                        return fmt.Errorf(
                                str, subsysID, logger.SupportedSubsystems(),
                        )
                }</span>

                // Validate log level.
                <span class="cov0" title="0">if !validLogLevel(logLevel) </span><span class="cov0" title="0">{
                        str := "the specified debug level [%v] is invalid"
                        return fmt.Errorf(str, logLevel)
                }</span>

                <span class="cov0" title="0">logger.SetLogLevel(subsysID, logLevel)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validLogLevel returns whether or not logLevel is a valid debug log level.
func validLogLevel(logLevel string) bool <span class="cov0" title="0">{
        switch logLevel </span>{
        case "trace":<span class="cov0" title="0">
                fallthrough</span>
        case "debug":<span class="cov0" title="0">
                fallthrough</span>
        case "info":<span class="cov0" title="0">
                fallthrough</span>
        case "warn":<span class="cov0" title="0">
                fallthrough</span>
        case "error":<span class="cov0" title="0">
                fallthrough</span>
        case "critical":<span class="cov0" title="0">
                fallthrough</span>
        case "off":<span class="cov0" title="0">
                return true</span>
        }

        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Copyright (c) 2013-2017 The btcsuite developers
// Copyright (c) 2015-2016 The Decred developers
// Heavily inspired by https://github.com/btcsuite/btcd/blob/master/version.go
// Copyright (C) 2015-2022 The Lightning Network Developers

package build

import (
        "context"
        "encoding/hex"
        "fmt"
        "runtime/debug"
        "strings"

        "github.com/btcsuite/btclog/v2"
)

var (
        // Commit stores the current commit of this build, which includes the
        // most recent tag, the number of commits since that tag (if non-zero),
        // the commit hash, and a dirty marker. This should be set using the
        // -ldflags during compilation.
        Commit string

        // CommitHash stores the current commit hash of this build.
        CommitHash string

        // RawTags contains the raw set of build tags, separated by commas.
        RawTags string

        // GoVersion stores the go version that the executable was compiled
        // with.
        GoVersion string
)

// semanticAlphabet is the set of characters that are permitted for use in an
// AppPreRelease.
const semanticAlphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-."

// These constants define the application version and follow the semantic
// versioning 2.0.0 spec (http://semver.org/).
const (
        // AppMajor defines the major version of this binary.
        AppMajor uint = 0

        // AppMinor defines the minor version of this binary.
        AppMinor uint = 19

        // AppPatch defines the application patch for this binary.
        AppPatch uint = 00

        // AppPreRelease MUST only contain characters from semanticAlphabet per
        // the semantic versioning spec.
        AppPreRelease = "beta.rc2"
)

func init() <span class="cov1" title="1">{
        // Assert that AppPreRelease is valid according to the semantic
        // versioning guidelines for pre-release version and build metadata
        // strings. In particular it MUST only contain characters in
        // semanticAlphabet.
        for _, r := range AppPreRelease </span><span class="cov10" title="8">{
                if !strings.ContainsRune(semanticAlphabet, r) </span><span class="cov0" title="0">{
                        panic(fmt.Errorf("rune: %v is not in the semantic "+
                                "alphabet", r))</span>
                }
        }

        // Get build information from the runtime.
        <span class="cov1" title="1">if info, ok := debug.ReadBuildInfo(); ok </span><span class="cov1" title="1">{
                GoVersion = info.GoVersion
                for _, setting := range info.Settings </span><span class="cov0" title="0">{
                        switch setting.Key </span>{
                        case "vcs.revision":<span class="cov0" title="0">
                                CommitHash = setting.Value</span>

                        case "-tags":<span class="cov0" title="0">
                                RawTags = setting.Value</span>
                        }
                }
        }
}

// Version returns the application version as a properly formed string per the
// semantic versioning 2.0.0 spec (http://semver.org/).
func Version() string <span class="cov0" title="0">{
        // Start with the major, minor, and patch versions.
        version := fmt.Sprintf("%d.%d.%d", AppMajor, AppMinor, AppPatch)

        // Append pre-release version if there is one. The hyphen called for by
        // the semantic versioning spec is automatically appended and should not
        // be contained in the pre-release string.
        if AppPreRelease != "" </span><span class="cov0" title="0">{
                version = fmt.Sprintf("%s-%s", version, AppPreRelease)
        }</span>

        <span class="cov0" title="0">return version</span>
}

// Tags returns the list of build tags that were compiled into the executable.
func Tags() []string <span class="cov0" title="0">{
        if len(RawTags) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return strings.Split(RawTags, ",")</span>
}

// WithBuildInfo derives a child context with the build information attached as
// attributes. At the moment, this only includes the current build's commit
// hash.
func WithBuildInfo(ctx context.Context, cfg *LogConfig) (context.Context,
        error) <span class="cov0" title="0">{

        if cfg.NoCommitHash </span><span class="cov0" title="0">{
                return ctx, nil
        }</span>

        // Convert the commit hash to a byte slice.
        <span class="cov0" title="0">commitHash, err := hex.DecodeString(CommitHash)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to decode commit hash: %w", err)
        }</span>

        <span class="cov0" title="0">return btclog.WithCtx(ctx, btclog.Hex3("rev", commitHash)), nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package input

import (
        "fmt"

        "github.com/btcsuite/btcd/btcutil"
        "github.com/btcsuite/btcd/txscript"
        "github.com/btcsuite/btcd/wire"
        "github.com/lightningnetwork/lnd/fn/v2"
        "github.com/lightningnetwork/lnd/lntypes"
        "github.com/lightningnetwork/lnd/tlv"
)

// EmptyOutPoint is a zeroed outpoint.
var EmptyOutPoint wire.OutPoint

// Input represents an abstract UTXO which is to be spent using a sweeping
// transaction. The method provided give the caller all information needed to
// construct a valid input within a sweeping transaction to sweep this
// lingering UTXO.
type Input interface {
        // OutPoint returns the reference to the output being spent, used to
        // construct the corresponding transaction input.
        OutPoint() wire.OutPoint

        // RequiredTxOut returns a non-nil TxOut if input commits to a certain
        // transaction output. This is used in the SINGLE|ANYONECANPAY case to
        // make sure any presigned input is still valid by including the
        // output.
        RequiredTxOut() *wire.TxOut

        // RequiredLockTime returns whether this input commits to a tx locktime
        // that must be used in the transaction including it.
        RequiredLockTime() (uint32, bool)

        // WitnessType returns an enum specifying the type of witness that must
        // be generated in order to spend this output.
        WitnessType() WitnessType

        // SignDesc returns a reference to a spendable output's sign
        // descriptor, which is used during signing to compute a valid witness
        // that spends this output.
        SignDesc() *SignDescriptor

        // CraftInputScript returns a valid set of input scripts allowing this
        // output to be spent. The returns input scripts should target the
        // input at location txIndex within the passed transaction. The input
        // scripts generated by this method support spending p2wkh, p2wsh, and
        // also nested p2sh outputs.
        CraftInputScript(signer Signer, txn *wire.MsgTx,
                hashCache *txscript.TxSigHashes,
                prevOutputFetcher txscript.PrevOutputFetcher,
                txinIdx int) (*Script, error)

        // BlocksToMaturity returns the relative timelock, as a number of
        // blocks, that must be built on top of the confirmation height before
        // the output can be spent. For non-CSV locked inputs this is always
        // zero.
        BlocksToMaturity() uint32

        // HeightHint returns the minimum height at which a confirmed spending
        // tx can occur.
        HeightHint() uint32

        // UnconfParent returns information about a possibly unconfirmed parent
        // tx.
        UnconfParent() *TxInfo

        // ResolutionBlob returns a special opaque blob to be used to
        // sweep/resolve this input.
        ResolutionBlob() fn.Option[tlv.Blob]

        // Preimage returns the preimage for the input if it is an HTLC input.
        Preimage() fn.Option[lntypes.Preimage]
}

// TxInfo describes properties of a parent tx that are relevant for CPFP.
type TxInfo struct {
        // Fee is the fee of the tx.
        Fee btcutil.Amount

        // Weight is the weight of the tx.
        Weight lntypes.WeightUnit
}

// String returns a human readable version of the tx info.
func (t *TxInfo) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("fee=%v, weight=%v", t.Fee, t.Weight)
}</span>

// SignDetails is a struct containing information needed to resign certain
// inputs. It is used to re-sign 2nd level HTLC transactions that uses the
// SINGLE|ANYONECANPAY sighash type, as we have a signature provided by our
// peer, but we can aggregate multiple of these 2nd level transactions into a
// new transaction, that needs to be signed by us.
type SignDetails struct {
        // SignDesc is the sign descriptor needed for us to sign the input.
        SignDesc SignDescriptor

        // PeerSig is the peer's signature for this input.
        PeerSig Signature

        // SigHashType is the sighash signed by the peer.
        SigHashType txscript.SigHashType
}

type inputKit struct {
        outpoint        wire.OutPoint
        witnessType     WitnessType
        signDesc        SignDescriptor
        heightHint      uint32
        blockToMaturity uint32
        cltvExpiry      uint32

        // unconfParent contains information about a potential unconfirmed
        // parent transaction.
        unconfParent *TxInfo

        // resolutionBlob is an optional blob that can be used to resolve an
        // input.
        resolutionBlob fn.Option[tlv.Blob]
}

// OutPoint returns the breached output's identifier that is to be included as
// a transaction input.
func (i *inputKit) OutPoint() wire.OutPoint <span class="cov0" title="0">{
        return i.outpoint
}</span>

// RequiredTxOut returns a nil for the base input type.
func (i *inputKit) RequiredTxOut() *wire.TxOut <span class="cov0" title="0">{
        return nil
}</span>

// RequiredLockTime returns whether this input commits to a tx locktime that
// must be used in the transaction including it. This will be false for the
// base input type since we can re-sign for any lock time.
func (i *inputKit) RequiredLockTime() (uint32, bool) <span class="cov0" title="0">{
        return i.cltvExpiry, i.cltvExpiry &gt; 0
}</span>

// WitnessType returns the type of witness that must be generated to spend the
// breached output.
func (i *inputKit) WitnessType() WitnessType <span class="cov0" title="0">{
        return i.witnessType
}</span>

// SignDesc returns the breached output's SignDescriptor, which is used during
// signing to compute the witness.
func (i *inputKit) SignDesc() *SignDescriptor <span class="cov0" title="0">{
        return &amp;i.signDesc
}</span>

// HeightHint returns the minimum height at which a confirmed spending
// tx can occur.
func (i *inputKit) HeightHint() uint32 <span class="cov0" title="0">{
        return i.heightHint
}</span>

// BlocksToMaturity returns the relative timelock, as a number of blocks, that
// must be built on top of the confirmation height before the output can be
// spent. For non-CSV locked inputs this is always zero.
func (i *inputKit) BlocksToMaturity() uint32 <span class="cov0" title="0">{
        return i.blockToMaturity
}</span>

// Cpfp returns information about a possibly unconfirmed parent tx.
func (i *inputKit) UnconfParent() *TxInfo <span class="cov0" title="0">{
        return i.unconfParent
}</span>

// ResolutionBlob returns a special opaque blob to be used to sweep/resolve
// this input.
func (i *inputKit) ResolutionBlob() fn.Option[tlv.Blob] <span class="cov0" title="0">{
        return i.resolutionBlob
}</span>

// inputOpts contains options for constructing a new input.
type inputOpts struct {
        // resolutionBlob is an optional blob that can be used to resolve an
        // input.
        resolutionBlob fn.Option[tlv.Blob]
}

// defaultInputOpts returns a new inputOpts with default values.
func defaultInputOpts() *inputOpts <span class="cov0" title="0">{
        return &amp;inputOpts{}
}</span>

// InputOpt is a functional option that can be used to modify the default input
// options.
type InputOpt func(*inputOpts) //nolint:revive

// WithResolutionBlob is an option that can be used to set a resolution blob on
// for an input.
func WithResolutionBlob(b fn.Option[tlv.Blob]) InputOpt <span class="cov0" title="0">{
        return func(o *inputOpts) </span><span class="cov0" title="0">{
                o.resolutionBlob = b
        }</span>
}

// BaseInput contains all the information needed to sweep a basic
// output (CSV/CLTV/no time lock).
type BaseInput struct {
        inputKit
}

// MakeBaseInput assembles a new BaseInput that can be used to construct a
// sweep transaction.
func MakeBaseInput(outpoint *wire.OutPoint, witnessType WitnessType,
        signDescriptor *SignDescriptor, heightHint uint32,
        unconfParent *TxInfo, opts ...InputOpt) BaseInput <span class="cov0" title="0">{

        opt := defaultInputOpts()
        for _, optF := range opts </span><span class="cov0" title="0">{
                optF(opt)
        }</span>

        <span class="cov0" title="0">return BaseInput{
                inputKit{
                        outpoint:       *outpoint,
                        witnessType:    witnessType,
                        signDesc:       *signDescriptor,
                        heightHint:     heightHint,
                        unconfParent:   unconfParent,
                        resolutionBlob: opt.resolutionBlob,
                },
        }</span>
}

// NewBaseInput allocates and assembles a new *BaseInput that can be used to
// construct a sweep transaction.
func NewBaseInput(outpoint *wire.OutPoint, witnessType WitnessType,
        signDescriptor *SignDescriptor, heightHint uint32,
        opts ...InputOpt) *BaseInput <span class="cov0" title="0">{

        input := MakeBaseInput(
                outpoint, witnessType, signDescriptor, heightHint, nil, opts...,
        )

        return &amp;input
}</span>

// NewCsvInput assembles a new csv-locked input that can be used to
// construct a sweep transaction.
func NewCsvInput(outpoint *wire.OutPoint, witnessType WitnessType,
        signDescriptor *SignDescriptor, heightHint uint32,
        blockToMaturity uint32, opts ...InputOpt) *BaseInput <span class="cov0" title="0">{

        input := MakeBaseInput(
                outpoint, witnessType, signDescriptor, heightHint, nil, opts...,
        )

        input.blockToMaturity = blockToMaturity

        return &amp;input
}</span>

// NewCsvInputWithCltv assembles a new csv and cltv locked input that can be
// used to construct a sweep transaction.
func NewCsvInputWithCltv(outpoint *wire.OutPoint, witnessType WitnessType,
        signDescriptor *SignDescriptor, heightHint uint32,
        csvDelay uint32, cltvExpiry uint32, opts ...InputOpt) *BaseInput <span class="cov0" title="0">{

        input := MakeBaseInput(
                outpoint, witnessType, signDescriptor, heightHint, nil, opts...,
        )

        input.blockToMaturity = csvDelay
        input.cltvExpiry = cltvExpiry

        return &amp;input
}</span>

// CraftInputScript returns a valid set of input scripts allowing this output
// to be spent. The returned input scripts should target the input at location
// txIndex within the passed transaction. The input scripts generated by this
// method support spending p2wkh, p2wsh, and also nested p2sh outputs.
func (bi *BaseInput) CraftInputScript(signer Signer, txn *wire.MsgTx,
        hashCache *txscript.TxSigHashes,
        prevOutputFetcher txscript.PrevOutputFetcher, txinIdx int) (*Script,
        error) <span class="cov0" title="0">{

        signDesc := bi.SignDesc()
        signDesc.PrevOutputFetcher = prevOutputFetcher
        witnessFunc := bi.witnessType.WitnessGenerator(signer, signDesc)

        return witnessFunc(txn, hashCache, txinIdx)
}</span>

// Preimage returns the preimage for the input if it is an HTLC input.
func (bi *BaseInput) Preimage() fn.Option[lntypes.Preimage] <span class="cov0" title="0">{
        return fn.None[lntypes.Preimage]()
}</span>

// HtlcSucceedInput constitutes a sweep input that needs a pre-image. The input
// is expected to reside on the commitment tx of the remote party and should
// not be a second level tx output.
type HtlcSucceedInput struct {
        inputKit

        preimage []byte
}

// MakeHtlcSucceedInput assembles a new redeem input that can be used to
// construct a sweep transaction.
func MakeHtlcSucceedInput(outpoint *wire.OutPoint,
        signDescriptor *SignDescriptor, preimage []byte, heightHint,
        blocksToMaturity uint32, opts ...InputOpt) HtlcSucceedInput <span class="cov0" title="0">{

        input := MakeBaseInput(
                outpoint, HtlcAcceptedRemoteSuccess, signDescriptor,
                heightHint, nil, opts...,
        )
        input.blockToMaturity = blocksToMaturity

        return HtlcSucceedInput{
                inputKit: input.inputKit,
                preimage: preimage,
        }
}</span>

// MakeTaprootHtlcSucceedInput creates a new HtlcSucceedInput that can be used
// to spend an HTLC output for a taproot channel on the remote party's
// commitment transaction.
func MakeTaprootHtlcSucceedInput(op *wire.OutPoint, signDesc *SignDescriptor,
        preimage []byte, heightHint, blocksToMaturity uint32,
        opts ...InputOpt) HtlcSucceedInput <span class="cov0" title="0">{

        input := MakeBaseInput(
                op, TaprootHtlcAcceptedRemoteSuccess, signDesc,
                heightHint, nil, opts...,
        )
        input.blockToMaturity = blocksToMaturity

        return HtlcSucceedInput{
                inputKit: input.inputKit,
                preimage: preimage,
        }
}</span>

// CraftInputScript returns a valid set of input scripts allowing this output
// to be spent. The returns input scripts should target the input at location
// txIndex within the passed transaction. The input scripts generated by this
// method support spending p2wkh, p2wsh, and also nested p2sh outputs.
func (h *HtlcSucceedInput) CraftInputScript(signer Signer, txn *wire.MsgTx,
        hashCache *txscript.TxSigHashes,
        prevOutputFetcher txscript.PrevOutputFetcher, txinIdx int) (*Script,
        error) <span class="cov0" title="0">{

        desc := h.signDesc
        desc.SigHashes = hashCache
        desc.InputIndex = txinIdx
        desc.PrevOutputFetcher = prevOutputFetcher

        isTaproot := txscript.IsPayToTaproot(desc.Output.PkScript)

        var (
                witness wire.TxWitness
                err     error
        )
        if isTaproot </span><span class="cov0" title="0">{
                if desc.ControlBlock == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("ctrl block must be set")
                }</span>

                <span class="cov0" title="0">desc.SignMethod = TaprootScriptSpendSignMethod
                witness, err = SenderHTLCScriptTaprootRedeem(
                        signer, &amp;desc, txn, h.preimage, nil, nil,
                )</span>
        } else<span class="cov0" title="0"> {
                witness, err = SenderHtlcSpendRedeem(
                        signer, &amp;desc, txn, h.preimage,
                )
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;Script{
                Witness: witness,
        }, nil</span>
}

// Preimage returns the preimage for the input if it is an HTLC input.
func (h *HtlcSucceedInput) Preimage() fn.Option[lntypes.Preimage] <span class="cov0" title="0">{
        if len(h.preimage) == 0 </span><span class="cov0" title="0">{
                return fn.None[lntypes.Preimage]()
        }</span>

        <span class="cov0" title="0">return fn.Some(lntypes.Preimage(h.preimage))</span>
}

// HtlcSecondLevelAnchorInput is an input type used to spend HTLC outputs
// using a re-signed second level transaction, either via the timeout or success
// paths.
type HtlcSecondLevelAnchorInput struct {
        inputKit

        // SignedTx is the original second level transaction signed by the
        // channel peer.
        SignedTx *wire.MsgTx

        // createWitness creates a witness allowing the passed transaction to
        // spend the input.
        createWitness func(signer Signer, txn *wire.MsgTx,
                hashCache *txscript.TxSigHashes,
                prevOutputFetcher txscript.PrevOutputFetcher,
                txinIdx int) (wire.TxWitness, error)

        preimage []byte
}

// RequiredTxOut returns the tx out needed to be present on the sweep tx for
// the spend of the input to be valid.
func (i *HtlcSecondLevelAnchorInput) RequiredTxOut() *wire.TxOut <span class="cov0" title="0">{
        return i.SignedTx.TxOut[0]
}</span>

// RequiredLockTime returns the locktime needed for the sweep tx for the spend
// of the input to be valid. For a second level HTLC timeout this will be the
// CLTV expiry, for HTLC success it will be zero.
func (i *HtlcSecondLevelAnchorInput) RequiredLockTime() (uint32, bool) <span class="cov0" title="0">{
        return i.SignedTx.LockTime, true
}</span>

// CraftInputScript returns a valid set of input scripts allowing this output
// to be spent. The returns input scripts should target the input at location
// txIndex within the passed transaction. The input scripts generated by this
// method support spending p2wkh, p2wsh, and also nested p2sh outputs.
func (i *HtlcSecondLevelAnchorInput) CraftInputScript(signer Signer,
        txn *wire.MsgTx, hashCache *txscript.TxSigHashes,
        prevOutputFetcher txscript.PrevOutputFetcher, txinIdx int) (*Script,
        error) <span class="cov0" title="0">{

        witness, err := i.createWitness(
                signer, txn, hashCache, prevOutputFetcher, txinIdx,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;Script{
                Witness: witness,
        }, nil</span>
}

// Preimage returns the preimage for the input if it is an HTLC input.
func (i *HtlcSecondLevelAnchorInput) Preimage() fn.Option[lntypes.Preimage] <span class="cov0" title="0">{
        if len(i.preimage) == 0 </span><span class="cov0" title="0">{
                return fn.None[lntypes.Preimage]()
        }</span>

        <span class="cov0" title="0">return fn.Some(lntypes.Preimage(i.preimage))</span>
}

// MakeHtlcSecondLevelTimeoutAnchorInput creates an input allowing the sweeper
// to spend the HTLC output on our commit using the second level timeout
// transaction.
func MakeHtlcSecondLevelTimeoutAnchorInput(signedTx *wire.MsgTx,
        signDetails *SignDetails, heightHint uint32,
        opts ...InputOpt) HtlcSecondLevelAnchorInput <span class="cov0" title="0">{

        // Spend an HTLC output on our local commitment tx using the
        // 2nd timeout transaction.
        createWitness := func(signer Signer, txn *wire.MsgTx,
                hashCache *txscript.TxSigHashes,
                prevOutputFetcher txscript.PrevOutputFetcher,
                txinIdx int) (wire.TxWitness, error) </span><span class="cov0" title="0">{

                desc := signDetails.SignDesc
                desc.SigHashes = txscript.NewTxSigHashes(txn, prevOutputFetcher)
                desc.InputIndex = txinIdx
                desc.PrevOutputFetcher = prevOutputFetcher

                return SenderHtlcSpendTimeout(
                        signDetails.PeerSig, signDetails.SigHashType, signer,
                        &amp;desc, txn,
                )
        }</span>

        <span class="cov0" title="0">input := MakeBaseInput(
                &amp;signedTx.TxIn[0].PreviousOutPoint,
                HtlcOfferedTimeoutSecondLevelInputConfirmed,
                &amp;signDetails.SignDesc, heightHint, nil, opts...,
        )
        input.blockToMaturity = 1

        return HtlcSecondLevelAnchorInput{
                inputKit:      input.inputKit,
                SignedTx:      signedTx,
                createWitness: createWitness,
        }</span>
}

// MakeHtlcSecondLevelTimeoutTaprootInput creates an input that allows the
// sweeper to spend an HTLC output to the second level on our commitment
// transaction. The sweeper is also able to generate witnesses on demand to
// sweep the second level HTLC aggregated with other transactions.
func MakeHtlcSecondLevelTimeoutTaprootInput(signedTx *wire.MsgTx,
        signDetails *SignDetails,
        heightHint uint32, opts ...InputOpt) HtlcSecondLevelAnchorInput <span class="cov0" title="0">{

        createWitness := func(signer Signer, txn *wire.MsgTx,
                hashCache *txscript.TxSigHashes,
                prevOutputFetcher txscript.PrevOutputFetcher,
                txinIdx int) (wire.TxWitness, error) </span><span class="cov0" title="0">{

                desc := signDetails.SignDesc
                if desc.ControlBlock == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("ctrl block must be set")
                }</span>

                <span class="cov0" title="0">desc.SigHashes = txscript.NewTxSigHashes(txn, prevOutputFetcher)
                desc.InputIndex = txinIdx
                desc.PrevOutputFetcher = prevOutputFetcher

                desc.SignMethod = TaprootScriptSpendSignMethod

                return SenderHTLCScriptTaprootTimeout(
                        signDetails.PeerSig, signDetails.SigHashType, signer,
                        &amp;desc, txn, nil, nil,
                )</span>
        }

        <span class="cov0" title="0">input := MakeBaseInput(
                &amp;signedTx.TxIn[0].PreviousOutPoint,
                TaprootHtlcLocalOfferedTimeout,
                &amp;signDetails.SignDesc, heightHint, nil, opts...,
        )
        input.blockToMaturity = 1

        return HtlcSecondLevelAnchorInput{
                inputKit:      input.inputKit,
                SignedTx:      signedTx,
                createWitness: createWitness,
        }</span>
}

// MakeHtlcSecondLevelSuccessAnchorInput creates an input allowing the sweeper
// to spend the HTLC output on our commit using the second level success
// transaction.
func MakeHtlcSecondLevelSuccessAnchorInput(signedTx *wire.MsgTx,
        signDetails *SignDetails, preimage lntypes.Preimage,
        heightHint uint32, opts ...InputOpt) HtlcSecondLevelAnchorInput <span class="cov0" title="0">{

        // Spend an HTLC output on our local commitment tx using the 2nd
        // success transaction.
        createWitness := func(signer Signer, txn *wire.MsgTx,
                hashCache *txscript.TxSigHashes,
                prevOutputFetcher txscript.PrevOutputFetcher,
                txinIdx int) (wire.TxWitness, error) </span><span class="cov0" title="0">{

                desc := signDetails.SignDesc
                desc.SigHashes = hashCache
                desc.InputIndex = txinIdx
                desc.PrevOutputFetcher = prevOutputFetcher

                return ReceiverHtlcSpendRedeem(
                        signDetails.PeerSig, signDetails.SigHashType,
                        preimage[:], signer, &amp;desc, txn,
                )
        }</span>
        <span class="cov0" title="0">input := MakeBaseInput(
                &amp;signedTx.TxIn[0].PreviousOutPoint,
                HtlcAcceptedSuccessSecondLevelInputConfirmed,
                &amp;signDetails.SignDesc, heightHint, nil, opts...,
        )
        input.blockToMaturity = 1

        return HtlcSecondLevelAnchorInput{
                SignedTx:      signedTx,
                inputKit:      input.inputKit,
                createWitness: createWitness,
                preimage:      preimage[:],
        }</span>
}

// MakeHtlcSecondLevelSuccessTaprootInput creates an input that allows the
// sweeper to spend an HTLC output to the second level on our taproot
// commitment transaction.
func MakeHtlcSecondLevelSuccessTaprootInput(signedTx *wire.MsgTx,
        signDetails *SignDetails, preimage lntypes.Preimage,
        heightHint uint32, opts ...InputOpt) HtlcSecondLevelAnchorInput <span class="cov0" title="0">{

        createWitness := func(signer Signer, txn *wire.MsgTx,
                hashCache *txscript.TxSigHashes,
                prevOutputFetcher txscript.PrevOutputFetcher,
                txinIdx int) (wire.TxWitness, error) </span><span class="cov0" title="0">{

                desc := signDetails.SignDesc
                if desc.ControlBlock == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("ctrl block must be set")
                }</span>

                <span class="cov0" title="0">desc.SigHashes = txscript.NewTxSigHashes(txn, prevOutputFetcher)
                desc.InputIndex = txinIdx
                desc.PrevOutputFetcher = prevOutputFetcher

                desc.SignMethod = TaprootScriptSpendSignMethod

                return ReceiverHTLCScriptTaprootRedeem(
                        signDetails.PeerSig, signDetails.SigHashType,
                        preimage[:], signer, &amp;desc, txn, nil, nil,
                )</span>
        }

        <span class="cov0" title="0">input := MakeBaseInput(
                &amp;signedTx.TxIn[0].PreviousOutPoint,
                TaprootHtlcAcceptedLocalSuccess,
                &amp;signDetails.SignDesc, heightHint, nil, opts...,
        )
        input.blockToMaturity = 1

        return HtlcSecondLevelAnchorInput{
                inputKit:      input.inputKit,
                SignedTx:      signedTx,
                createWitness: createWitness,
                preimage:      preimage[:],
        }</span>
}

// Compile-time constraints to ensure each input struct implement the Input
// interface.
var _ Input = (*BaseInput)(nil)
var _ Input = (*HtlcSucceedInput)(nil)
var _ Input = (*HtlcSecondLevelAnchorInput)(nil)
</pre>
		
		<pre class="file" id="file14" style="display: none">package input

import (
        "crypto/sha256"

        "github.com/btcsuite/btcd/btcec/v2"
        "github.com/btcsuite/btcd/btcec/v2/schnorr"
        "github.com/btcsuite/btcd/btcec/v2/schnorr/musig2"
        "github.com/btcsuite/btcd/txscript"
        "github.com/btcsuite/btcd/wire"
        "github.com/lightningnetwork/lnd/fn/v2"
        "github.com/lightningnetwork/lnd/keychain"
        "github.com/lightningnetwork/lnd/lntypes"
        "github.com/lightningnetwork/lnd/tlv"
        "github.com/stretchr/testify/mock"
)

// MockInput implements the `Input` interface and is used by other packages for
// mock testing.
type MockInput struct {
        mock.Mock
}

// Compile time assertion that MockInput implements Input.
var _ Input = (*MockInput)(nil)

// OutPoint returns the reference to the output being spent, used to construct
// the corresponding transaction input.
func (m *MockInput) OutPoint() wire.OutPoint <span class="cov0" title="0">{
        args := m.Called()
        op := args.Get(0)

        return op.(wire.OutPoint)
}</span>

// RequiredTxOut returns a non-nil TxOut if input commits to a certain
// transaction output. This is used in the SINGLE|ANYONECANPAY case to make
// sure any presigned input is still valid by including the output.
func (m *MockInput) RequiredTxOut() *wire.TxOut <span class="cov0" title="0">{
        args := m.Called()
        txOut := args.Get(0)

        if txOut == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return txOut.(*wire.TxOut)</span>
}

// RequiredLockTime returns whether this input commits to a tx locktime that
// must be used in the transaction including it.
func (m *MockInput) RequiredLockTime() (uint32, bool) <span class="cov0" title="0">{
        args := m.Called()

        return args.Get(0).(uint32), args.Bool(1)
}</span>

// WitnessType returns an enum specifying the type of witness that must be
// generated in order to spend this output.
func (m *MockInput) WitnessType() WitnessType <span class="cov0" title="0">{
        args := m.Called()

        wt := args.Get(0)
        if wt == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return wt.(WitnessType)</span>
}

// SignDesc returns a reference to a spendable output's sign descriptor, which
// is used during signing to compute a valid witness that spends this output.
func (m *MockInput) SignDesc() *SignDescriptor <span class="cov0" title="0">{
        args := m.Called()

        sd := args.Get(0)
        if sd == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return sd.(*SignDescriptor)</span>
}

// CraftInputScript returns a valid set of input scripts allowing this output
// to be spent. The returns input scripts should target the input at location
// txIndex within the passed transaction. The input scripts generated by this
// method support spending p2wkh, p2wsh, and also nested p2sh outputs.
func (m *MockInput) CraftInputScript(signer Signer, txn *wire.MsgTx,
        hashCache *txscript.TxSigHashes,
        prevOutputFetcher txscript.PrevOutputFetcher,
        txinIdx int) (*Script, error) <span class="cov0" title="0">{

        args := m.Called(signer, txn, hashCache, prevOutputFetcher, txinIdx)

        s := args.Get(0)
        if s == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>

        <span class="cov0" title="0">return s.(*Script), args.Error(1)</span>
}

// BlocksToMaturity returns the relative timelock, as a number of blocks, that
// must be built on top of the confirmation height before the output can be
// spent. For non-CSV locked inputs this is always zero.
func (m *MockInput) BlocksToMaturity() uint32 <span class="cov0" title="0">{
        args := m.Called()

        return args.Get(0).(uint32)
}</span>

// HeightHint returns the minimum height at which a confirmed spending tx can
// occur.
func (m *MockInput) HeightHint() uint32 <span class="cov0" title="0">{
        args := m.Called()

        return args.Get(0).(uint32)
}</span>

// UnconfParent returns information about a possibly unconfirmed parent tx.
func (m *MockInput) UnconfParent() *TxInfo <span class="cov0" title="0">{
        args := m.Called()

        info := args.Get(0)
        if info == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return info.(*TxInfo)</span>
}

func (m *MockInput) ResolutionBlob() fn.Option[tlv.Blob] <span class="cov0" title="0">{
        args := m.Called()

        info := args.Get(0)
        if info == nil </span><span class="cov0" title="0">{
                return fn.None[tlv.Blob]()
        }</span>

        <span class="cov0" title="0">return info.(fn.Option[tlv.Blob])</span>
}

func (m *MockInput) Preimage() fn.Option[lntypes.Preimage] <span class="cov0" title="0">{
        args := m.Called()

        info := args.Get(0)
        if info == nil </span><span class="cov0" title="0">{
                return fn.None[lntypes.Preimage]()
        }</span>

        <span class="cov0" title="0">return info.(fn.Option[lntypes.Preimage])</span>
}

// MockWitnessType implements the `WitnessType` interface and is used by other
// packages for mock testing.
type MockWitnessType struct {
        mock.Mock
}

// Compile time assertion that MockWitnessType implements WitnessType.
var _ WitnessType = (*MockWitnessType)(nil)

// String returns a human readable version of the WitnessType.
func (m *MockWitnessType) String() string <span class="cov0" title="0">{
        args := m.Called()

        return args.String(0)
}</span>

// WitnessGenerator will return a WitnessGenerator function that an output uses
// to generate the witness and optionally the sigScript for a sweep
// transaction.
func (m *MockWitnessType) WitnessGenerator(signer Signer,
        descriptor *SignDescriptor) WitnessGenerator <span class="cov0" title="0">{

        args := m.Called()

        return args.Get(0).(WitnessGenerator)
}</span>

// SizeUpperBound returns the maximum length of the witness of this WitnessType
// if it would be included in a tx. It also returns if the output itself is a
// nested p2sh output, if so then we need to take into account the extra
// sigScript data size.
func (m *MockWitnessType) SizeUpperBound() (lntypes.WeightUnit, bool, error) <span class="cov0" title="0">{
        args := m.Called()

        return args.Get(0).(lntypes.WeightUnit), args.Bool(1), args.Error(2)
}</span>

// AddWeightEstimation adds the estimated size of the witness in bytes to the
// given weight estimator.
func (m *MockWitnessType) AddWeightEstimation(e *TxWeightEstimator) error <span class="cov0" title="0">{
        args := m.Called()

        return args.Error(0)
}</span>

// MockInputSigner is a mock implementation of the Signer interface.
type MockInputSigner struct {
        mock.Mock
}

// Compile-time constraint to ensure MockInputSigner implements Signer.
var _ Signer = (*MockInputSigner)(nil)

// SignOutputRaw generates a signature for the passed transaction according to
// the data within the passed SignDescriptor.
func (m *MockInputSigner) SignOutputRaw(tx *wire.MsgTx,
        signDesc *SignDescriptor) (Signature, error) <span class="cov0" title="0">{

        args := m.Called(tx, signDesc)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>

        <span class="cov0" title="0">return args.Get(0).(Signature), args.Error(1)</span>
}

// ComputeInputScript generates a complete InputIndex for the passed
// transaction with the signature as defined within the passed SignDescriptor.
func (m *MockInputSigner) ComputeInputScript(tx *wire.MsgTx,
        signDesc *SignDescriptor) (*Script, error) <span class="cov0" title="0">{

        args := m.Called(tx, signDesc)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>

        <span class="cov0" title="0">return args.Get(0).(*Script), args.Error(1)</span>
}

// MuSig2CreateSession creates a new MuSig2 signing session using the local key
// identified by the key locator.
func (m *MockInputSigner) MuSig2CreateSession(version MuSig2Version,
        locator keychain.KeyLocator, pubkey []*btcec.PublicKey,
        tweak *MuSig2Tweaks, pubNonces [][musig2.PubNonceSize]byte,
        nonces *musig2.Nonces) (*MuSig2SessionInfo, error) <span class="cov0" title="0">{

        args := m.Called(version, locator, pubkey, tweak, pubNonces, nonces)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>

        <span class="cov0" title="0">return args.Get(0).(*MuSig2SessionInfo), args.Error(1)</span>
}

// MuSig2RegisterNonces registers one or more public nonces of other signing
// participants for a session identified by its ID.
func (m *MockInputSigner) MuSig2RegisterNonces(versio MuSig2SessionID,
        pubNonces [][musig2.PubNonceSize]byte) (bool, error) <span class="cov0" title="0">{

        args := m.Called(versio, pubNonces)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return false, args.Error(1)
        }</span>

        <span class="cov0" title="0">return args.Bool(0), args.Error(1)</span>
}

// MuSig2Sign creates a partial signature using the local signing key that was
// specified when the session was created.
func (m *MockInputSigner) MuSig2Sign(sessionID MuSig2SessionID,
        msg [sha256.Size]byte, withSortedKeys bool) (
        *musig2.PartialSignature, error) <span class="cov0" title="0">{

        args := m.Called(sessionID, msg, withSortedKeys)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>

        <span class="cov0" title="0">return args.Get(0).(*musig2.PartialSignature), args.Error(1)</span>
}

// MuSig2CombineSig combines the given partial signature(s) with the local one,
// if it already exists.
func (m *MockInputSigner) MuSig2CombineSig(sessionID MuSig2SessionID,
        partialSig []*musig2.PartialSignature) (
        *schnorr.Signature, bool, error) <span class="cov0" title="0">{

        args := m.Called(sessionID, partialSig)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, false, args.Error(2)
        }</span>

        <span class="cov0" title="0">return args.Get(0).(*schnorr.Signature), args.Bool(1), args.Error(2)</span>
}

// MuSig2Cleanup removes a session from memory to free up resources.
func (m *MockInputSigner) MuSig2Cleanup(sessionID MuSig2SessionID) error <span class="cov0" title="0">{
        args := m.Called(sessionID)

        return args.Error(0)
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package input

import (
        "bytes"
        "crypto/sha256"
        "fmt"

        "github.com/btcsuite/btcd/btcec/v2"
        "github.com/btcsuite/btcd/btcec/v2/schnorr"
        "github.com/btcsuite/btcd/btcec/v2/schnorr/musig2"
        "github.com/lightningnetwork/lnd/internal/musig2v040"
        "github.com/lightningnetwork/lnd/keychain"
)

// MuSig2Version is a type that defines the different versions of the MuSig2
// as defined in the BIP draft:
// (https://github.com/jonasnick/bips/blob/musig2/bip-musig2.mediawiki)
type MuSig2Version uint8

const (
        // MuSig2Version040 is version 0.4.0 of the MuSig2 BIP draft. This will
        // use the lnd internal/musig2v040 package.
        MuSig2Version040 MuSig2Version = 0

        // MuSig2Version100RC2 is version 1.0.0rc2 of the MuSig2 BIP draft. This
        // uses the github.com/btcsuite/btcd/btcec/v2/schnorr/musig2 package
        // at git tag `btcec/v2.3.1`.
        MuSig2Version100RC2 MuSig2Version = 1
)

const (
        // MuSig2PartialSigSize is the size of a MuSig2 partial signature.
        // Because a partial signature is just the s value, this corresponds to
        // the length of a scalar.
        MuSig2PartialSigSize = 32
)

// MuSig2SessionID is a type for a session ID that is just a hash of the MuSig2
// combined key and the local public nonces.
type MuSig2SessionID [sha256.Size]byte

// MuSig2Signer is an interface that declares all methods that a MuSig2
// compatible signer needs to implement.
type MuSig2Signer interface {
        // MuSig2CreateSession creates a new MuSig2 signing session using the
        // local key identified by the key locator. The complete list of all
        // public keys of all signing parties must be provided, including the
        // public key of the local signing key. If nonces of other parties are
        // already known, they can be submitted as well to reduce the number of
        // method calls necessary later on.
        //
        // The localNonces field is optional. If it is set, then the specified
        // nonces will be used instead of generating from scratch.  This is
        // useful in instances where the nonces are generated ahead of time
        // before the set of signers is known.
        MuSig2CreateSession(MuSig2Version, keychain.KeyLocator,
                []*btcec.PublicKey, *MuSig2Tweaks, [][musig2.PubNonceSize]byte,
                *musig2.Nonces) (*MuSig2SessionInfo, error)

        // MuSig2RegisterNonces registers one or more public nonces of other
        // signing participants for a session identified by its ID. This method
        // returns true once we have all nonces for all other signing
        // participants.
        MuSig2RegisterNonces(MuSig2SessionID,
                [][musig2.PubNonceSize]byte) (bool, error)

        // MuSig2Sign creates a partial signature using the local signing key
        // that was specified when the session was created. This can only be
        // called when all public nonces of all participants are known and have
        // been registered with the session. If this node isn't responsible for
        // combining all the partial signatures, then the cleanup parameter
        // should be set, indicating that the session can be removed from memory
        // once the signature was produced.
        MuSig2Sign(MuSig2SessionID, [sha256.Size]byte,
                bool) (*musig2.PartialSignature, error)

        // MuSig2CombineSig combines the given partial signature(s) with the
        // local one, if it already exists. Once a partial signature of all
        // participants is registered, the final signature will be combined and
        // returned.
        MuSig2CombineSig(MuSig2SessionID,
                []*musig2.PartialSignature) (*schnorr.Signature, bool, error)

        // MuSig2Cleanup removes a session from memory to free up resources.
        MuSig2Cleanup(MuSig2SessionID) error
}

// MuSig2Context is an interface that is an abstraction over the MuSig2 signing
// context. This interface does not contain all of the methods the underlying
// implementations have because those use package specific types which cannot
// easily be made compatible. Those calls (such as NewSession) are implemented
// in this package instead and do the necessary type switch (see
// MuSig2CreateContext).
type MuSig2Context interface {
        // SigningKeys returns the set of keys used for signing.
        SigningKeys() []*btcec.PublicKey

        // CombinedKey returns the combined public key that will be used to
        // generate multi-signatures  against.
        CombinedKey() (*btcec.PublicKey, error)

        // TaprootInternalKey returns the internal taproot key, which is the
        // aggregated key _before_ the tweak is applied. If a taproot tweak was
        // specified, then CombinedKey() will return the fully tweaked output
        // key, with this method returning the internal key. If a taproot tweak
        // wasn't specified, then this method will return an error.
        TaprootInternalKey() (*btcec.PublicKey, error)
}

// MuSig2Session is an interface that is an abstraction over the MuSig2 signing
// session. This interface does not contain all of the methods the underlying
// implementations have because those use package specific types which cannot
// easily be made compatible. Those calls (such as CombineSig or Sign) are
// implemented in this package instead and do the necessary type switch (see
// MuSig2CombineSig or MuSig2Sign).
type MuSig2Session interface {
        // FinalSig returns the final combined multi-signature, if present.
        FinalSig() *schnorr.Signature

        // PublicNonce returns the public nonce for a signer. This should be
        // sent to other parties before signing begins, so they can compute the
        // aggregated public nonce.
        PublicNonce() [musig2.PubNonceSize]byte

        // NumRegisteredNonces returns the total number of nonces that have been
        // registered so far.
        NumRegisteredNonces() int

        // RegisterPubNonce should be called for each public nonce from the set
        // of signers. This method returns true once all the public nonces have
        // been accounted for.
        RegisterPubNonce(nonce [musig2.PubNonceSize]byte) (bool, error)
}

// MuSig2SessionInfo is a struct for keeping track of a signing session
// information in memory.
type MuSig2SessionInfo struct {
        // SessionID is the wallet's internal unique ID of this session. The ID
        // is the hash over the combined public key and the local public nonces.
        SessionID [32]byte

        // Version is the version of the MuSig2 BIP this signing session is
        // using.
        Version MuSig2Version

        // PublicNonce contains the public nonce of the local signer session.
        PublicNonce [musig2.PubNonceSize]byte

        // CombinedKey is the combined public key with all tweaks applied to it.
        CombinedKey *btcec.PublicKey

        // TaprootTweak indicates whether a taproot tweak (BIP-0086 or script
        // path) was used. The TaprootInternalKey will only be set if this is
        // set to true.
        TaprootTweak bool

        // TaprootInternalKey is the raw combined public key without any tweaks
        // applied to it. This is only set if TaprootTweak is true.
        TaprootInternalKey *btcec.PublicKey

        // HaveAllNonces indicates whether this session already has all nonces
        // of all other signing participants registered.
        HaveAllNonces bool

        // HaveAllSigs indicates whether this session already has all partial
        // signatures of all other signing participants registered.
        HaveAllSigs bool
}

// MuSig2Tweaks is a struct that contains all tweaks that can be applied to a
// MuSig2 combined public key.
type MuSig2Tweaks struct {
        // GenericTweaks is a list of normal tweaks to apply to the combined
        // public key (and to the private key when signing).
        GenericTweaks []musig2.KeyTweakDesc

        // TaprootBIP0086Tweak indicates that the final key should use the
        // taproot tweak as defined in BIP 341, with the BIP 86 modification:
        //     outputKey = internalKey + h_tapTweak(internalKey)*G.
        // In this case, the aggregated key before the tweak will be used as the
        // internal key. If this is set to true then TaprootTweak will be
        // ignored.
        TaprootBIP0086Tweak bool

        // TaprootTweak specifies that the final key should use the taproot
        // tweak as defined in BIP 341:
        //     outputKey = internalKey + h_tapTweak(internalKey || scriptRoot).
        // In this case, the aggregated key before the tweak will be used as the
        // internal key. Will be ignored if TaprootBIP0086Tweak is set to true.
        TaprootTweak []byte
}

// HasTaprootTweak returns true if either a taproot BIP0086 tweak or a taproot
// script root tweak is set.
func (t *MuSig2Tweaks) HasTaprootTweak() bool <span class="cov0" title="0">{
        return t.TaprootBIP0086Tweak || len(t.TaprootTweak) &gt; 0
}</span>

// ToContextOptions converts the tweak descriptor to context options.
func (t *MuSig2Tweaks) ToContextOptions() []musig2.ContextOption <span class="cov0" title="0">{
        var tweakOpts []musig2.ContextOption
        if len(t.GenericTweaks) &gt; 0 </span><span class="cov0" title="0">{
                tweakOpts = append(tweakOpts, musig2.WithTweakedContext(
                        t.GenericTweaks...,
                ))
        }</span>

        // The BIP0086 tweak and the taproot script tweak are mutually
        // exclusive.
        <span class="cov0" title="0">if t.TaprootBIP0086Tweak </span><span class="cov0" title="0">{
                tweakOpts = append(tweakOpts, musig2.WithBip86TweakCtx())
        }</span> else<span class="cov0" title="0"> if len(t.TaprootTweak) &gt; 0 </span><span class="cov0" title="0">{
                tweakOpts = append(tweakOpts, musig2.WithTaprootTweakCtx(
                        t.TaprootTweak,
                ))
        }</span>

        <span class="cov0" title="0">return tweakOpts</span>
}

// ToV040ContextOptions converts the tweak descriptor to v0.4.0 context options.
func (t *MuSig2Tweaks) ToV040ContextOptions() []musig2v040.ContextOption <span class="cov0" title="0">{
        var tweakOpts []musig2v040.ContextOption
        if len(t.GenericTweaks) &gt; 0 </span><span class="cov0" title="0">{
                genericTweaksCopy := make(
                        []musig2v040.KeyTweakDesc, len(t.GenericTweaks),
                )
                for idx := range t.GenericTweaks </span><span class="cov0" title="0">{
                        genericTweaksCopy[idx] = musig2v040.KeyTweakDesc{
                                Tweak:   t.GenericTweaks[idx].Tweak,
                                IsXOnly: t.GenericTweaks[idx].IsXOnly,
                        }
                }</span>
                <span class="cov0" title="0">tweakOpts = append(tweakOpts, musig2v040.WithTweakedContext(
                        genericTweaksCopy...,
                ))</span>
        }

        // The BIP0086 tweak and the taproot script tweak are mutually
        // exclusive.
        <span class="cov0" title="0">if t.TaprootBIP0086Tweak </span><span class="cov0" title="0">{
                tweakOpts = append(tweakOpts, musig2v040.WithBip86TweakCtx())
        }</span> else<span class="cov0" title="0"> if len(t.TaprootTweak) &gt; 0 </span><span class="cov0" title="0">{
                tweakOpts = append(tweakOpts, musig2v040.WithTaprootTweakCtx(
                        t.TaprootTweak,
                ))
        }</span>

        <span class="cov0" title="0">return tweakOpts</span>
}

// MuSig2ParsePubKeys parses a list of raw public keys as the signing keys of a
// MuSig2 signing session.
func MuSig2ParsePubKeys(bipVersion MuSig2Version,
        rawPubKeys [][]byte) ([]*btcec.PublicKey, error) <span class="cov0" title="0">{

        allSignerPubKeys := make([]*btcec.PublicKey, len(rawPubKeys))
        if len(rawPubKeys) &lt; 2 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("need at least two signing public keys")
        }</span>

        <span class="cov0" title="0">for idx, pubKeyBytes := range rawPubKeys </span><span class="cov0" title="0">{
                switch bipVersion </span>{
                case MuSig2Version040:<span class="cov0" title="0">
                        pubKey, err := schnorr.ParsePubKey(pubKeyBytes)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("error parsing signer "+
                                        "public key %d for v0.4.0 (x-only "+
                                        "format): %v", idx, err)
                        }</span>
                        <span class="cov0" title="0">allSignerPubKeys[idx] = pubKey</span>

                case MuSig2Version100RC2:<span class="cov0" title="0">
                        pubKey, err := btcec.ParsePubKey(pubKeyBytes)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("error parsing signer "+
                                        "public key %d for v1.0.0rc2 ("+
                                        "compressed format): %v", idx, err)
                        }</span>
                        <span class="cov0" title="0">allSignerPubKeys[idx] = pubKey</span>

                default:<span class="cov0" title="0">
                        return nil, fmt.Errorf("unknown MuSig2 version: &lt;%d&gt;",
                                bipVersion)</span>
                }
        }

        <span class="cov0" title="0">return allSignerPubKeys, nil</span>
}

// MuSig2CombineKeys combines the given set of public keys into a single
// combined MuSig2 combined public key, applying the given tweaks.
func MuSig2CombineKeys(bipVersion MuSig2Version,
        allSignerPubKeys []*btcec.PublicKey, sortKeys bool,
        tweaks *MuSig2Tweaks) (*musig2.AggregateKey, error) <span class="cov0" title="0">{

        switch bipVersion </span>{
        case MuSig2Version040:<span class="cov0" title="0">
                return combineKeysV040(allSignerPubKeys, sortKeys, tweaks)</span>

        case MuSig2Version100RC2:<span class="cov0" title="0">
                return combineKeysV100RC2(allSignerPubKeys, sortKeys, tweaks)</span>

        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unknown MuSig2 version: &lt;%d&gt;",
                        bipVersion)</span>
        }
}

// combineKeysV100rc1 implements the MuSigCombineKeys logic for the MuSig2 BIP
// draft version 1.0.0rc2.
func combineKeysV100RC2(allSignerPubKeys []*btcec.PublicKey, sortKeys bool,
        tweaks *MuSig2Tweaks) (*musig2.AggregateKey, error) <span class="cov0" title="0">{

        // Convert the tweak options into the appropriate MuSig2 API functional
        // options.
        var keyAggOpts []musig2.KeyAggOption
        switch </span>{
        case tweaks.TaprootBIP0086Tweak:<span class="cov0" title="0">
                keyAggOpts = append(keyAggOpts, musig2.WithBIP86KeyTweak())</span>
        case len(tweaks.TaprootTweak) &gt; 0:<span class="cov0" title="0">
                keyAggOpts = append(keyAggOpts, musig2.WithTaprootKeyTweak(
                        tweaks.TaprootTweak,
                ))</span>
        case len(tweaks.GenericTweaks) &gt; 0:<span class="cov0" title="0">
                keyAggOpts = append(keyAggOpts, musig2.WithKeyTweaks(
                        tweaks.GenericTweaks...,
                ))</span>
        }

        // Then we'll use this information to compute the aggregated public key.
        <span class="cov0" title="0">combinedKey, _, _, err := musig2.AggregateKeys(
                allSignerPubKeys, sortKeys, keyAggOpts...,
        )
        return combinedKey, err</span>
}

// combineKeysV040 implements the MuSigCombineKeys logic for the MuSig2 BIP
// draft version 0.4.0.
func combineKeysV040(allSignerPubKeys []*btcec.PublicKey, sortKeys bool,
        tweaks *MuSig2Tweaks) (*musig2.AggregateKey, error) <span class="cov0" title="0">{

        // Convert the tweak options into the appropriate MuSig2 API functional
        // options.
        var keyAggOpts []musig2v040.KeyAggOption
        switch </span>{
        case tweaks.TaprootBIP0086Tweak:<span class="cov0" title="0">
                keyAggOpts = append(keyAggOpts, musig2v040.WithBIP86KeyTweak())</span>
        case len(tweaks.TaprootTweak) &gt; 0:<span class="cov0" title="0">
                keyAggOpts = append(keyAggOpts, musig2v040.WithTaprootKeyTweak(
                        tweaks.TaprootTweak,
                ))</span>
        case len(tweaks.GenericTweaks) &gt; 0:<span class="cov0" title="0">
                genericTweaksCopy := make(
                        []musig2v040.KeyTweakDesc, len(tweaks.GenericTweaks),
                )
                for idx := range tweaks.GenericTweaks </span><span class="cov0" title="0">{
                        genericTweaksCopy[idx] = musig2v040.KeyTweakDesc{
                                Tweak:   tweaks.GenericTweaks[idx].Tweak,
                                IsXOnly: tweaks.GenericTweaks[idx].IsXOnly,
                        }
                }</span>
                <span class="cov0" title="0">keyAggOpts = append(keyAggOpts, musig2v040.WithKeyTweaks(
                        genericTweaksCopy...,
                ))</span>
        }

        // Then we'll use this information to compute the aggregated public key.
        <span class="cov0" title="0">combinedKey, _, _, err := musig2v040.AggregateKeys(
                allSignerPubKeys, sortKeys, keyAggOpts...,
        )

        // Copy the result back into the default version's native type.
        return &amp;musig2.AggregateKey{
                FinalKey:      combinedKey.FinalKey,
                PreTweakedKey: combinedKey.PreTweakedKey,
        }, err</span>
}

// MuSig2CreateContext creates a new MuSig2 signing context.
func MuSig2CreateContext(bipVersion MuSig2Version, privKey *btcec.PrivateKey,
        allSignerPubKeys []*btcec.PublicKey, tweaks *MuSig2Tweaks,
        localNonces *musig2.Nonces,
) (MuSig2Context, MuSig2Session, error) <span class="cov0" title="0">{

        switch bipVersion </span>{
        case MuSig2Version040:<span class="cov0" title="0">
                return createContextV040(
                        privKey, allSignerPubKeys, tweaks, localNonces,
                )</span>

        case MuSig2Version100RC2:<span class="cov0" title="0">
                return createContextV100RC2(
                        privKey, allSignerPubKeys, tweaks, localNonces,
                )</span>

        default:<span class="cov0" title="0">
                return nil, nil, fmt.Errorf("unknown MuSig2 version: &lt;%d&gt;",
                        bipVersion)</span>
        }
}

// createContextV100RC2 implements the MuSig2CreateContext logic for the MuSig2
// BIP draft version 1.0.0rc2.
func createContextV100RC2(privKey *btcec.PrivateKey,
        allSignerPubKeys []*btcec.PublicKey, tweaks *MuSig2Tweaks,
        localNonces *musig2.Nonces,
) (*musig2.Context, *musig2.Session, error) <span class="cov0" title="0">{

        // The context keeps track of all signing keys and our local key.
        allOpts := append(
                []musig2.ContextOption{
                        musig2.WithKnownSigners(allSignerPubKeys),
                },
                tweaks.ToContextOptions()...,
        )
        muSigContext, err := musig2.NewContext(privKey, true, allOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("error creating MuSig2 signing "+
                        "context: %v", err)
        }</span>

        <span class="cov0" title="0">var sessionOpts []musig2.SessionOption
        if localNonces != nil </span><span class="cov0" title="0">{
                sessionOpts = append(
                        sessionOpts, musig2.WithPreGeneratedNonce(localNonces),
                )
        }</span>

        <span class="cov0" title="0">muSigSession, err := muSigContext.NewSession(sessionOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("error creating MuSig2 signing "+
                        "session: %v", err)
        }</span>

        <span class="cov0" title="0">return muSigContext, muSigSession, nil</span>
}

// createContextV040 implements the MuSig2CreateContext logic for the MuSig2 BIP
// draft version 0.4.0.
func createContextV040(privKey *btcec.PrivateKey,
        allSignerPubKeys []*btcec.PublicKey, tweaks *MuSig2Tweaks,
        _ *musig2.Nonces,
) (*musig2v040.Context, *musig2v040.Session, error) <span class="cov0" title="0">{

        // The context keeps track of all signing keys and our local key.
        allOpts := append(
                []musig2v040.ContextOption{
                        musig2v040.WithKnownSigners(allSignerPubKeys),
                },
                tweaks.ToV040ContextOptions()...,
        )
        muSigContext, err := musig2v040.NewContext(privKey, true, allOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("error creating MuSig2 signing "+
                        "context: %v", err)
        }</span>

        <span class="cov0" title="0">muSigSession, err := muSigContext.NewSession()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("error creating MuSig2 signing "+
                        "session: %v", err)
        }</span>

        <span class="cov0" title="0">return muSigContext, muSigSession, nil</span>
}

// MuSig2Sign calls the Sign() method on the given versioned signing session and
// returns the result in the most recent version of the MuSig2 API.
func MuSig2Sign(session MuSig2Session, msg [32]byte,
        withSortedKeys bool) (*musig2.PartialSignature, error) <span class="cov0" title="0">{

        switch s := session.(type) </span>{
        case *musig2.Session:<span class="cov0" title="0">
                var opts []musig2.SignOption
                if withSortedKeys </span><span class="cov0" title="0">{
                        opts = append(opts, musig2.WithSortedKeys())
                }</span>
                <span class="cov0" title="0">partialSig, err := s.Sign(msg, opts...)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error signing with local key: "+
                                "%v", err)
                }</span>

                <span class="cov0" title="0">return partialSig, nil</span>

        case *musig2v040.Session:<span class="cov0" title="0">
                var opts []musig2v040.SignOption
                if withSortedKeys </span><span class="cov0" title="0">{
                        opts = append(opts, musig2v040.WithSortedKeys())
                }</span>
                <span class="cov0" title="0">partialSig, err := s.Sign(msg, opts...)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error signing with local key: "+
                                "%v", err)
                }</span>

                <span class="cov0" title="0">return &amp;musig2.PartialSignature{
                        S: partialSig.S,
                        R: partialSig.R,
                }, nil</span>

        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("invalid session type &lt;%T&gt;", s)</span>
        }
}

// MuSig2CombineSig calls the CombineSig() method on the given versioned signing
// session and returns the result in the most recent version of the MuSig2 API.
func MuSig2CombineSig(session MuSig2Session,
        otherPartialSig *musig2.PartialSignature) (bool, error) <span class="cov0" title="0">{

        switch s := session.(type) </span>{
        case *musig2.Session:<span class="cov0" title="0">
                haveAllSigs, err := s.CombineSig(otherPartialSig)
                if err != nil </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("error combining partial "+
                                "signature: %v", err)
                }</span>

                <span class="cov0" title="0">return haveAllSigs, nil</span>

        case *musig2v040.Session:<span class="cov0" title="0">
                haveAllSigs, err := s.CombineSig(&amp;musig2v040.PartialSignature{
                        S: otherPartialSig.S,
                        R: otherPartialSig.R,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("error combining partial "+
                                "signature: %v", err)
                }</span>

                <span class="cov0" title="0">return haveAllSigs, nil</span>

        default:<span class="cov0" title="0">
                return false, fmt.Errorf("invalid session type &lt;%T&gt;", s)</span>
        }
}

// NewMuSig2SessionID returns the unique ID of a MuSig2 session by using the
// combined key and the local public nonces and hashing that data.
func NewMuSig2SessionID(combinedKey *btcec.PublicKey,
        publicNonces [musig2.PubNonceSize]byte) MuSig2SessionID <span class="cov0" title="0">{

        // We hash the data to save some bytes in memory.
        hash := sha256.New()
        _, _ = hash.Write(combinedKey.SerializeCompressed())
        _, _ = hash.Write(publicNonces[:])

        id := MuSig2SessionID{}
        copy(id[:], hash.Sum(nil))
        return id
}</span>

// SerializePartialSignature encodes the partial signature to a fixed size byte
// array.
func SerializePartialSignature(
        sig *musig2.PartialSignature) ([MuSig2PartialSigSize]byte, error) <span class="cov0" title="0">{

        var (
                buf    bytes.Buffer
                result [MuSig2PartialSigSize]byte
        )
        if err := sig.Encode(&amp;buf); err != nil </span><span class="cov0" title="0">{
                return result, fmt.Errorf("error encoding partial signature: "+
                        "%v", err)
        }</span>

        <span class="cov0" title="0">if buf.Len() != MuSig2PartialSigSize </span><span class="cov0" title="0">{
                return result, fmt.Errorf("invalid partial signature length, "+
                        "got %d wanted %d", buf.Len(), MuSig2PartialSigSize)
        }</span>

        <span class="cov0" title="0">copy(result[:], buf.Bytes())

        return result, nil</span>
}

// DeserializePartialSignature decodes a partial signature from a byte slice.
func DeserializePartialSignature(scalarBytes []byte) (*musig2.PartialSignature,
        error) <span class="cov0" title="0">{

        if len(scalarBytes) != MuSig2PartialSigSize </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid partial signature length, got "+
                        "%d wanted %d", len(scalarBytes), MuSig2PartialSigSize)
        }</span>

        <span class="cov0" title="0">sig := &amp;musig2.PartialSignature{}
        if err := sig.Decode(bytes.NewReader(scalarBytes)); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error decoding partial signature: %w",
                        err)
        }</span>

        <span class="cov0" title="0">return sig, nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package input

import (
        "crypto/sha256"
        "fmt"

        "github.com/btcsuite/btcd/btcec/v2"
        "github.com/btcsuite/btcd/btcec/v2/schnorr"
        "github.com/btcsuite/btcd/btcec/v2/schnorr/musig2"
        "github.com/lightningnetwork/lnd/keychain"
        "github.com/lightningnetwork/lnd/lnutils"
        "github.com/lightningnetwork/lnd/multimutex"
)

// MuSig2State is a struct that holds on to the internal signing session state
// of a MuSig2 session.
type MuSig2State struct {
        // MuSig2SessionInfo is the associated meta information of the signing
        // session.
        MuSig2SessionInfo

        // context is the signing context responsible for keeping track of the
        // public keys involved in the signing process.
        context MuSig2Context

        // session is the signing session responsible for keeping track of the
        // nonces and partial signatures involved in the signing process.
        session MuSig2Session
}

// PrivKeyFetcher is used to fetch a private key that matches a given key desc.
type PrivKeyFetcher func(*keychain.KeyDescriptor) (*btcec.PrivateKey, error)

// MusigSessionMusigSessionManager houses the state needed to manage concurrent
// musig sessions. Each session is identified by a unique session ID which is
// used by callers to interact with a given session.
type MusigSessionManager struct {
        keyFetcher PrivKeyFetcher

        sessionMtx *multimutex.Mutex[MuSig2SessionID]

        musig2Sessions *lnutils.SyncMap[MuSig2SessionID, *MuSig2State]
}

// NewMusigSessionManager creates a new musig manager given an abstract key
// fetcher.
func NewMusigSessionManager(keyFetcher PrivKeyFetcher) *MusigSessionManager <span class="cov0" title="0">{
        return &amp;MusigSessionManager{
                keyFetcher: keyFetcher,
                musig2Sessions: &amp;lnutils.SyncMap[
                        MuSig2SessionID, *MuSig2State,
                ]{},
                sessionMtx: multimutex.NewMutex[MuSig2SessionID](),
        }
}</span>

// MuSig2CreateSession creates a new MuSig2 signing session using the local key
// identified by the key locator. The complete list of all public keys of all
// signing parties must be provided, including the public key of the local
// signing key. If nonces of other parties are already known, they can be
// submitted as well to reduce the number of method calls necessary later on.
//
// The set of sessionOpts are _optional_ and allow a caller to modify the
// generated sessions. As an example the local nonce might already be generated
// ahead of time.
func (m *MusigSessionManager) MuSig2CreateSession(bipVersion MuSig2Version,
        keyLoc keychain.KeyLocator, allSignerPubKeys []*btcec.PublicKey,
        tweaks *MuSig2Tweaks, otherSignerNonces [][musig2.PubNonceSize]byte,
        localNonces *musig2.Nonces) (*MuSig2SessionInfo, error) <span class="cov0" title="0">{

        // We need to derive the private key for signing. In the remote signing
        // setup, this whole RPC call will be forwarded to the signing
        // instance, which requires it to be stateful.
        privKey, err := m.keyFetcher(&amp;keychain.KeyDescriptor{
                KeyLocator: keyLoc,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error deriving private key: %w", err)
        }</span>

        // Create a signing context and session with the given private key and
        // list of all known signer public keys.
        <span class="cov0" title="0">musigContext, musigSession, err := MuSig2CreateContext(
                bipVersion, privKey, allSignerPubKeys, tweaks, localNonces,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error creating signing context: %w",
                        err)
        }</span>

        // Add all nonces we might've learned so far.
        <span class="cov0" title="0">haveAllNonces := false
        for _, otherSignerNonce := range otherSignerNonces </span><span class="cov0" title="0">{
                haveAllNonces, err = musigSession.RegisterPubNonce(
                        otherSignerNonce,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error registering other "+
                                "signer public nonce: %v", err)
                }</span>
        }

        // Register the new session.
        <span class="cov0" title="0">combinedKey, err := musigContext.CombinedKey()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error getting combined key: %w", err)
        }</span>
        <span class="cov0" title="0">session := &amp;MuSig2State{
                MuSig2SessionInfo: MuSig2SessionInfo{
                        SessionID: NewMuSig2SessionID(
                                combinedKey, musigSession.PublicNonce(),
                        ),
                        Version:       bipVersion,
                        PublicNonce:   musigSession.PublicNonce(),
                        CombinedKey:   combinedKey,
                        TaprootTweak:  tweaks.HasTaprootTweak(),
                        HaveAllNonces: haveAllNonces,
                },
                context: musigContext,
                session: musigSession,
        }

        // The internal key is only calculated if we are using a taproot tweak
        // and need to know it for a potential script spend.
        if tweaks.HasTaprootTweak() </span><span class="cov0" title="0">{
                internalKey, err := musigContext.TaprootInternalKey()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error getting internal key: %w",
                                err)
                }</span>
                <span class="cov0" title="0">session.TaprootInternalKey = internalKey</span>
        }

        // Since we generate new nonces for every session, there is no way that
        // a session with the same ID already exists. So even if we call the API
        // twice with the same signers, we still get a new ID.
        //
        // We'll use just all zeroes as the session ID for the mutex, as this
        // is a "global" action.
        <span class="cov0" title="0">m.musig2Sessions.Store(session.SessionID, session)

        return &amp;session.MuSig2SessionInfo, nil</span>
}

// MuSig2Sign creates a partial signature using the local signing key
// that was specified when the session was created. This can only be
// called when all public nonces of all participants are known and have
// been registered with the session. If this node isn't responsible for
// combining all the partial signatures, then the cleanup parameter
// should be set, indicating that the session can be removed from memory
// once the signature was produced.
func (m *MusigSessionManager) MuSig2Sign(sessionID MuSig2SessionID,
        msg [sha256.Size]byte, cleanUp bool) (*musig2.PartialSignature, error) <span class="cov0" title="0">{

        // We hold the lock during the whole operation, we don't want any
        // interference with calls that might come through in parallel for the
        // same session.
        m.sessionMtx.Lock(sessionID)
        defer m.sessionMtx.Unlock(sessionID)

        session, ok := m.musig2Sessions.Load(sessionID)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("session with ID %x not found",
                        sessionID[:])
        }</span>

        // We can only sign once we have all other signer's nonces.
        <span class="cov0" title="0">if !session.HaveAllNonces </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("only have %d of %d required nonces",
                        session.session.NumRegisteredNonces(),
                        len(session.context.SigningKeys()))
        }</span>

        // Create our own partial signature with the local signing key.
        <span class="cov0" title="0">partialSig, err := MuSig2Sign(session.session, msg, true)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error signing with local key: %w", err)
        }</span>

        // Clean up our local state if requested.
        <span class="cov0" title="0">if cleanUp </span><span class="cov0" title="0">{
                m.musig2Sessions.Delete(sessionID)
        }</span>

        <span class="cov0" title="0">return partialSig, nil</span>
}

// MuSig2CombineSig combines the given partial signature(s) with the
// local one, if it already exists. Once a partial signature of all
// participants is registered, the final signature will be combined and
// returned.
func (m *MusigSessionManager) MuSig2CombineSig(sessionID MuSig2SessionID,
        partialSigs []*musig2.PartialSignature) (*schnorr.Signature, bool,
        error) <span class="cov0" title="0">{

        // We hold the lock during the whole operation, we don't want any
        // interference with calls that might come through in parallel for the
        // same session.
        m.sessionMtx.Lock(sessionID)
        defer m.sessionMtx.Unlock(sessionID)

        session, ok := m.musig2Sessions.Load(sessionID)
        if !ok </span><span class="cov0" title="0">{
                return nil, false, fmt.Errorf("session with ID %x not found",
                        sessionID[:])
        }</span>

        // Make sure we don't exceed the number of expected partial signatures
        // as that would indicate something is wrong with the signing setup.
        <span class="cov0" title="0">if session.HaveAllSigs </span><span class="cov0" title="0">{
                return nil, true, fmt.Errorf("already have all partial" +
                        "signatures")
        }</span>

        // Add all sigs we got so far.
        <span class="cov0" title="0">var (
                finalSig *schnorr.Signature
                err      error
        )
        for _, otherPartialSig := range partialSigs </span><span class="cov0" title="0">{
                session.HaveAllSigs, err = MuSig2CombineSig(
                        session.session, otherPartialSig,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, false, fmt.Errorf("error combining "+
                                "partial signature: %w", err)
                }</span>
        }

        // If we have all partial signatures, we should be able to get the
        // complete signature now. We also remove this session from memory since
        // there is nothing more left to do.
        <span class="cov0" title="0">if session.HaveAllSigs </span><span class="cov0" title="0">{
                finalSig = session.session.FinalSig()
                m.musig2Sessions.Delete(sessionID)
        }</span>

        <span class="cov0" title="0">return finalSig, session.HaveAllSigs, nil</span>
}

// MuSig2Cleanup removes a session from memory to free up resources.
func (m *MusigSessionManager) MuSig2Cleanup(sessionID MuSig2SessionID) error <span class="cov0" title="0">{
        // We hold the lock during the whole operation, we don't want any
        // interference with calls that might come through in parallel for the
        // same session.
        m.sessionMtx.Lock(sessionID)
        defer m.sessionMtx.Unlock(sessionID)

        _, ok := m.musig2Sessions.Load(sessionID)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("session with ID %x not found", sessionID[:])
        }</span>

        <span class="cov0" title="0">m.musig2Sessions.Delete(sessionID)

        return nil</span>
}

// MuSig2RegisterNonces registers one or more public nonces of other signing
// participants for a session identified by its ID. This method returns true
// once we have all nonces for all other signing participants.
func (m *MusigSessionManager) MuSig2RegisterNonces(sessionID MuSig2SessionID,
        otherSignerNonces [][musig2.PubNonceSize]byte) (bool, error) <span class="cov0" title="0">{

        // We hold the lock during the whole operation, we don't want any
        // interference with calls that might come through in parallel for the
        // same session.
        m.sessionMtx.Lock(sessionID)
        defer m.sessionMtx.Unlock(sessionID)

        session, ok := m.musig2Sessions.Load(sessionID)
        if !ok </span><span class="cov0" title="0">{
                return false, fmt.Errorf("session with ID %x not found",
                        sessionID[:])
        }</span>

        // Make sure we don't exceed the number of expected nonces as that would
        // indicate something is wrong with the signing setup.
        <span class="cov0" title="0">if session.HaveAllNonces </span><span class="cov0" title="0">{
                return true, fmt.Errorf("already have all nonces")
        }</span>

        <span class="cov0" title="0">numSigners := len(session.context.SigningKeys())
        remainingNonces := numSigners - session.session.NumRegisteredNonces()
        if len(otherSignerNonces) &gt; remainingNonces </span><span class="cov0" title="0">{
                return false, fmt.Errorf("only %d other nonces remaining but "+
                        "trying to register %d more", remainingNonces,
                        len(otherSignerNonces))
        }</span>

        // Add all nonces we've learned so far.
        <span class="cov0" title="0">var err error
        for _, otherSignerNonce := range otherSignerNonces </span><span class="cov0" title="0">{
                session.HaveAllNonces, err = session.session.RegisterPubNonce(
                        otherSignerNonce,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("error registering other "+
                                "signer public nonce: %v", err)
                }</span>
        }

        <span class="cov0" title="0">return session.HaveAllNonces, nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package input

import (
        "errors"

        "github.com/btcsuite/btcd/btcec/v2"
        "github.com/btcsuite/btcd/txscript"
        "github.com/lightningnetwork/lnd/lnutils"
)

// ErrUnknownScriptType is returned when an unknown script type is encountered.
var ErrUnknownScriptType = errors.New("unknown script type")

// ScriptPath is used to indicate the spending path of a given script. Possible
// paths include: timeout, success, revocation, and others.
type ScriptPath uint8

const (
        // ScriptPathTimeout is a script path that can be taken only after a
        // timeout has elapsed.
        ScriptPathTimeout ScriptPath = iota

        // ScriptPathSuccess is a script path that can be taken only with some
        // secret data.
        ScriptPathSuccess

        // ScriptPathRevocation is a script path used when a contract has been
        // breached.
        ScriptPathRevocation

        // ScriptPathDelay is a script path used when a contract has relative
        // delay that must elapse before it can be swept.
        ScriptPathDelay
)

// ScriptDescriptor is an interface that abstracts over the various ways a
// pkScript can be spent from an output. This supports both normal p2wsh
// (witness script, etc.), and also tapscript paths which have distinct
// tapscript leaves.
type ScriptDescriptor interface {
        // PkScript is the public key script that commits to the final
        // contract.
        PkScript() []byte

        // WitnessScriptToSign returns the witness script that we'll use when
        // signing for the remote party, and also verifying signatures on our
        // transactions. As an example, when we create an outgoing HTLC for the
        // remote party, we want to sign their success path.
        //
        // TODO(roasbeef): break out into HTLC specific desc? or Branching Desc
        // w/ the below?
        WitnessScriptToSign() []byte

        // WitnessScriptForPath returns the witness script for the given
        // spending path. An error is returned if the path is unknown. This is
        // useful as when constructing a control block for a given path, one
        // also needs witness script being signed.
        WitnessScriptForPath(path ScriptPath) ([]byte, error)
}

// TapscriptDescriptor is a super-set of the normal script multiplexer that
// adds in taproot specific details such as the control block, or top-level tap
// tweak.
type TapscriptDescriptor interface {
        ScriptDescriptor

        // CtrlBlockForPath returns the control block for the given spending
        // path. For unknown paths, an error is returned.
        CtrlBlockForPath(path ScriptPath) (*txscript.ControlBlock, error)

        // TapTweak returns the top-level taproot tweak for the script.
        TapTweak() []byte

        // TapScriptTree returns the underlying tapscript tree.
        TapScriptTree() *txscript.IndexedTapScriptTree

        // Tree returns the underlying ScriptTree.
        Tree() ScriptTree
}

// ScriptTree holds the contents needed to spend a script within a tapscript
// tree.
type ScriptTree struct {
        // InternalKey is the internal key of the Taproot output key.
        InternalKey *btcec.PublicKey

        // TaprootKey is the key that will be used to generate the taproot
        // output.
        TaprootKey *btcec.PublicKey

        // TapscriptTree is the full tapscript tree that also includes the
        // control block needed to spend each of the leaves.
        TapscriptTree *txscript.IndexedTapScriptTree

        // TapscriptTreeRoot is the root hash of the tapscript tree.
        TapscriptRoot []byte
}

// PkScript is the public key script that commits to the final contract.
func (s *ScriptTree) PkScript() []byte <span class="cov0" title="0">{
        // Script building can never internally return an error, so we ignore
        // the error to simplify the interface.
        pkScript, _ := PayToTaprootScript(s.TaprootKey)
        return pkScript
}</span>

// TapTweak returns the top-level taproot tweak for the script.
func (s *ScriptTree) TapTweak() []byte <span class="cov0" title="0">{
        return lnutils.ByteSlice(s.TapscriptTree.RootNode.TapHash())
}</span>

// TapScriptTree returns the underlying tapscript tree.
func (s *ScriptTree) TapScriptTree() *txscript.IndexedTapScriptTree <span class="cov0" title="0">{
        return s.TapscriptTree
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package input

import (
        "bytes"
        "crypto/sha256"
        "encoding/hex"
        "fmt"

        "github.com/btcsuite/btcd/btcec/v2"
        "github.com/btcsuite/btcd/btcec/v2/ecdsa"
        "github.com/btcsuite/btcd/btcec/v2/schnorr"
        "github.com/btcsuite/btcd/btcec/v2/schnorr/musig2"
        "github.com/btcsuite/btcd/btcutil"
        "github.com/btcsuite/btcd/chaincfg/chainhash"
        "github.com/btcsuite/btcd/txscript"
        "github.com/btcsuite/btcd/wire"
        "github.com/lightningnetwork/lnd/fn/v2"
        "github.com/lightningnetwork/lnd/lntypes"
        "github.com/lightningnetwork/lnd/lnutils"
        "golang.org/x/crypto/ripemd160"
)

var (
        // TODO(roasbeef): remove these and use the one's defined in txscript
        // within testnet-L.

        // SequenceLockTimeSeconds is the 22nd bit which indicates the lock
        // time is in seconds.
        SequenceLockTimeSeconds = uint32(1 &lt;&lt; 22)
)

// MustParsePubKey parses a hex encoded public key string into a public key and
// panic if parsing fails.
func MustParsePubKey(pubStr string) btcec.PublicKey <span class="cov8" title="1">{
        pubBytes, err := hex.DecodeString(pubStr)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="1">pub, err := btcec.ParsePubKey(pubBytes)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="1">return *pub</span>
}

// TaprootNUMSHex is the hex encoded version of the taproot NUMs key.
const TaprootNUMSHex = "02dca094751109d0bd055d03565874e8276dd53e926b44e3bd1bb" +
        "6bf4bc130a279"

var (
        // TaprootNUMSKey is a NUMS key (nothing up my sleeves number) that has
        // no known private key. This was generated using the following script:
        // https://github.com/lightninglabs/lightning-node-connect/tree/
        // master/mailbox/numsgen, with the seed phrase "Lightning Simple
        // Taproot".
        TaprootNUMSKey = MustParsePubKey(TaprootNUMSHex)
)

// Signature is an interface for objects that can populate signatures during
// witness construction.
type Signature interface {
        // Serialize returns a DER-encoded ECDSA signature.
        Serialize() []byte

        // Verify return true if the ECDSA signature is valid for the passed
        // message digest under the provided public key.
        Verify([]byte, *btcec.PublicKey) bool
}

// ParseSignature parses a raw signature into an input.Signature instance. This
// routine supports parsing normal ECDSA DER encoded signatures, as well as
// schnorr signatures.
func ParseSignature(rawSig []byte) (Signature, error) <span class="cov0" title="0">{
        if len(rawSig) == schnorr.SignatureSize </span><span class="cov0" title="0">{
                return schnorr.ParseSignature(rawSig)
        }</span>

        <span class="cov0" title="0">return ecdsa.ParseDERSignature(rawSig)</span>
}

// WitnessScriptHash generates a pay-to-witness-script-hash public key script
// paying to a version 0 witness program paying to the passed redeem script.
func WitnessScriptHash(witnessScript []byte) ([]byte, error) <span class="cov0" title="0">{
        bldr := txscript.NewScriptBuilder(
                txscript.WithScriptAllocSize(P2WSHSize),
        )

        bldr.AddOp(txscript.OP_0)
        scriptHash := sha256.Sum256(witnessScript)
        bldr.AddData(scriptHash[:])
        return bldr.Script()
}</span>

// WitnessPubKeyHash generates a pay-to-witness-pubkey-hash public key script
// paying to a version 0 witness program containing the passed serialized
// public key.
func WitnessPubKeyHash(pubkey []byte) ([]byte, error) <span class="cov0" title="0">{
        bldr := txscript.NewScriptBuilder(
                txscript.WithScriptAllocSize(P2WPKHSize),
        )

        bldr.AddOp(txscript.OP_0)
        pkhash := btcutil.Hash160(pubkey)
        bldr.AddData(pkhash)
        return bldr.Script()
}</span>

// GenerateP2SH generates a pay-to-script-hash public key script paying to the
// passed redeem script.
func GenerateP2SH(script []byte) ([]byte, error) <span class="cov0" title="0">{
        bldr := txscript.NewScriptBuilder(
                txscript.WithScriptAllocSize(NestedP2WPKHSize),
        )

        bldr.AddOp(txscript.OP_HASH160)
        scripthash := btcutil.Hash160(script)
        bldr.AddData(scripthash)
        bldr.AddOp(txscript.OP_EQUAL)
        return bldr.Script()
}</span>

// GenerateP2PKH generates a pay-to-public-key-hash public key script paying to
// the passed serialized public key.
func GenerateP2PKH(pubkey []byte) ([]byte, error) <span class="cov0" title="0">{
        bldr := txscript.NewScriptBuilder(
                txscript.WithScriptAllocSize(P2PKHSize),
        )

        bldr.AddOp(txscript.OP_DUP)
        bldr.AddOp(txscript.OP_HASH160)
        pkhash := btcutil.Hash160(pubkey)
        bldr.AddData(pkhash)
        bldr.AddOp(txscript.OP_EQUALVERIFY)
        bldr.AddOp(txscript.OP_CHECKSIG)
        return bldr.Script()
}</span>

// GenerateUnknownWitness generates the maximum-sized witness public key script
// consisting of a version push and a 40-byte data push.
func GenerateUnknownWitness() ([]byte, error) <span class="cov0" title="0">{
        bldr := txscript.NewScriptBuilder()

        bldr.AddOp(txscript.OP_0)
        witnessScript := make([]byte, 40)
        bldr.AddData(witnessScript)
        return bldr.Script()
}</span>

// GenMultiSigScript generates the non-p2sh'd multisig script for 2 of 2
// pubkeys.
func GenMultiSigScript(aPub, bPub []byte) ([]byte, error) <span class="cov0" title="0">{
        if len(aPub) != 33 || len(bPub) != 33 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("pubkey size error: compressed " +
                        "pubkeys only")
        }</span>

        // Swap to sort pubkeys if needed. Keys are sorted in lexicographical
        // order. The signatures within the scriptSig must also adhere to the
        // order, ensuring that the signatures for each public key appears in
        // the proper order on the stack.
        <span class="cov0" title="0">if bytes.Compare(aPub, bPub) == 1 </span><span class="cov0" title="0">{
                aPub, bPub = bPub, aPub
        }</span>

        <span class="cov0" title="0">bldr := txscript.NewScriptBuilder(txscript.WithScriptAllocSize(
                MultiSigSize,
        ))
        bldr.AddOp(txscript.OP_2)
        bldr.AddData(aPub) // Add both pubkeys (sorted).
        bldr.AddData(bPub)
        bldr.AddOp(txscript.OP_2)
        bldr.AddOp(txscript.OP_CHECKMULTISIG)
        return bldr.Script()</span>
}

// GenFundingPkScript creates a redeem script, and its matching p2wsh
// output for the funding transaction.
func GenFundingPkScript(aPub, bPub []byte, amt int64) ([]byte, *wire.TxOut, error) <span class="cov0" title="0">{
        // As a sanity check, ensure that the passed amount is above zero.
        if amt &lt;= 0 </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("can't create FundTx script with " +
                        "zero, or negative coins")
        }</span>

        // First, create the 2-of-2 multi-sig script itself.
        <span class="cov0" title="0">witnessScript, err := GenMultiSigScript(aPub, bPub)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        // With the 2-of-2 script in had, generate a p2wsh script which pays
        // to the funding script.
        <span class="cov0" title="0">pkScript, err := WitnessScriptHash(witnessScript)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">return witnessScript, wire.NewTxOut(amt, pkScript), nil</span>
}

// GenTaprootFundingScript constructs the taproot-native funding output that
// uses MuSig2 to create a single aggregated key to anchor the channel.
func GenTaprootFundingScript(aPub, bPub *btcec.PublicKey,
        amt int64, tapscriptRoot fn.Option[chainhash.Hash]) ([]byte,
        *wire.TxOut, error) <span class="cov0" title="0">{

        muSig2Opt := musig2.WithBIP86KeyTweak()
        tapscriptRoot.WhenSome(func(scriptRoot chainhash.Hash) </span><span class="cov0" title="0">{
                muSig2Opt = musig2.WithTaprootKeyTweak(scriptRoot[:])
        }</span>)

        // Similar to the existing p2wsh funding script, we'll always make sure
        // we sort the keys before any major operations. In order to ensure
        // that there's no other way this output can be spent, we'll use a BIP
        // 86 tweak here during aggregation, unless the user has explicitly
        // specified a tapscript root.
        <span class="cov0" title="0">combinedKey, _, _, err := musig2.AggregateKeys(
                []*btcec.PublicKey{aPub, bPub}, true, muSig2Opt,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("unable to combine keys: %w", err)
        }</span>

        // Now that we have the combined key, we can create a taproot pkScript
        // from this, and then make the txOut given the amount.
        <span class="cov0" title="0">pkScript, err := PayToTaprootScript(combinedKey.FinalKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("unable to make taproot "+
                        "pkscript: %w", err)
        }</span>

        <span class="cov0" title="0">txOut := wire.NewTxOut(amt, pkScript)

        // For the "witness program" we just return the raw pkScript since the
        // output we create can _only_ be spent with a MuSig2 signature.
        return pkScript, txOut, nil</span>
}

// SpendMultiSig generates the witness stack required to redeem the 2-of-2 p2wsh
// multi-sig output.
func SpendMultiSig(witnessScript, pubA []byte, sigA Signature,
        pubB []byte, sigB Signature) [][]byte <span class="cov0" title="0">{

        witness := make([][]byte, 4)

        // When spending a p2wsh multi-sig script, rather than an OP_0, we add
        // a nil stack element to eat the extra pop.
        witness[0] = nil

        // When initially generating the witnessScript, we sorted the serialized
        // public keys in descending order. So we do a quick comparison in order
        // ensure the signatures appear on the Script Virtual Machine stack in
        // the correct order.
        if bytes.Compare(pubA, pubB) == 1 </span><span class="cov0" title="0">{
                witness[1] = append(sigB.Serialize(), byte(txscript.SigHashAll))
                witness[2] = append(sigA.Serialize(), byte(txscript.SigHashAll))
        }</span> else<span class="cov0" title="0"> {
                witness[1] = append(sigA.Serialize(), byte(txscript.SigHashAll))
                witness[2] = append(sigB.Serialize(), byte(txscript.SigHashAll))
        }</span>

        // Finally, add the preimage as the last witness element.
        <span class="cov0" title="0">witness[3] = witnessScript

        return witness</span>
}

// FindScriptOutputIndex finds the index of the public key script output
// matching 'script'. Additionally, a boolean is returned indicating if a
// matching output was found at all.
//
// NOTE: The search stops after the first matching script is found.
func FindScriptOutputIndex(tx *wire.MsgTx, script []byte) (bool, uint32) <span class="cov0" title="0">{
        found := false
        index := uint32(0)
        for i, txOut := range tx.TxOut </span><span class="cov0" title="0">{
                if bytes.Equal(txOut.PkScript, script) </span><span class="cov0" title="0">{
                        found = true
                        index = uint32(i)
                        break</span>
                }
        }

        <span class="cov0" title="0">return found, index</span>
}

// Ripemd160H calculates the ripemd160 of the passed byte slice. This is used to
// calculate the intermediate hash for payment pre-images. Payment hashes are
// the result of ripemd160(sha256(paymentPreimage)). As a result, the value
// passed in should be the sha256 of the payment hash.
func Ripemd160H(d []byte) []byte <span class="cov0" title="0">{
        h := ripemd160.New()
        h.Write(d)
        return h.Sum(nil)
}</span>

// SenderHTLCScript constructs the public key script for an outgoing HTLC
// output payment for the sender's version of the commitment transaction. The
// possible script paths from this output include:
//
//   - The sender timing out the HTLC using the second level HTLC timeout
//     transaction.
//   - The receiver of the HTLC claiming the output on-chain with the payment
//     preimage.
//   - The receiver of the HTLC sweeping all the funds in the case that a
//     revoked commitment transaction bearing this HTLC was broadcast.
//
// If confirmedSpend=true, a 1 OP_CSV check will be added to the non-revocation
// cases, to allow sweeping only after confirmation.
//
// Possible Input Scripts:
//
//        SENDR: &lt;0&gt; &lt;sendr sig&gt;  &lt;recvr sig&gt; &lt;0&gt; (spend using HTLC timeout transaction)
//        RECVR: &lt;recvr sig&gt;  &lt;preimage&gt;
//        REVOK: &lt;revoke sig&gt; &lt;revoke key&gt;
//         * receiver revoke
//
// Offered HTLC Output Script:
//
//         OP_DUP OP_HASH160 &lt;revocation key hash160&gt; OP_EQUAL
//         OP_IF
//                OP_CHECKSIG
//         OP_ELSE
//                &lt;recv htlc key&gt;
//                OP_SWAP OP_SIZE 32 OP_EQUAL
//                OP_NOTIF
//                    OP_DROP 2 OP_SWAP &lt;sender htlc key&gt; 2 OP_CHECKMULTISIG
//                OP_ELSE
//                    OP_HASH160 &lt;ripemd160(payment hash)&gt; OP_EQUALVERIFY
//                    OP_CHECKSIG
//                OP_ENDIF
//                [1 OP_CHECKSEQUENCEVERIFY OP_DROP] &lt;- if allowing confirmed
//                spend only.
//         OP_ENDIF
func SenderHTLCScript(senderHtlcKey, receiverHtlcKey,
        revocationKey *btcec.PublicKey, paymentHash []byte,
        confirmedSpend bool) ([]byte, error) <span class="cov0" title="0">{

        builder := txscript.NewScriptBuilder(txscript.WithScriptAllocSize(
                OfferedHtlcScriptSizeConfirmed,
        ))

        // The opening operations are used to determine if this is the receiver
        // of the HTLC attempting to sweep all the funds due to a contract
        // breach. In this case, they'll place the revocation key at the top of
        // the stack.
        builder.AddOp(txscript.OP_DUP)
        builder.AddOp(txscript.OP_HASH160)
        builder.AddData(btcutil.Hash160(revocationKey.SerializeCompressed()))
        builder.AddOp(txscript.OP_EQUAL)

        // If the hash matches, then this is the revocation clause. The output
        // can be spent if the check sig operation passes.
        builder.AddOp(txscript.OP_IF)
        builder.AddOp(txscript.OP_CHECKSIG)

        // Otherwise, this may either be the receiver of the HTLC claiming with
        // the pre-image, or the sender of the HTLC sweeping the output after
        // it has timed out.
        builder.AddOp(txscript.OP_ELSE)

        // We'll do a bit of set up by pushing the receiver's key on the top of
        // the stack. This will be needed later if we decide that this is the
        // sender activating the time out clause with the HTLC timeout
        // transaction.
        builder.AddData(receiverHtlcKey.SerializeCompressed())

        // Atm, the top item of the stack is the receiverKey's so we use a swap
        // to expose what is either the payment pre-image or a signature.
        builder.AddOp(txscript.OP_SWAP)

        // With the top item swapped, check if it's 32 bytes. If so, then this
        // *may* be the payment pre-image.
        builder.AddOp(txscript.OP_SIZE)
        builder.AddInt64(32)
        builder.AddOp(txscript.OP_EQUAL)

        // If it isn't then this might be the sender of the HTLC activating the
        // time out clause.
        builder.AddOp(txscript.OP_NOTIF)

        // We'll drop the OP_IF return value off the top of the stack so we can
        // reconstruct the multi-sig script used as an off-chain covenant. If
        // two valid signatures are provided, then the output will be deemed as
        // spendable.
        builder.AddOp(txscript.OP_DROP)
        builder.AddOp(txscript.OP_2)
        builder.AddOp(txscript.OP_SWAP)
        builder.AddData(senderHtlcKey.SerializeCompressed())
        builder.AddOp(txscript.OP_2)
        builder.AddOp(txscript.OP_CHECKMULTISIG)

        // Otherwise, then the only other case is that this is the receiver of
        // the HTLC sweeping it on-chain with the payment pre-image.
        builder.AddOp(txscript.OP_ELSE)

        // Hash the top item of the stack and compare it with the hash160 of
        // the payment hash, which is already the sha256 of the payment
        // pre-image. By using this little trick we're able to save space
        // on-chain as the witness includes a 20-byte hash rather than a
        // 32-byte hash.
        builder.AddOp(txscript.OP_HASH160)
        builder.AddData(Ripemd160H(paymentHash))
        builder.AddOp(txscript.OP_EQUALVERIFY)

        // This checks the receiver's signature so that a third party with
        // knowledge of the payment preimage still cannot steal the output.
        builder.AddOp(txscript.OP_CHECKSIG)

        // Close out the OP_IF statement above.
        builder.AddOp(txscript.OP_ENDIF)

        // Add 1 block CSV delay if a confirmation is required for the
        // non-revocation clauses.
        if confirmedSpend </span><span class="cov0" title="0">{
                builder.AddOp(txscript.OP_1)
                builder.AddOp(txscript.OP_CHECKSEQUENCEVERIFY)
                builder.AddOp(txscript.OP_DROP)
        }</span>

        // Close out the OP_IF statement at the top of the script.
        <span class="cov0" title="0">builder.AddOp(txscript.OP_ENDIF)

        return builder.Script()</span>
}

// SenderHtlcSpendRevokeWithKey constructs a valid witness allowing the receiver of an
// HTLC to claim the output with knowledge of the revocation private key in the
// scenario that the sender of the HTLC broadcasts a previously revoked
// commitment transaction. A valid spend requires knowledge of the private key
// that corresponds to their revocation base point and also the private key from
// the per commitment point, and a valid signature under the combined public
// key.
func SenderHtlcSpendRevokeWithKey(signer Signer, signDesc *SignDescriptor,
        revokeKey *btcec.PublicKey, sweepTx *wire.MsgTx) (wire.TxWitness, error) <span class="cov0" title="0">{

        sweepSig, err := signer.SignOutputRaw(sweepTx, signDesc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // The stack required to sweep a revoke HTLC output consists simply of
        // the exact witness stack as one of a regular p2wkh spend. The only
        // difference is that the keys used were derived in an adversarial
        // manner in order to encode the revocation contract into a sig+key
        // pair.
        <span class="cov0" title="0">witnessStack := wire.TxWitness(make([][]byte, 3))
        witnessStack[0] = append(sweepSig.Serialize(), byte(signDesc.HashType))
        witnessStack[1] = revokeKey.SerializeCompressed()
        witnessStack[2] = signDesc.WitnessScript

        return witnessStack, nil</span>
}

// SenderHtlcSpendRevoke constructs a valid witness allowing the receiver of an
// HTLC to claim the output with knowledge of the revocation private key in the
// scenario that the sender of the HTLC broadcasts a previously revoked
// commitment transaction.  This method first derives the appropriate revocation
// key, and requires that the provided SignDescriptor has a local revocation
// basepoint and commitment secret in the PubKey and DoubleTweak fields,
// respectively.
func SenderHtlcSpendRevoke(signer Signer, signDesc *SignDescriptor,
        sweepTx *wire.MsgTx) (wire.TxWitness, error) <span class="cov0" title="0">{

        revokeKey, err := deriveRevokePubKey(signDesc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return SenderHtlcSpendRevokeWithKey(signer, signDesc, revokeKey, sweepTx)</span>
}

// IsHtlcSpendRevoke is used to determine if the passed spend is spending a
// HTLC output using the revocation key.
func IsHtlcSpendRevoke(txIn *wire.TxIn, signDesc *SignDescriptor) (
        bool, error) <span class="cov0" title="0">{

        // For taproot channels, the revocation path only has a single witness,
        // as that's the key spend path.
        isTaproot := txscript.IsPayToTaproot(signDesc.Output.PkScript)
        if isTaproot </span><span class="cov0" title="0">{
                return len(txIn.Witness) == 1, nil
        }</span>

        <span class="cov0" title="0">revokeKey, err := deriveRevokePubKey(signDesc)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">if len(txIn.Witness) == 3 &amp;&amp;
                bytes.Equal(txIn.Witness[1], revokeKey.SerializeCompressed()) </span><span class="cov0" title="0">{

                return true, nil
        }</span>

        <span class="cov0" title="0">return false, nil</span>
}

// SenderHtlcSpendRedeem constructs a valid witness allowing the receiver of an
// HTLC to redeem the pending output in the scenario that the sender broadcasts
// their version of the commitment transaction. A valid spend requires
// knowledge of the payment preimage, and a valid signature under the receivers
// public key.
func SenderHtlcSpendRedeem(signer Signer, signDesc *SignDescriptor,
        sweepTx *wire.MsgTx, paymentPreimage []byte) (wire.TxWitness, error) <span class="cov0" title="0">{

        sweepSig, err := signer.SignOutputRaw(sweepTx, signDesc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // The stack required to spend this output is simply the signature
        // generated above under the receiver's public key, and the payment
        // pre-image.
        <span class="cov0" title="0">witnessStack := wire.TxWitness(make([][]byte, 3))
        witnessStack[0] = append(sweepSig.Serialize(), byte(signDesc.HashType))
        witnessStack[1] = paymentPreimage
        witnessStack[2] = signDesc.WitnessScript

        return witnessStack, nil</span>
}

// SenderHtlcSpendTimeout constructs a valid witness allowing the sender of an
// HTLC to activate the time locked covenant clause of a soon to be expired
// HTLC.  This script simply spends the multi-sig output using the
// pre-generated HTLC timeout transaction.
func SenderHtlcSpendTimeout(receiverSig Signature,
        receiverSigHash txscript.SigHashType, signer Signer,
        signDesc *SignDescriptor, htlcTimeoutTx *wire.MsgTx) (
        wire.TxWitness, error) <span class="cov0" title="0">{

        sweepSig, err := signer.SignOutputRaw(htlcTimeoutTx, signDesc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // We place a zero as the first item of the evaluated witness stack in
        // order to force Script execution to the HTLC timeout clause. The
        // second zero is required to consume the extra pop due to a bug in the
        // original OP_CHECKMULTISIG.
        <span class="cov0" title="0">witnessStack := wire.TxWitness(make([][]byte, 5))
        witnessStack[0] = nil
        witnessStack[1] = append(receiverSig.Serialize(), byte(receiverSigHash))
        witnessStack[2] = append(sweepSig.Serialize(), byte(signDesc.HashType))
        witnessStack[3] = nil
        witnessStack[4] = signDesc.WitnessScript

        return witnessStack, nil</span>
}

// SenderHTLCTapLeafTimeout returns the full tapscript leaf for the timeout
// path of the sender HTLC. This is a small script that allows the sender to
// timeout the HTLC after a period of time:
//
//        &lt;local_key&gt; OP_CHECKSIGVERIFY
//        &lt;remote_key&gt; OP_CHECKSIG
func SenderHTLCTapLeafTimeout(senderHtlcKey,
        receiverHtlcKey *btcec.PublicKey) (txscript.TapLeaf, error) <span class="cov0" title="0">{

        builder := txscript.NewScriptBuilder()

        builder.AddData(schnorr.SerializePubKey(senderHtlcKey))
        builder.AddOp(txscript.OP_CHECKSIGVERIFY)
        builder.AddData(schnorr.SerializePubKey(receiverHtlcKey))
        builder.AddOp(txscript.OP_CHECKSIG)

        timeoutLeafScript, err := builder.Script()
        if err != nil </span><span class="cov0" title="0">{
                return txscript.TapLeaf{}, err
        }</span>

        <span class="cov0" title="0">return txscript.NewBaseTapLeaf(timeoutLeafScript), nil</span>
}

// SenderHTLCTapLeafSuccess returns the full tapscript leaf for the success
// path of the sender HTLC. This is a small script that allows the receiver to
// redeem the HTLC with a pre-image:
//
//        OP_SIZE 32 OP_EQUALVERIFY OP_HASH160
//        &lt;RIPEMD160(payment_hash)&gt; OP_EQUALVERIFY
//        &lt;remote_htlcpubkey&gt; OP_CHECKSIG
//        1 OP_CHECKSEQUENCEVERIFY OP_DROP
func SenderHTLCTapLeafSuccess(receiverHtlcKey *btcec.PublicKey,
        paymentHash []byte) (txscript.TapLeaf, error) <span class="cov0" title="0">{

        builder := txscript.NewScriptBuilder()

        // Check that the pre-image is 32 bytes as required.
        builder.AddOp(txscript.OP_SIZE)
        builder.AddInt64(32)
        builder.AddOp(txscript.OP_EQUALVERIFY)

        // Check that the specified pre-image matches what we hard code into
        // the script.
        builder.AddOp(txscript.OP_HASH160)
        builder.AddData(Ripemd160H(paymentHash))
        builder.AddOp(txscript.OP_EQUALVERIFY)

        // Verify the remote party's signature, then make them wait 1 block
        // after confirmation to properly sweep.
        builder.AddData(schnorr.SerializePubKey(receiverHtlcKey))
        builder.AddOp(txscript.OP_CHECKSIG)
        builder.AddOp(txscript.OP_1)
        builder.AddOp(txscript.OP_CHECKSEQUENCEVERIFY)
        builder.AddOp(txscript.OP_DROP)

        successLeafScript, err := builder.Script()
        if err != nil </span><span class="cov0" title="0">{
                return txscript.TapLeaf{}, err
        }</span>

        <span class="cov0" title="0">return txscript.NewBaseTapLeaf(successLeafScript), nil</span>
}

// htlcType is an enum value that denotes what type of HTLC script this is.
type htlcType uint8

const (
        // htlcLocalIncoming represents an incoming HTLC on the local
        // commitment transaction.
        htlcLocalIncoming htlcType = iota

        // htlcLocalOutgoing represents an outgoing HTLC on the local
        // commitment transaction.
        htlcLocalOutgoing

        // htlcRemoteIncoming represents an incoming HTLC on the remote
        // commitment transaction.
        htlcRemoteIncoming

        // htlcRemoteOutgoing represents an outgoing HTLC on the remote
        // commitment transaction.
        htlcRemoteOutgoing
)

// HtlcScriptTree holds the taproot output key, as well as the two script path
// leaves that every taproot HTLC script depends on.
type HtlcScriptTree struct {
        ScriptTree

        // SuccessTapLeaf is the tapleaf for the redemption path.
        SuccessTapLeaf txscript.TapLeaf

        // TimeoutTapLeaf is the tapleaf for the timeout path.
        TimeoutTapLeaf txscript.TapLeaf

        // AuxLeaf is an auxiliary leaf that can be used to extend the base
        // HTLC script tree with new spend paths, or just as extra commitment
        // space. When present, this leaf will always be in the right-most area
        // of the tapscript tree.
        AuxLeaf AuxTapLeaf

        // htlcType is the type of HTLC script this is.
        htlcType htlcType
}

// WitnessScriptToSign returns the witness script that we'll use when signing
// for the remote party, and also verifying signatures on our transactions. As
// an example, when we create an outgoing HTLC for the remote party, we want to
// sign the success path for them, so we'll return the success path leaf.
func (h *HtlcScriptTree) WitnessScriptToSign() []byte <span class="cov0" title="0">{
        switch h.htlcType </span>{
        // For incoming HLTCs on our local commitment, we care about verifying
        // the success path.
        case htlcLocalIncoming:<span class="cov0" title="0">
                return h.SuccessTapLeaf.Script</span>

        // For incoming HTLCs on the remote party's commitment, we want to sign
        // the timeout path for them.
        case htlcRemoteIncoming:<span class="cov0" title="0">
                return h.TimeoutTapLeaf.Script</span>

        // For outgoing HTLCs on our local commitment, we want to verify the
        // timeout path.
        case htlcLocalOutgoing:<span class="cov0" title="0">
                return h.TimeoutTapLeaf.Script</span>

        // For outgoing HTLCs on the remote party's commitment, we want to sign
        // the success path for them.
        case htlcRemoteOutgoing:<span class="cov0" title="0">
                return h.SuccessTapLeaf.Script</span>

        default:<span class="cov0" title="0">
                panic(fmt.Sprintf("unknown htlc type: %v", h.htlcType))</span>
        }
}

// WitnessScriptForPath returns the witness script for the given spending path.
// An error is returned if the path is unknown.
func (h *HtlcScriptTree) WitnessScriptForPath(path ScriptPath) ([]byte, error) <span class="cov0" title="0">{
        switch path </span>{
        case ScriptPathSuccess:<span class="cov0" title="0">
                return h.SuccessTapLeaf.Script, nil</span>
        case ScriptPathTimeout:<span class="cov0" title="0">
                return h.TimeoutTapLeaf.Script, nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unknown script path: %v", path)</span>
        }
}

// CtrlBlockForPath returns the control block for the given spending path. For
// script types that don't have a control block, nil is returned.
func (h *HtlcScriptTree) CtrlBlockForPath(
        path ScriptPath) (*txscript.ControlBlock, error) <span class="cov0" title="0">{

        switch path </span>{
        case ScriptPathSuccess:<span class="cov0" title="0">
                return lnutils.Ptr(MakeTaprootCtrlBlock(
                        h.SuccessTapLeaf.Script, h.InternalKey,
                        h.TapscriptTree,
                )), nil</span>
        case ScriptPathTimeout:<span class="cov0" title="0">
                return lnutils.Ptr(MakeTaprootCtrlBlock(
                        h.TimeoutTapLeaf.Script, h.InternalKey,
                        h.TapscriptTree,
                )), nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unknown script path: %v", path)</span>
        }
}

// Tree returns the underlying ScriptTree of the HtlcScriptTree.
func (h *HtlcScriptTree) Tree() ScriptTree <span class="cov0" title="0">{
        return h.ScriptTree
}</span>

// A compile time check to ensure HtlcScriptTree implements the
// TapscriptMultiplexer interface.
var _ TapscriptDescriptor = (*HtlcScriptTree)(nil)

// senderHtlcTapScriptTree builds the tapscript tree which is used to anchor
// the HTLC key for HTLCs on the sender's commitment.
func senderHtlcTapScriptTree(senderHtlcKey, receiverHtlcKey,
        revokeKey *btcec.PublicKey, payHash []byte, hType htlcType,
        auxLeaf AuxTapLeaf) (*HtlcScriptTree, error) <span class="cov0" title="0">{

        // First, we'll obtain the tap leaves for both the success and timeout
        // path.
        successTapLeaf, err := SenderHTLCTapLeafSuccess(
                receiverHtlcKey, payHash,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">timeoutTapLeaf, err := SenderHTLCTapLeafTimeout(
                senderHtlcKey, receiverHtlcKey,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">tapLeaves := []txscript.TapLeaf{successTapLeaf, timeoutTapLeaf}
        auxLeaf.WhenSome(func(l txscript.TapLeaf) </span><span class="cov0" title="0">{
                tapLeaves = append(tapLeaves, l)
        }</span>)

        // With the two leaves obtained, we'll now make the tapscript tree,
        // then obtain the root from that
        <span class="cov0" title="0">tapscriptTree := txscript.AssembleTaprootScriptTree(tapLeaves...)

        tapScriptRoot := tapscriptTree.RootNode.TapHash()

        // With the tapscript root obtained, we'll tweak the revocation key
        // with this value to obtain the key that HTLCs will be sent to.
        htlcKey := txscript.ComputeTaprootOutputKey(
                revokeKey, tapScriptRoot[:],
        )

        return &amp;HtlcScriptTree{
                ScriptTree: ScriptTree{
                        TaprootKey:    htlcKey,
                        TapscriptTree: tapscriptTree,
                        TapscriptRoot: tapScriptRoot[:],
                        InternalKey:   revokeKey,
                },
                SuccessTapLeaf: successTapLeaf,
                TimeoutTapLeaf: timeoutTapLeaf,
                AuxLeaf:        auxLeaf,
                htlcType:       hType,
        }, nil</span>
}

// SenderHTLCScriptTaproot constructs the taproot witness program (schnorr key)
// for an outgoing HTLC on the sender's version of the commitment transaction.
// This method returns the top level tweaked public key that commits to both
// the script paths. This is also known as an offered HTLC.
//
// The returned key commits to a tapscript tree with two possible paths:
//
//   - Timeout path:
//     &lt;local_key&gt; OP_CHECKSIGVERIFY
//     &lt;remote_key&gt; OP_CHECKSIG
//
//   - Success path:
//     OP_SIZE 32 OP_EQUALVERIFY
//     OP_HASH160 &lt;RIPEMD160(payment_hash)&gt; OP_EQUALVERIFY
//     &lt;remote_htlcpubkey&gt; OP_CHECKSIG
//     1 OP_CHECKSEQUENCEVERIFY OP_DROP
//
// The timeout path can be spent with a witness of (sender timeout):
//
//        &lt;receiver sig&gt; &lt;local sig&gt; &lt;timeout_script&gt; &lt;control_block&gt;
//
// The success path can be spent with a valid control block, and a witness of
// (receiver redeem):
//
//        &lt;receiver sig&gt; &lt;preimage&gt; &lt;success_script&gt; &lt;control_block&gt;
//
// The top level keyspend key is the revocation key, which allows a defender to
// unilaterally spend the created output.
func SenderHTLCScriptTaproot(senderHtlcKey, receiverHtlcKey,
        revokeKey *btcec.PublicKey, payHash []byte,
        whoseCommit lntypes.ChannelParty, auxLeaf AuxTapLeaf) (*HtlcScriptTree,
        error) <span class="cov0" title="0">{

        var hType htlcType
        if whoseCommit.IsLocal() </span><span class="cov0" title="0">{
                hType = htlcLocalOutgoing
        }</span> else<span class="cov0" title="0"> {
                hType = htlcRemoteIncoming
        }</span>

        // Given all the necessary parameters, we'll return the HTLC script
        // tree that includes the top level output script, as well as the two
        // tap leaf paths.
        <span class="cov0" title="0">return senderHtlcTapScriptTree(
                senderHtlcKey, receiverHtlcKey, revokeKey, payHash, hType,
                auxLeaf,
        )</span>
}

// maybeAppendSighashType appends a sighash type to the end of a signature if
// the sighash type isn't sighash default.
func maybeAppendSighash(sig Signature, sigHash txscript.SigHashType) []byte <span class="cov0" title="0">{
        sigBytes := sig.Serialize()
        if sigHash == txscript.SigHashDefault </span><span class="cov0" title="0">{
                return sigBytes
        }</span>

        <span class="cov0" title="0">return append(sigBytes, byte(sigHash))</span>
}

// SenderHTLCScriptTaprootRedeem creates a valid witness needed to redeem a
// sender taproot HTLC with the pre-image. The returned witness is valid and
// includes the control block required to spend the output. This is the offered
// HTLC claimed by the remote party.
func SenderHTLCScriptTaprootRedeem(signer Signer, signDesc *SignDescriptor,
        sweepTx *wire.MsgTx, preimage []byte, revokeKey *btcec.PublicKey,
        tapscriptTree *txscript.IndexedTapScriptTree) (wire.TxWitness, error) <span class="cov0" title="0">{

        sweepSig, err := signer.SignOutputRaw(sweepTx, signDesc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // In addition to the signature and the witness/leaf script, we also
        // need to make a control block proof using the tapscript tree.
        <span class="cov0" title="0">var ctrlBlock []byte
        if signDesc.ControlBlock == nil </span><span class="cov0" title="0">{
                successControlBlock := MakeTaprootCtrlBlock(
                        signDesc.WitnessScript, revokeKey, tapscriptTree,
                )

                ctrlBytes, err := successControlBlock.ToBytes()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">ctrlBlock = ctrlBytes</span>
        } else<span class="cov0" title="0"> {
                ctrlBlock = signDesc.ControlBlock
        }</span>

        // The final witness stack is:
        //  &lt;receiver sig&gt; &lt;preimage&gt; &lt;success_script&gt; &lt;control_block&gt;
        <span class="cov0" title="0">witnessStack := make(wire.TxWitness, 4)
        witnessStack[0] = maybeAppendSighash(sweepSig, signDesc.HashType)
        witnessStack[1] = preimage
        witnessStack[2] = signDesc.WitnessScript
        witnessStack[3] = ctrlBlock

        return witnessStack, nil</span>
}

// SenderHTLCScriptTaprootTimeout creates a valid witness needed to timeout an
// HTLC on the sender's commitment transaction. The returned witness is valid
// and includes the control block required to spend the output. This is a
// timeout of the offered HTLC by the sender.
func SenderHTLCScriptTaprootTimeout(receiverSig Signature,
        receiverSigHash txscript.SigHashType, signer Signer,
        signDesc *SignDescriptor, htlcTimeoutTx *wire.MsgTx,
        revokeKey *btcec.PublicKey,
        tapscriptTree *txscript.IndexedTapScriptTree) (wire.TxWitness, error) <span class="cov0" title="0">{

        sweepSig, err := signer.SignOutputRaw(htlcTimeoutTx, signDesc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // With the sweep signature obtained, we'll obtain the control block
        // proof needed to perform a valid spend for the timeout path.
        <span class="cov0" title="0">var ctrlBlockBytes []byte
        if signDesc.ControlBlock == nil </span><span class="cov0" title="0">{
                timeoutControlBlock := MakeTaprootCtrlBlock(
                        signDesc.WitnessScript, revokeKey, tapscriptTree,
                )
                ctrlBytes, err := timeoutControlBlock.ToBytes()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">ctrlBlockBytes = ctrlBytes</span>
        } else<span class="cov0" title="0"> {
                ctrlBlockBytes = signDesc.ControlBlock
        }</span>

        // The final witness stack is:
        //  &lt;receiver sig&gt; &lt;local sig&gt; &lt;timeout_script&gt; &lt;control_block&gt;
        <span class="cov0" title="0">witnessStack := make(wire.TxWitness, 4)
        witnessStack[0] = maybeAppendSighash(receiverSig, receiverSigHash)
        witnessStack[1] = maybeAppendSighash(sweepSig, signDesc.HashType)
        witnessStack[2] = signDesc.WitnessScript
        witnessStack[3] = ctrlBlockBytes

        return witnessStack, nil</span>
}

// SenderHTLCScriptTaprootRevoke creates a valid witness needed to spend the
// revocation path of the HTLC. This uses a plain keyspend using the specified
// revocation key.
func SenderHTLCScriptTaprootRevoke(signer Signer, signDesc *SignDescriptor,
        sweepTx *wire.MsgTx) (wire.TxWitness, error) <span class="cov0" title="0">{

        sweepSig, err := signer.SignOutputRaw(sweepTx, signDesc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // The witness stack in this case is pretty simple: we only need to
        // specify the signature generated.
        <span class="cov0" title="0">witnessStack := make(wire.TxWitness, 1)
        witnessStack[0] = maybeAppendSighash(sweepSig, signDesc.HashType)

        return witnessStack, nil</span>
}

// ReceiverHTLCScript constructs the public key script for an incoming HTLC
// output payment for the receiver's version of the commitment transaction. The
// possible execution paths from this script include:
//   - The receiver of the HTLC uses its second level HTLC transaction to
//     advance the state of the HTLC into the delay+claim state.
//   - The sender of the HTLC sweeps all the funds of the HTLC as a breached
//     commitment was broadcast.
//   - The sender of the HTLC sweeps the HTLC on-chain after the timeout period
//     of the HTLC has passed.
//
// If confirmedSpend=true, a 1 OP_CSV check will be added to the non-revocation
// cases, to allow sweeping only after confirmation.
//
// Possible Input Scripts:
//
//        RECVR: &lt;0&gt; &lt;sender sig&gt; &lt;recvr sig&gt; &lt;preimage&gt; (spend using HTLC success transaction)
//        REVOK: &lt;sig&gt; &lt;key&gt;
//        SENDR: &lt;sig&gt; 0
//
// Received HTLC Output Script:
//
//         OP_DUP OP_HASH160 &lt;revocation key hash160&gt; OP_EQUAL
//         OP_IF
//                 OP_CHECKSIG
//         OP_ELSE
//                &lt;sendr htlc key&gt;
//                OP_SWAP OP_SIZE 32 OP_EQUAL
//                OP_IF
//                    OP_HASH160 &lt;ripemd160(payment hash)&gt; OP_EQUALVERIFY
//                    2 OP_SWAP &lt;recvr htlc key&gt; 2 OP_CHECKMULTISIG
//                OP_ELSE
//                    OP_DROP &lt;cltv expiry&gt; OP_CHECKLOCKTIMEVERIFY OP_DROP
//                    OP_CHECKSIG
//                OP_ENDIF
//                [1 OP_CHECKSEQUENCEVERIFY OP_DROP] &lt;- if allowing confirmed
//                spend only.
//         OP_ENDIF
func ReceiverHTLCScript(cltvExpiry uint32, senderHtlcKey,
        receiverHtlcKey, revocationKey *btcec.PublicKey,
        paymentHash []byte, confirmedSpend bool) ([]byte, error) <span class="cov0" title="0">{

        builder := txscript.NewScriptBuilder(txscript.WithScriptAllocSize(
                AcceptedHtlcScriptSizeConfirmed,
        ))

        // The opening operations are used to determine if this is the sender
        // of the HTLC attempting to sweep all the funds due to a contract
        // breach. In this case, they'll place the revocation key at the top of
        // the stack.
        builder.AddOp(txscript.OP_DUP)
        builder.AddOp(txscript.OP_HASH160)
        builder.AddData(btcutil.Hash160(revocationKey.SerializeCompressed()))
        builder.AddOp(txscript.OP_EQUAL)

        // If the hash matches, then this is the revocation clause. The output
        // can be spent if the check sig operation passes.
        builder.AddOp(txscript.OP_IF)
        builder.AddOp(txscript.OP_CHECKSIG)

        // Otherwise, this may either be the receiver of the HTLC starting the
        // claiming process via the second level HTLC success transaction and
        // the pre-image, or the sender of the HTLC sweeping the output after
        // it has timed out.
        builder.AddOp(txscript.OP_ELSE)

        // We'll do a bit of set up by pushing the sender's key on the top of
        // the stack. This will be needed later if we decide that this is the
        // receiver transitioning the output to the claim state using their
        // second-level HTLC success transaction.
        builder.AddData(senderHtlcKey.SerializeCompressed())

        // Atm, the top item of the stack is the sender's key so we use a swap
        // to expose what is either the payment pre-image or something else.
        builder.AddOp(txscript.OP_SWAP)

        // With the top item swapped, check if it's 32 bytes. If so, then this
        // *may* be the payment pre-image.
        builder.AddOp(txscript.OP_SIZE)
        builder.AddInt64(32)
        builder.AddOp(txscript.OP_EQUAL)

        // If the item on the top of the stack is 32-bytes, then it is the
        // proper size, so this indicates that the receiver of the HTLC is
        // attempting to claim the output on-chain by transitioning the state
        // of the HTLC to delay+claim.
        builder.AddOp(txscript.OP_IF)

        // Next we'll hash the item on the top of the stack, if it matches the
        // payment pre-image, then we'll continue. Otherwise, we'll end the
        // script here as this is the invalid payment pre-image.
        builder.AddOp(txscript.OP_HASH160)
        builder.AddData(Ripemd160H(paymentHash))
        builder.AddOp(txscript.OP_EQUALVERIFY)

        // If the payment hash matches, then we'll also need to satisfy the
        // multi-sig covenant by providing both signatures of the sender and
        // receiver. If the convenient is met, then we'll allow the spending of
        // this output, but only by the HTLC success transaction.
        builder.AddOp(txscript.OP_2)
        builder.AddOp(txscript.OP_SWAP)
        builder.AddData(receiverHtlcKey.SerializeCompressed())
        builder.AddOp(txscript.OP_2)
        builder.AddOp(txscript.OP_CHECKMULTISIG)

        // Otherwise, this might be the sender of the HTLC attempting to sweep
        // it on-chain after the timeout.
        builder.AddOp(txscript.OP_ELSE)

        // We'll drop the extra item (which is the output from evaluating the
        // OP_EQUAL) above from the stack.
        builder.AddOp(txscript.OP_DROP)

        // With that item dropped off, we can now enforce the absolute
        // lock-time required to timeout the HTLC. If the time has passed, then
        // we'll proceed with a checksig to ensure that this is actually the
        // sender of he original HTLC.
        builder.AddInt64(int64(cltvExpiry))
        builder.AddOp(txscript.OP_CHECKLOCKTIMEVERIFY)
        builder.AddOp(txscript.OP_DROP)
        builder.AddOp(txscript.OP_CHECKSIG)

        // Close out the inner if statement.
        builder.AddOp(txscript.OP_ENDIF)

        // Add 1 block CSV delay for non-revocation clauses if confirmation is
        // required.
        if confirmedSpend </span><span class="cov0" title="0">{
                builder.AddOp(txscript.OP_1)
                builder.AddOp(txscript.OP_CHECKSEQUENCEVERIFY)
                builder.AddOp(txscript.OP_DROP)
        }</span>

        // Close out the outer if statement.
        <span class="cov0" title="0">builder.AddOp(txscript.OP_ENDIF)

        return builder.Script()</span>
}

// ReceiverHtlcSpendRedeem constructs a valid witness allowing the receiver of
// an HTLC to redeem the conditional payment in the event that their commitment
// transaction is broadcast. This clause transitions the state of the HLTC
// output into the delay+claim state by activating the off-chain covenant bound
// by the 2-of-2 multi-sig output. The HTLC success timeout transaction being
// signed has a relative timelock delay enforced by its sequence number. This
// delay give the sender of the HTLC enough time to revoke the output if this
// is a breach commitment transaction.
func ReceiverHtlcSpendRedeem(senderSig Signature,
        senderSigHash txscript.SigHashType, paymentPreimage []byte,
        signer Signer, signDesc *SignDescriptor, htlcSuccessTx *wire.MsgTx) (
        wire.TxWitness, error) <span class="cov0" title="0">{

        // First, we'll generate a signature for the HTLC success transaction.
        // The signDesc should be signing with the public key used as the
        // receiver's public key and also the correct single tweak.
        sweepSig, err := signer.SignOutputRaw(htlcSuccessTx, signDesc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // The final witness stack is used the provide the script with the
        // payment pre-image, and also execute the multi-sig clause after the
        // pre-images matches. We add a nil item at the bottom of the stack in
        // order to consume the extra pop within OP_CHECKMULTISIG.
        <span class="cov0" title="0">witnessStack := wire.TxWitness(make([][]byte, 5))
        witnessStack[0] = nil
        witnessStack[1] = append(senderSig.Serialize(), byte(senderSigHash))
        witnessStack[2] = append(sweepSig.Serialize(), byte(signDesc.HashType))
        witnessStack[3] = paymentPreimage
        witnessStack[4] = signDesc.WitnessScript

        return witnessStack, nil</span>
}

// ReceiverHtlcSpendRevokeWithKey constructs a valid witness allowing the sender of an
// HTLC within a previously revoked commitment transaction to re-claim the
// pending funds in the case that the receiver broadcasts this revoked
// commitment transaction.
func ReceiverHtlcSpendRevokeWithKey(signer Signer, signDesc *SignDescriptor,
        revokeKey *btcec.PublicKey, sweepTx *wire.MsgTx) (wire.TxWitness, error) <span class="cov0" title="0">{

        // First, we'll generate a signature for the sweep transaction.  The
        // signDesc should be signing with the public key used as the fully
        // derived revocation public key and also the correct double tweak
        // value.
        sweepSig, err := signer.SignOutputRaw(sweepTx, signDesc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // We place a zero, then one as the first items in the evaluated
        // witness stack in order to force script execution to the HTLC
        // revocation clause.
        <span class="cov0" title="0">witnessStack := wire.TxWitness(make([][]byte, 3))
        witnessStack[0] = append(sweepSig.Serialize(), byte(signDesc.HashType))
        witnessStack[1] = revokeKey.SerializeCompressed()
        witnessStack[2] = signDesc.WitnessScript

        return witnessStack, nil</span>
}

func deriveRevokePubKey(signDesc *SignDescriptor) (*btcec.PublicKey, error) <span class="cov0" title="0">{
        if signDesc.KeyDesc.PubKey == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot generate witness with nil " +
                        "KeyDesc pubkey")
        }</span>

        // Derive the revocation key using the local revocation base point and
        // commitment point.
        <span class="cov0" title="0">revokeKey := DeriveRevocationPubkey(
                signDesc.KeyDesc.PubKey,
                signDesc.DoubleTweak.PubKey(),
        )

        return revokeKey, nil</span>
}

// ReceiverHtlcSpendRevoke constructs a valid witness allowing the sender of an
// HTLC within a previously revoked commitment transaction to re-claim the
// pending funds in the case that the receiver broadcasts this revoked
// commitment transaction. This method first derives the appropriate revocation
// key, and requires that the provided SignDescriptor has a local revocation
// basepoint and commitment secret in the PubKey and DoubleTweak fields,
// respectively.
func ReceiverHtlcSpendRevoke(signer Signer, signDesc *SignDescriptor,
        sweepTx *wire.MsgTx) (wire.TxWitness, error) <span class="cov0" title="0">{

        revokeKey, err := deriveRevokePubKey(signDesc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return ReceiverHtlcSpendRevokeWithKey(signer, signDesc, revokeKey, sweepTx)</span>
}

// ReceiverHtlcSpendTimeout constructs a valid witness allowing the sender of
// an HTLC to recover the pending funds after an absolute timeout in the
// scenario that the receiver of the HTLC broadcasts their version of the
// commitment transaction. If the caller has already set the lock time on the
// spending transaction, than a value of -1 can be passed for the cltvExpiry
// value.
//
// NOTE: The target input of the passed transaction MUST NOT have a final
// sequence number. Otherwise, the OP_CHECKLOCKTIMEVERIFY check will fail.
func ReceiverHtlcSpendTimeout(signer Signer, signDesc *SignDescriptor,
        sweepTx *wire.MsgTx, cltvExpiry int32) (wire.TxWitness, error) <span class="cov0" title="0">{

        // If the caller set a proper timeout value, then we'll apply it
        // directly to the transaction.
        if cltvExpiry != -1 </span><span class="cov0" title="0">{
                // The HTLC output has an absolute time period before we are
                // permitted to recover the pending funds. Therefore we need to
                // set the locktime on this sweeping transaction in order to
                // pass Script verification.
                sweepTx.LockTime = uint32(cltvExpiry)
        }</span>

        // With the lock time on the transaction set, we'll not generate a
        // signature for the sweep transaction. The passed sign descriptor
        // should be created using the raw public key of the sender (w/o the
        // single tweak applied), and the single tweak set to the proper value
        // taking into account the current state's point.
        <span class="cov0" title="0">sweepSig, err := signer.SignOutputRaw(sweepTx, signDesc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">witnessStack := wire.TxWitness(make([][]byte, 3))
        witnessStack[0] = append(sweepSig.Serialize(), byte(signDesc.HashType))
        witnessStack[1] = nil
        witnessStack[2] = signDesc.WitnessScript

        return witnessStack, nil</span>
}

// ReceiverHtlcTapLeafTimeout returns the full tapscript leaf for the timeout
// path of the sender HTLC. This is a small script that allows the sender
// timeout the HTLC after expiry:
//
//        &lt;sender_htlcpubkey&gt; OP_CHECKSIG
//        1 OP_CHECKSEQUENCEVERIFY OP_DROP
//        &lt;cltv_expiry&gt; OP_CHECKLOCKTIMEVERIFY OP_DROP
func ReceiverHtlcTapLeafTimeout(senderHtlcKey *btcec.PublicKey,
        cltvExpiry uint32) (txscript.TapLeaf, error) <span class="cov0" title="0">{

        builder := txscript.NewScriptBuilder()

        // The first part of the script will verify a signature from the
        // sender authorizing the spend (the timeout).
        builder.AddData(schnorr.SerializePubKey(senderHtlcKey))
        builder.AddOp(txscript.OP_CHECKSIG)
        builder.AddOp(txscript.OP_1)
        builder.AddOp(txscript.OP_CHECKSEQUENCEVERIFY)
        builder.AddOp(txscript.OP_DROP)

        // The second portion will ensure that the CLTV expiry on the spending
        // transaction is correct.
        builder.AddInt64(int64(cltvExpiry))
        builder.AddOp(txscript.OP_CHECKLOCKTIMEVERIFY)
        builder.AddOp(txscript.OP_DROP)

        timeoutLeafScript, err := builder.Script()
        if err != nil </span><span class="cov0" title="0">{
                return txscript.TapLeaf{}, err
        }</span>

        <span class="cov0" title="0">return txscript.NewBaseTapLeaf(timeoutLeafScript), nil</span>
}

// ReceiverHtlcTapLeafSuccess returns the full tapscript leaf for the success
// path for an HTLC on the receiver's commitment transaction. This script
// allows the receiver to redeem an HTLC with knowledge of the preimage:
//
//        OP_SIZE 32 OP_EQUALVERIFY OP_HASH160
//        &lt;RIPEMD160(payment_hash)&gt; OP_EQUALVERIFY
//        &lt;receiver_htlcpubkey&gt; OP_CHECKSIGVERIFY
//        &lt;sender_htlcpubkey&gt; OP_CHECKSIG
func ReceiverHtlcTapLeafSuccess(receiverHtlcKey *btcec.PublicKey,
        senderHtlcKey *btcec.PublicKey,
        paymentHash []byte) (txscript.TapLeaf, error) <span class="cov0" title="0">{

        builder := txscript.NewScriptBuilder()

        // Check that the pre-image is 32 bytes as required.
        builder.AddOp(txscript.OP_SIZE)
        builder.AddInt64(32)
        builder.AddOp(txscript.OP_EQUALVERIFY)

        // Check that the specified pre-image matches what we hard code into
        // the script.
        builder.AddOp(txscript.OP_HASH160)
        builder.AddData(Ripemd160H(paymentHash))
        builder.AddOp(txscript.OP_EQUALVERIFY)

        // Verify the "2-of-2" multi-sig that requires both parties to sign
        // off.
        builder.AddData(schnorr.SerializePubKey(receiverHtlcKey))
        builder.AddOp(txscript.OP_CHECKSIGVERIFY)
        builder.AddData(schnorr.SerializePubKey(senderHtlcKey))
        builder.AddOp(txscript.OP_CHECKSIG)

        successLeafScript, err := builder.Script()
        if err != nil </span><span class="cov0" title="0">{
                return txscript.TapLeaf{}, err
        }</span>

        <span class="cov0" title="0">return txscript.NewBaseTapLeaf(successLeafScript), nil</span>
}

// receiverHtlcTapScriptTree builds the tapscript tree which is used to anchor
// the HTLC key for HTLCs on the receiver's commitment.
func receiverHtlcTapScriptTree(senderHtlcKey, receiverHtlcKey,
        revokeKey *btcec.PublicKey, payHash []byte, cltvExpiry uint32,
        hType htlcType, auxLeaf AuxTapLeaf) (*HtlcScriptTree, error) <span class="cov0" title="0">{

        // First, we'll obtain the tap leaves for both the success and timeout
        // path.
        successTapLeaf, err := ReceiverHtlcTapLeafSuccess(
                receiverHtlcKey, senderHtlcKey, payHash,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">timeoutTapLeaf, err := ReceiverHtlcTapLeafTimeout(
                senderHtlcKey, cltvExpiry,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">tapLeaves := []txscript.TapLeaf{timeoutTapLeaf, successTapLeaf}
        auxLeaf.WhenSome(func(l txscript.TapLeaf) </span><span class="cov0" title="0">{
                tapLeaves = append(tapLeaves, l)
        }</span>)

        // With the two leaves obtained, we'll now make the tapscript tree,
        // then obtain the root from that
        <span class="cov0" title="0">tapscriptTree := txscript.AssembleTaprootScriptTree(tapLeaves...)

        tapScriptRoot := tapscriptTree.RootNode.TapHash()

        // With the tapscript root obtained, we'll tweak the revocation key
        // with this value to obtain the key that HTLCs will be sent to.
        htlcKey := txscript.ComputeTaprootOutputKey(
                revokeKey, tapScriptRoot[:],
        )

        return &amp;HtlcScriptTree{
                ScriptTree: ScriptTree{
                        TaprootKey:    htlcKey,
                        TapscriptTree: tapscriptTree,
                        TapscriptRoot: tapScriptRoot[:],
                        InternalKey:   revokeKey,
                },
                SuccessTapLeaf: successTapLeaf,
                TimeoutTapLeaf: timeoutTapLeaf,
                AuxLeaf:        auxLeaf,
                htlcType:       hType,
        }, nil</span>
}

// ReceiverHTLCScriptTaproot constructs the taproot witness program (schnor
// key) for an incoming HTLC on the receiver's version of the commitment
// transaction. This method returns the top level tweaked public key that
// commits to both the script paths. From the PoV of the receiver, this is an
// accepted HTLC.
//
// The returned key commits to a tapscript tree with two possible paths:
//
//   - The timeout path:
//     &lt;remote_htlcpubkey&gt; OP_CHECKSIG
//     1 OP_CHECKSEQUENCEVERIFY OP_DROP
//     &lt;cltv_expiry&gt; OP_CHECKLOCKTIMEVERIFY OP_DROP
//
//   - Success path:
//     OP_SIZE 32 OP_EQUALVERIFY
//     OP_HASH160 &lt;RIPEMD160(payment_hash)&gt; OP_EQUALVERIFY
//     &lt;local_htlcpubkey&gt; OP_CHECKSIGVERIFY
//     &lt;remote_htlcpubkey&gt; OP_CHECKSIG
//
// The timeout path can be spent with a witness of:
//   - &lt;sender sig&gt; &lt;timeout_script&gt; &lt;control_block&gt;
//
// The success path can be spent with a witness of:
//   - &lt;sender sig&gt; &lt;receiver sig&gt; &lt;preimage&gt; &lt;success_script&gt; &lt;control_block&gt;
//
// The top level keyspend key is the revocation key, which allows a defender to
// unilaterally spend the created output. Both the final output key as well as
// the tap leaf are returned.
func ReceiverHTLCScriptTaproot(cltvExpiry uint32,
        senderHtlcKey, receiverHtlcKey, revocationKey *btcec.PublicKey,
        payHash []byte, whoseCommit lntypes.ChannelParty,
        auxLeaf AuxTapLeaf) (*HtlcScriptTree, error) <span class="cov0" title="0">{

        var hType htlcType
        if whoseCommit.IsLocal() </span><span class="cov0" title="0">{
                hType = htlcLocalIncoming
        }</span> else<span class="cov0" title="0"> {
                hType = htlcRemoteOutgoing
        }</span>

        // Given all the necessary parameters, we'll return the HTLC script
        // tree that includes the top level output script, as well as the two
        // tap leaf paths.
        <span class="cov0" title="0">return receiverHtlcTapScriptTree(
                senderHtlcKey, receiverHtlcKey, revocationKey, payHash,
                cltvExpiry, hType, auxLeaf,
        )</span>
}

// ReceiverHTLCScriptTaprootRedeem creates a valid witness needed to redeem a
// receiver taproot HTLC with the pre-image. The returned witness is valid and
// includes the control block required to spend the output.
func ReceiverHTLCScriptTaprootRedeem(senderSig Signature,
        senderSigHash txscript.SigHashType, paymentPreimage []byte,
        signer Signer, signDesc *SignDescriptor,
        htlcSuccessTx *wire.MsgTx, revokeKey *btcec.PublicKey,
        tapscriptTree *txscript.IndexedTapScriptTree) (wire.TxWitness, error) <span class="cov0" title="0">{

        // First, we'll generate a signature for the HTLC success transaction.
        // The signDesc should be signing with the public key used as the
        // receiver's public key and also the correct single tweak.
        sweepSig, err := signer.SignOutputRaw(htlcSuccessTx, signDesc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // In addition to the signature and the witness/leaf script, we also
        // need to make a control block proof using the tapscript tree.
        <span class="cov0" title="0">var ctrlBlock []byte
        if signDesc.ControlBlock == nil </span><span class="cov0" title="0">{
                redeemControlBlock := MakeTaprootCtrlBlock(
                        signDesc.WitnessScript, revokeKey, tapscriptTree,
                )
                ctrlBytes, err := redeemControlBlock.ToBytes()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">ctrlBlock = ctrlBytes</span>
        } else<span class="cov0" title="0"> {
                ctrlBlock = signDesc.ControlBlock
        }</span>

        // The final witness stack is:
        //  * &lt;sender sig&gt; &lt;receiver sig&gt; &lt;preimage&gt; &lt;success_script&gt;
        //    &lt;control_block&gt;
        <span class="cov0" title="0">witnessStack := wire.TxWitness(make([][]byte, 5))
        witnessStack[0] = maybeAppendSighash(senderSig, senderSigHash)
        witnessStack[1] = maybeAppendSighash(sweepSig, signDesc.HashType)
        witnessStack[2] = paymentPreimage
        witnessStack[3] = signDesc.WitnessScript
        witnessStack[4] = ctrlBlock

        return witnessStack, nil</span>
}

// ReceiverHTLCScriptTaprootTimeout creates a valid witness needed to timeout
// an HTLC on the receiver's commitment transaction after the timeout has
// elapsed.
func ReceiverHTLCScriptTaprootTimeout(signer Signer, signDesc *SignDescriptor,
        sweepTx *wire.MsgTx, cltvExpiry int32, revokeKey *btcec.PublicKey,
        tapscriptTree *txscript.IndexedTapScriptTree) (wire.TxWitness, error) <span class="cov0" title="0">{

        // If the caller set a proper timeout value, then we'll apply it
        // directly to the transaction.
        //
        // TODO(roasbeef): helper func
        if cltvExpiry != -1 </span><span class="cov0" title="0">{
                // The HTLC output has an absolute time period before we are
                // permitted to recover the pending funds. Therefore we need to
                // set the locktime on this sweeping transaction in order to
                // pass Script verification.
                sweepTx.LockTime = uint32(cltvExpiry)
        }</span>

        // With the lock time on the transaction set, we'll now generate a
        // signature for the sweep transaction. The passed sign descriptor
        // should be created using the raw public key of the sender (w/o the
        // single tweak applied), and the single tweak set to the proper value
        // taking into account the current state's point.
        <span class="cov0" title="0">sweepSig, err := signer.SignOutputRaw(sweepTx, signDesc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // In addition to the signature and the witness/leaf script, we also
        // need to make a control block proof using the tapscript tree.
        <span class="cov0" title="0">var ctrlBlock []byte
        if signDesc.ControlBlock == nil </span><span class="cov0" title="0">{
                timeoutControlBlock := MakeTaprootCtrlBlock(
                        signDesc.WitnessScript, revokeKey, tapscriptTree,
                )
                ctrlBlock, err = timeoutControlBlock.ToBytes()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        } else<span class="cov0" title="0"> {
                ctrlBlock = signDesc.ControlBlock
        }</span>

        // The final witness is pretty simple, we just need to present a valid
        // signature for the script, and then provide the control block.
        <span class="cov0" title="0">witnessStack := make(wire.TxWitness, 3)
        witnessStack[0] = maybeAppendSighash(sweepSig, signDesc.HashType)
        witnessStack[1] = signDesc.WitnessScript
        witnessStack[2] = ctrlBlock

        return witnessStack, nil</span>
}

// ReceiverHTLCScriptTaprootRevoke creates a valid witness needed to spend the
// revocation path of the HTLC from the PoV of the sender (offerer) of the
// HTLC. This uses a plain keyspend using the specified revocation key.
func ReceiverHTLCScriptTaprootRevoke(signer Signer, signDesc *SignDescriptor,
        sweepTx *wire.MsgTx) (wire.TxWitness, error) <span class="cov0" title="0">{

        sweepSig, err := signer.SignOutputRaw(sweepTx, signDesc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // The witness stack in this case is pretty simple: we only need to
        // specify the signature generated.
        <span class="cov0" title="0">witnessStack := make(wire.TxWitness, 1)
        witnessStack[0] = maybeAppendSighash(sweepSig, signDesc.HashType)

        return witnessStack, nil</span>
}

// SecondLevelHtlcScript is the uniform script that's used as the output for
// the second-level HTLC transactions. The second level transaction act as a
// sort of covenant, ensuring that a 2-of-2 multi-sig output can only be
// spent in a particular way, and to a particular output.
//
// Possible Input Scripts:
//
//   - To revoke an HTLC output that has been transitioned to the claim+delay
//     state:
//     &lt;revoke sig&gt; 1
//
//   - To claim and HTLC output, either with a pre-image or due to a timeout:
//     &lt;delay sig&gt; 0
//
// Output Script:
//
//         OP_IF
//                &lt;revoke key&gt;
//         OP_ELSE
//                &lt;delay in blocks&gt;
//                OP_CHECKSEQUENCEVERIFY
//                OP_DROP
//                &lt;delay key&gt;
//         OP_ENDIF
//         OP_CHECKSIG
//
// TODO(roasbeef): possible renames for second-level
//   - transition?
//   - covenant output
func SecondLevelHtlcScript(revocationKey, delayKey *btcec.PublicKey,
        csvDelay uint32) ([]byte, error) <span class="cov0" title="0">{

        builder := txscript.NewScriptBuilder(txscript.WithScriptAllocSize(
                ToLocalScriptSize,
        ))

        // If this is the revocation clause for this script is to be executed,
        // the spender will push a 1, forcing us to hit the true clause of this
        // if statement.
        builder.AddOp(txscript.OP_IF)

        // If this is the revocation case, then we'll push the revocation
        // public key on the stack.
        builder.AddData(revocationKey.SerializeCompressed())

        // Otherwise, this is either the sender or receiver of the HTLC
        // attempting to claim the HTLC output.
        builder.AddOp(txscript.OP_ELSE)

        // In order to give the other party time to execute the revocation
        // clause above, we require a relative timeout to pass before the
        // output can be spent.
        builder.AddInt64(int64(csvDelay))
        builder.AddOp(txscript.OP_CHECKSEQUENCEVERIFY)
        builder.AddOp(txscript.OP_DROP)

        // If the relative timelock passes, then we'll add the delay key to the
        // stack to ensure that we properly authenticate the spending party.
        builder.AddData(delayKey.SerializeCompressed())

        // Close out the if statement.
        builder.AddOp(txscript.OP_ENDIF)

        // In either case, we'll ensure that only either the party possessing
        // the revocation private key, or the delay private key is able to
        // spend this output.
        builder.AddOp(txscript.OP_CHECKSIG)

        return builder.Script()
}</span>

// TODO(roasbeef): move all taproot stuff to new file?

// TaprootSecondLevelTapLeaf constructs the tap leaf used as the sole script
// path for a second level HTLC spend.
//
// The final script used is:
//
//        &lt;local_delay_key&gt; OP_CHECKSIG
//        &lt;to_self_delay&gt; OP_CHECKSEQUENCEVERIFY OP_DROP
func TaprootSecondLevelTapLeaf(delayKey *btcec.PublicKey,
        csvDelay uint32) (txscript.TapLeaf, error) <span class="cov0" title="0">{

        builder := txscript.NewScriptBuilder()

        // Ensure the proper party can sign for this output.
        builder.AddData(schnorr.SerializePubKey(delayKey))
        builder.AddOp(txscript.OP_CHECKSIG)

        // Assuming the above passes, then we'll now ensure that the CSV delay
        // has been upheld, dropping the int we pushed on. If the sig above is
        // valid, then a 1 will be left on the stack.
        builder.AddInt64(int64(csvDelay))
        builder.AddOp(txscript.OP_CHECKSEQUENCEVERIFY)
        builder.AddOp(txscript.OP_DROP)

        secondLevelLeafScript, err := builder.Script()
        if err != nil </span><span class="cov0" title="0">{
                return txscript.TapLeaf{}, err
        }</span>

        <span class="cov0" title="0">return txscript.NewBaseTapLeaf(secondLevelLeafScript), nil</span>
}

// SecondLevelHtlcTapscriptTree construct the indexed tapscript tree needed to
// generate the tap tweak to create the final output and also control block.
func SecondLevelHtlcTapscriptTree(delayKey *btcec.PublicKey, csvDelay uint32,
        auxLeaf AuxTapLeaf) (*txscript.IndexedTapScriptTree, error) <span class="cov0" title="0">{

        // First grab the second level leaf script we need to create the top
        // level output.
        secondLevelTapLeaf, err := TaprootSecondLevelTapLeaf(delayKey, csvDelay)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">tapLeaves := []txscript.TapLeaf{secondLevelTapLeaf}
        auxLeaf.WhenSome(func(l txscript.TapLeaf) </span><span class="cov0" title="0">{
                tapLeaves = append(tapLeaves, l)
        }</span>)

        // Now that we have the sole second level script, we can create the
        // tapscript tree that commits to both the leaves.
        <span class="cov0" title="0">return txscript.AssembleTaprootScriptTree(tapLeaves...), nil</span>
}

// TaprootSecondLevelHtlcScript is the uniform script that's used as the output
// for the second-level HTLC transaction. The second level transaction acts as
// an off-chain 2-of-2 covenant that can only be spent a particular way and to
// a particular output.
//
// Possible Input Scripts:
//   - revocation sig
//   - &lt;local_delay_sig&gt;
//
// The script main script lets the broadcaster spend after a delay the script
// path:
//
//        &lt;local_delay_key&gt; OP_CHECKSIG
//        &lt;to_self_delay&gt; OP_CHECKSEQUENCEVERIFY OP_DROP
//
// The keyspend path require knowledge of the top level revocation private key.
func TaprootSecondLevelHtlcScript(revokeKey, delayKey *btcec.PublicKey,
        csvDelay uint32, auxLeaf AuxTapLeaf) (*btcec.PublicKey, error) <span class="cov0" title="0">{

        // First, we'll make the tapscript tree that commits to the redemption
        // path.
        tapScriptTree, err := SecondLevelHtlcTapscriptTree(
                delayKey, csvDelay, auxLeaf,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">tapScriptRoot := tapScriptTree.RootNode.TapHash()

        // With the tapscript root obtained, we'll tweak the revocation key
        // with this value to obtain the key that the second level spend will
        // create.
        redemptionKey := txscript.ComputeTaprootOutputKey(
                revokeKey, tapScriptRoot[:],
        )

        return redemptionKey, nil</span>
}

// SecondLevelScriptTree is a tapscript tree used to spend the second level
// HTLC output after the CSV delay has passed.
type SecondLevelScriptTree struct {
        ScriptTree

        // SuccessTapLeaf is the tapleaf for the redemption path.
        SuccessTapLeaf txscript.TapLeaf

        // AuxLeaf is an optional leaf that can be used to extend the script
        // tree.
        AuxLeaf AuxTapLeaf
}

// TaprootSecondLevelScriptTree constructs the tapscript tree used to spend the
// second level HTLC output.
func TaprootSecondLevelScriptTree(revokeKey, delayKey *btcec.PublicKey,
        csvDelay uint32, auxLeaf AuxTapLeaf) (*SecondLevelScriptTree, error) <span class="cov0" title="0">{

        // First, we'll make the tapscript tree that commits to the redemption
        // path.
        tapScriptTree, err := SecondLevelHtlcTapscriptTree(
                delayKey, csvDelay, auxLeaf,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // With the tree constructed, we can make the pkscript which is the
        // taproot output key itself.
        <span class="cov0" title="0">tapScriptRoot := tapScriptTree.RootNode.TapHash()
        outputKey := txscript.ComputeTaprootOutputKey(
                revokeKey, tapScriptRoot[:],
        )

        return &amp;SecondLevelScriptTree{
                ScriptTree: ScriptTree{
                        TaprootKey:    outputKey,
                        TapscriptTree: tapScriptTree,
                        TapscriptRoot: tapScriptRoot[:],
                        InternalKey:   revokeKey,
                },
                SuccessTapLeaf: tapScriptTree.LeafMerkleProofs[0].TapLeaf,
                AuxLeaf:        auxLeaf,
        }, nil</span>
}

// WitnessScriptToSign returns the witness script that we'll use when signing
// for the remote party, and also verifying signatures on our transactions. As
// an example, when we create an outgoing HTLC for the remote party, we want to
// sign their success path.
func (s *SecondLevelScriptTree) WitnessScriptToSign() []byte <span class="cov0" title="0">{
        return s.SuccessTapLeaf.Script
}</span>

// WitnessScriptForPath returns the witness script for the given spending path.
// An error is returned if the path is unknown.
func (s *SecondLevelScriptTree) WitnessScriptForPath(
        path ScriptPath) ([]byte, error) <span class="cov0" title="0">{

        switch path </span>{
        case ScriptPathDelay:<span class="cov0" title="0">
                fallthrough</span>
        case ScriptPathSuccess:<span class="cov0" title="0">
                return s.SuccessTapLeaf.Script, nil</span>

        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unknown script path: %v", path)</span>
        }
}

// CtrlBlockForPath returns the control block for the given spending path. For
// script types that don't have a control block, nil is returned.
func (s *SecondLevelScriptTree) CtrlBlockForPath(
        path ScriptPath) (*txscript.ControlBlock, error) <span class="cov0" title="0">{

        switch path </span>{
        case ScriptPathDelay:<span class="cov0" title="0">
                fallthrough</span>
        case ScriptPathSuccess:<span class="cov0" title="0">
                return lnutils.Ptr(MakeTaprootCtrlBlock(
                        s.SuccessTapLeaf.Script, s.InternalKey,
                        s.TapscriptTree,
                )), nil</span>

        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unknown script path: %v", path)</span>
        }
}

// Tree returns the underlying ScriptTree of the SecondLevelScriptTree.
func (s *SecondLevelScriptTree) Tree() ScriptTree <span class="cov0" title="0">{
        return s.ScriptTree
}</span>

// A compile time check to ensure SecondLevelScriptTree implements the
// TapscriptDescriptor interface.
var _ TapscriptDescriptor = (*SecondLevelScriptTree)(nil)

// TaprootHtlcSpendRevoke spends a second-level HTLC output via the revocation
// path. This uses the top level keyspend path to redeem the contested output.
//
// The passed SignDescriptor MUST have the proper witness script and also the
// proper top-level tweak derived from the tapscript tree for the second level
// output.
func TaprootHtlcSpendRevoke(signer Signer, signDesc *SignDescriptor,
        revokeTx *wire.MsgTx) (wire.TxWitness, error) <span class="cov0" title="0">{

        // We don't need any spacial modifications to the transaction as this
        // is just sweeping a revoked HTLC output. So we'll generate a regular
        // schnorr signature.
        sweepSig, err := signer.SignOutputRaw(revokeTx, signDesc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // The witness stack in this case is pretty simple: we only need to
        // specify the signature generated.
        <span class="cov0" title="0">witnessStack := make(wire.TxWitness, 1)
        witnessStack[0] = maybeAppendSighash(sweepSig, signDesc.HashType)

        return witnessStack, nil</span>
}

// TaprootHtlcSpendSuccess spends a second-level HTLC output via the redemption
// path. This should be used to sweep funds after the pre-image is known.
//
// NOTE: The caller MUST set the txn version, sequence number, and sign
// descriptor's sig hash cache before invocation.
func TaprootHtlcSpendSuccess(signer Signer, signDesc *SignDescriptor,
        sweepTx *wire.MsgTx, revokeKey *btcec.PublicKey,
        tapscriptTree *txscript.IndexedTapScriptTree) (wire.TxWitness, error) <span class="cov0" title="0">{

        // First, we'll generate the sweep signature based on the populated
        // sign desc. This should give us a valid schnorr signature for the
        // sole script path leaf.
        sweepSig, err := signer.SignOutputRaw(sweepTx, signDesc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var ctrlBlock []byte
        if signDesc.ControlBlock == nil </span><span class="cov0" title="0">{
                // Now that we have the sweep signature, we'll construct the
                // control block needed to spend the script path.
                redeemControlBlock := MakeTaprootCtrlBlock(
                        signDesc.WitnessScript, revokeKey, tapscriptTree,
                )

                ctrlBlock, err = redeemControlBlock.ToBytes()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        } else<span class="cov0" title="0"> {
                ctrlBlock = signDesc.ControlBlock
        }</span>

        // Now that we have the redeem control block, we can construct the
        // final witness needed to spend the script:
        //
        //  &lt;success sig&gt; &lt;success script&gt; &lt;control_block&gt;
        <span class="cov0" title="0">witnessStack := make(wire.TxWitness, 3)
        witnessStack[0] = maybeAppendSighash(sweepSig, signDesc.HashType)
        witnessStack[1] = signDesc.WitnessScript
        witnessStack[2] = ctrlBlock

        return witnessStack, nil</span>
}

// LeaseSecondLevelHtlcScript is the uniform script that's used as the output
// for the second-level HTLC transactions. The second level transaction acts as
// a sort of covenant, ensuring that a 2-of-2 multi-sig output can only be
// spent in a particular way, and to a particular output.
//
// Possible Input Scripts:
//
//   - To revoke an HTLC output that has been transitioned to the claim+delay
//     state:
//     &lt;revoke sig&gt; 1
//
//   - To claim an HTLC output, either with a pre-image or due to a timeout:
//     &lt;delay sig&gt; 0
//
// Output Script:
//
//         OP_IF
//                &lt;revoke key&gt;
//         OP_ELSE
//                &lt;lease maturity in blocks&gt;
//                OP_CHECKLOCKTIMEVERIFY
//                OP_DROP
//                &lt;delay in blocks&gt;
//                OP_CHECKSEQUENCEVERIFY
//                OP_DROP
//                &lt;delay key&gt;
//         OP_ENDIF
//         OP_CHECKSIG.
func LeaseSecondLevelHtlcScript(revocationKey, delayKey *btcec.PublicKey,
        csvDelay, cltvExpiry uint32) ([]byte, error) <span class="cov0" title="0">{

        builder := txscript.NewScriptBuilder(txscript.WithScriptAllocSize(
                ToLocalScriptSize + LeaseWitnessScriptSizeOverhead,
        ))

        // If this is the revocation clause for this script is to be executed,
        // the spender will push a 1, forcing us to hit the true clause of this
        // if statement.
        builder.AddOp(txscript.OP_IF)

        // If this this is the revocation case, then we'll push the revocation
        // public key on the stack.
        builder.AddData(revocationKey.SerializeCompressed())

        // Otherwise, this is either the sender or receiver of the HTLC
        // attempting to claim the HTLC output.
        builder.AddOp(txscript.OP_ELSE)

        // The channel initiator always has the additional channel lease
        // expiration constraint for outputs that pay to them which must be
        // satisfied.
        builder.AddInt64(int64(cltvExpiry))
        builder.AddOp(txscript.OP_CHECKLOCKTIMEVERIFY)
        builder.AddOp(txscript.OP_DROP)

        // In order to give the other party time to execute the revocation
        // clause above, we require a relative timeout to pass before the
        // output can be spent.
        builder.AddInt64(int64(csvDelay))
        builder.AddOp(txscript.OP_CHECKSEQUENCEVERIFY)
        builder.AddOp(txscript.OP_DROP)

        // If the relative timelock passes, then we'll add the delay key to the
        // stack to ensure that we properly authenticate the spending party.
        builder.AddData(delayKey.SerializeCompressed())

        // Close out the if statement.
        builder.AddOp(txscript.OP_ENDIF)

        // In either case, we'll ensure that only either the party possessing
        // the revocation private key, or the delay private key is able to
        // spend this output.
        builder.AddOp(txscript.OP_CHECKSIG)

        return builder.Script()
}</span>

// HtlcSpendSuccess spends a second-level HTLC output. This function is to be
// used by the sender of an HTLC to claim the output after a relative timeout
// or the receiver of the HTLC to claim on-chain with the pre-image.
func HtlcSpendSuccess(signer Signer, signDesc *SignDescriptor,
        sweepTx *wire.MsgTx, csvDelay uint32) (wire.TxWitness, error) <span class="cov0" title="0">{

        // We're required to wait a relative period of time before we can sweep
        // the output in order to allow the other party to contest our claim of
        // validity to this version of the commitment transaction.
        sweepTx.TxIn[0].Sequence = LockTimeToSequence(false, csvDelay)

        // Finally, OP_CSV requires that the version of the transaction
        // spending a pkscript with OP_CSV within it *must* be &gt;= 2.
        sweepTx.Version = 2

        // As we mutated the transaction, we'll re-calculate the sighashes for
        // this instance.
        signDesc.SigHashes = NewTxSigHashesV0Only(sweepTx)

        // With the proper sequence and version set, we'll now sign the timeout
        // transaction using the passed signed descriptor. In order to generate
        // a valid signature, then signDesc should be using the base delay
        // public key, and the proper single tweak bytes.
        sweepSig, err := signer.SignOutputRaw(sweepTx, signDesc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // We set a zero as the first element the witness stack (ignoring the
        // witness script), in order to force execution to the second portion
        // of the if clause.
        <span class="cov0" title="0">witnessStack := wire.TxWitness(make([][]byte, 3))
        witnessStack[0] = append(sweepSig.Serialize(), byte(signDesc.HashType))
        witnessStack[1] = nil
        witnessStack[2] = signDesc.WitnessScript

        return witnessStack, nil</span>
}

// HtlcSpendRevoke spends a second-level HTLC output. This function is to be
// used by the sender or receiver of an HTLC to claim the HTLC after a revoked
// commitment transaction was broadcast.
func HtlcSpendRevoke(signer Signer, signDesc *SignDescriptor,
        revokeTx *wire.MsgTx) (wire.TxWitness, error) <span class="cov0" title="0">{

        // We don't need any spacial modifications to the transaction as this
        // is just sweeping a revoked HTLC output. So we'll generate a regular
        // witness signature.
        sweepSig, err := signer.SignOutputRaw(revokeTx, signDesc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // We set a one as the first element the witness stack (ignoring the
        // witness script), in order to force execution to the revocation
        // clause in the second level HTLC script.
        <span class="cov0" title="0">witnessStack := wire.TxWitness(make([][]byte, 3))
        witnessStack[0] = append(sweepSig.Serialize(), byte(signDesc.HashType))
        witnessStack[1] = []byte{1}
        witnessStack[2] = signDesc.WitnessScript

        return witnessStack, nil</span>
}

// HtlcSecondLevelSpend exposes the public witness generation function for
// spending an HTLC success transaction, either due to an expiring time lock or
// having had the payment preimage. This method is able to spend any
// second-level HTLC transaction, assuming the caller sets the locktime or
// seqno properly.
//
// NOTE: The caller MUST set the txn version, sequence number, and sign
// descriptor's sig hash cache before invocation.
func HtlcSecondLevelSpend(signer Signer, signDesc *SignDescriptor,
        sweepTx *wire.MsgTx) (wire.TxWitness, error) <span class="cov0" title="0">{

        // With the proper sequence and version set, we'll now sign the timeout
        // transaction using the passed signed descriptor. In order to generate
        // a valid signature, then signDesc should be using the base delay
        // public key, and the proper single tweak bytes.
        sweepSig, err := signer.SignOutputRaw(sweepTx, signDesc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // We set a zero as the first element the witness stack (ignoring the
        // witness script), in order to force execution to the second portion
        // of the if clause.
        <span class="cov0" title="0">witnessStack := wire.TxWitness(make([][]byte, 3))
        witnessStack[0] = append(sweepSig.Serialize(), byte(txscript.SigHashAll))
        witnessStack[1] = nil
        witnessStack[2] = signDesc.WitnessScript

        return witnessStack, nil</span>
}

// LockTimeToSequence converts the passed relative locktime to a sequence
// number in accordance to BIP-68.
// See: https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki
//   - (Compatibility)
func LockTimeToSequence(isSeconds bool, locktime uint32) uint32 <span class="cov0" title="0">{
        if !isSeconds </span><span class="cov0" title="0">{
                // The locktime is to be expressed in confirmations.
                return locktime
        }</span>

        // Set the 22nd bit which indicates the lock time is in seconds, then
        // shift the locktime over by 9 since the time granularity is in
        // 512-second intervals (2^9). This results in a max lock-time of
        // 33,554,431 seconds, or 1.06 years.
        <span class="cov0" title="0">return SequenceLockTimeSeconds | (locktime &gt;&gt; 9)</span>
}

// CommitScriptToSelf constructs the public key script for the output on the
// commitment transaction paying to the "owner" of said commitment transaction.
// If the other party learns of the preimage to the revocation hash, then they
// can claim all the settled funds in the channel, plus the unsettled funds.
//
// Possible Input Scripts:
//
//        REVOKE:     &lt;sig&gt; 1
//        SENDRSWEEP: &lt;sig&gt; &lt;emptyvector&gt;
//
// Output Script:
//
//        OP_IF
//            &lt;revokeKey&gt;
//        OP_ELSE
//            &lt;numRelativeBlocks&gt; OP_CHECKSEQUENCEVERIFY OP_DROP
//            &lt;selfKey&gt;
//        OP_ENDIF
//        OP_CHECKSIG
func CommitScriptToSelf(csvTimeout uint32, selfKey, revokeKey *btcec.PublicKey) ([]byte, error) <span class="cov0" title="0">{
        // This script is spendable under two conditions: either the
        // 'csvTimeout' has passed and we can redeem our funds, or they can
        // produce a valid signature with the revocation public key. The
        // revocation public key will *only* be known to the other party if we
        // have divulged the revocation hash, allowing them to homomorphically
        // derive the proper private key which corresponds to the revoke public
        // key.
        builder := txscript.NewScriptBuilder(txscript.WithScriptAllocSize(
                ToLocalScriptSize,
        ))

        builder.AddOp(txscript.OP_IF)

        // If a valid signature using the revocation key is presented, then
        // allow an immediate spend provided the proper signature.
        builder.AddData(revokeKey.SerializeCompressed())

        builder.AddOp(txscript.OP_ELSE)

        // Otherwise, we can re-claim our funds after a CSV delay of
        // 'csvTimeout' timeout blocks, and a valid signature.
        builder.AddInt64(int64(csvTimeout))
        builder.AddOp(txscript.OP_CHECKSEQUENCEVERIFY)
        builder.AddOp(txscript.OP_DROP)
        builder.AddData(selfKey.SerializeCompressed())

        builder.AddOp(txscript.OP_ENDIF)

        // Finally, we'll validate the signature against the public key that's
        // left on the top of the stack.
        builder.AddOp(txscript.OP_CHECKSIG)

        return builder.Script()
}</span>

// CommitScriptTree holds the taproot output key (in this case the revocation
// key, or a NUMs point for the remote output) along with the tapscript leaf
// that can spend the output after a delay.
type CommitScriptTree struct {
        ScriptTree

        // SettleLeaf is the leaf used to settle the output after the delay.
        SettleLeaf txscript.TapLeaf

        // RevocationLeaf is the leaf used to spend the output with the
        // revocation key signature.
        RevocationLeaf txscript.TapLeaf

        // AuxLeaf is an auxiliary leaf that can be used to extend the base
        // commitment script tree with new spend paths, or just as extra
        // commitment space. When present, this leaf will always be in the
        // left-most or right-most area of the tapscript tree.
        AuxLeaf AuxTapLeaf
}

// A compile time check to ensure CommitScriptTree implements the
// TapscriptDescriptor interface.
var _ TapscriptDescriptor = (*CommitScriptTree)(nil)

// WitnessScriptToSign returns the witness script that we'll use when signing
// for the remote party, and also verifying signatures on our transactions. As
// an example, when we create an outgoing HTLC for the remote party, we want to
// sign their success path.
func (c *CommitScriptTree) WitnessScriptToSign() []byte <span class="cov0" title="0">{
        // TODO(roasbeef): abstraction leak here? always dependent
        return nil
}</span>

// WitnessScriptForPath returns the witness script for the given spending path.
// An error is returned if the path is unknown.
func (c *CommitScriptTree) WitnessScriptForPath(
        path ScriptPath) ([]byte, error) <span class="cov0" title="0">{

        switch path </span>{
        // For the commitment output, the delay and success path are the same,
        // so we'll fall through here to success.
        case ScriptPathDelay:<span class="cov0" title="0">
                fallthrough</span>
        case ScriptPathSuccess:<span class="cov0" title="0">
                return c.SettleLeaf.Script, nil</span>
        case ScriptPathRevocation:<span class="cov0" title="0">
                return c.RevocationLeaf.Script, nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unknown script path: %v", path)</span>
        }
}

// CtrlBlockForPath returns the control block for the given spending path. For
// script types that don't have a control block, nil is returned.
func (c *CommitScriptTree) CtrlBlockForPath(
        path ScriptPath) (*txscript.ControlBlock, error) <span class="cov0" title="0">{

        switch path </span>{
        case ScriptPathDelay:<span class="cov0" title="0">
                fallthrough</span>
        case ScriptPathSuccess:<span class="cov0" title="0">
                return lnutils.Ptr(MakeTaprootCtrlBlock(
                        c.SettleLeaf.Script, c.InternalKey,
                        c.TapscriptTree,
                )), nil</span>
        case ScriptPathRevocation:<span class="cov0" title="0">
                return lnutils.Ptr(MakeTaprootCtrlBlock(
                        c.RevocationLeaf.Script, c.InternalKey,
                        c.TapscriptTree,
                )), nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unknown script path: %v", path)</span>
        }
}

// Tree returns the underlying ScriptTree of the CommitScriptTree.
func (c *CommitScriptTree) Tree() ScriptTree <span class="cov0" title="0">{
        return c.ScriptTree
}</span>

// NewLocalCommitScriptTree returns a new CommitScript tree that can be used to
// create and spend the commitment output for the local party.
func NewLocalCommitScriptTree(csvTimeout uint32, selfKey,
        revokeKey *btcec.PublicKey, auxLeaf AuxTapLeaf) (*CommitScriptTree,
        error) <span class="cov0" title="0">{

        // First, we'll need to construct the tapLeaf that'll be our delay CSV
        // clause.
        delayScript, err := TaprootLocalCommitDelayScript(csvTimeout, selfKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Next, we'll need to construct the revocation path, which is just a
        // simple checksig script.
        <span class="cov0" title="0">revokeScript, err := TaprootLocalCommitRevokeScript(selfKey, revokeKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // With both scripts computed, we'll now create a tapscript tree with
        // the two leaves, and then obtain a root from that.
        <span class="cov0" title="0">delayTapLeaf := txscript.NewBaseTapLeaf(delayScript)
        revokeTapLeaf := txscript.NewBaseTapLeaf(revokeScript)

        tapLeaves := []txscript.TapLeaf{delayTapLeaf, revokeTapLeaf}
        auxLeaf.WhenSome(func(l txscript.TapLeaf) </span><span class="cov0" title="0">{
                tapLeaves = append(tapLeaves, l)
        }</span>)

        <span class="cov0" title="0">tapScriptTree := txscript.AssembleTaprootScriptTree(tapLeaves...)
        tapScriptRoot := tapScriptTree.RootNode.TapHash()

        // Now that we have our root, we can arrive at the final output script
        // by tweaking the internal key with this root.
        toLocalOutputKey := txscript.ComputeTaprootOutputKey(
                &amp;TaprootNUMSKey, tapScriptRoot[:],
        )

        return &amp;CommitScriptTree{
                ScriptTree: ScriptTree{
                        TaprootKey:    toLocalOutputKey,
                        TapscriptTree: tapScriptTree,
                        TapscriptRoot: tapScriptRoot[:],
                        InternalKey:   &amp;TaprootNUMSKey,
                },
                SettleLeaf:     delayTapLeaf,
                RevocationLeaf: revokeTapLeaf,
                AuxLeaf:        auxLeaf,
        }, nil</span>
}

// TaprootLocalCommitDelayScript builds the tap leaf with the CSV delay script
// for the to-local output.
func TaprootLocalCommitDelayScript(csvTimeout uint32,
        selfKey *btcec.PublicKey) ([]byte, error) <span class="cov0" title="0">{

        builder := txscript.NewScriptBuilder()
        builder.AddData(schnorr.SerializePubKey(selfKey))
        builder.AddOp(txscript.OP_CHECKSIG)
        builder.AddInt64(int64(csvTimeout))
        builder.AddOp(txscript.OP_CHECKSEQUENCEVERIFY)
        builder.AddOp(txscript.OP_DROP)

        return builder.Script()
}</span>

// TaprootLocalCommitRevokeScript builds the tap leaf with the revocation path
// for the to-local output.
func TaprootLocalCommitRevokeScript(selfKey, revokeKey *btcec.PublicKey) (
        []byte, error) <span class="cov0" title="0">{

        builder := txscript.NewScriptBuilder()
        builder.AddData(schnorr.SerializePubKey(selfKey))
        builder.AddOp(txscript.OP_DROP)
        builder.AddData(schnorr.SerializePubKey(revokeKey))
        builder.AddOp(txscript.OP_CHECKSIG)

        return builder.Script()
}</span>

// TaprootCommitScriptToSelf creates the taproot witness program that commits
// to the revocation (script path) and delay path (script path) in a single
// taproot output key. Both the delay script and the revocation script are part
// of the tapscript tree to ensure that the internal key (the local delay key)
// is always revealed.  This ensures that a 3rd party can always sweep the set
// of anchor outputs.
//
// For the delay path we have the following tapscript leaf script:
//
//        &lt;local_delayedpubkey&gt; OP_CHECKSIG
//        &lt;to_self_delay&gt; OP_CHECKSEQUENCEVERIFY OP_DROP
//
// This can then be spent with just:
//
//        &lt;local_delayedsig&gt; &lt;to_delay_script&gt; &lt;delay_control_block&gt;
//
// Where the to_delay_script is listed above, and the delay_control_block
// computed as:
//
//        delay_control_block = (output_key_y_parity | 0xc0) || taproot_nums_key
//
// The revocation path is simply:
//
//        &lt;local_delayedpubkey&gt; OP_DROP
//        &lt;revocationkey&gt; OP_CHECKSIG
//
// The revocation path can be spent with a control block similar to the above
// (but contains the hash of the other script), and with the following witness:
//
//        &lt;revocation_sig&gt;
//
// We use a noop data push to ensure that the local public key is also revealed
// on chain, which enables the anchor output to be swept.
func TaprootCommitScriptToSelf(csvTimeout uint32,
        selfKey, revokeKey *btcec.PublicKey) (*btcec.PublicKey, error) <span class="cov0" title="0">{

        commitScriptTree, err := NewLocalCommitScriptTree(
                csvTimeout, selfKey, revokeKey, NoneTapLeaf(),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return commitScriptTree.TaprootKey, nil</span>
}

// MakeTaprootCtrlBlock takes a leaf script, the internal key (usually the
// revoke key), and a script tree and creates a valid control block for a spend
// of the leaf.
func MakeTaprootCtrlBlock(leafScript []byte, internalKey *btcec.PublicKey,
        scriptTree *txscript.IndexedTapScriptTree) txscript.ControlBlock <span class="cov0" title="0">{

        tapLeafHash := txscript.NewBaseTapLeaf(leafScript).TapHash()
        scriptIdx := scriptTree.LeafProofIndex[tapLeafHash]
        settleMerkleProof := scriptTree.LeafMerkleProofs[scriptIdx]

        return settleMerkleProof.ToControlBlock(internalKey)
}</span>

// TaprootCommitSpendSuccess constructs a valid witness allowing a node to
// sweep the settled taproot output after the delay has passed for a force
// close.
func TaprootCommitSpendSuccess(signer Signer, signDesc *SignDescriptor,
        sweepTx *wire.MsgTx,
        scriptTree *txscript.IndexedTapScriptTree) (wire.TxWitness, error) <span class="cov0" title="0">{

        // First, we'll need to construct a valid control block to execute the
        // leaf script for sweep settlement.
        //
        // TODO(roasbeef); make into closure instead? only need reovke key and
        // scriptTree to make the ctrl block -- then default version that would
        // take froms ign desc?
        var ctrlBlockBytes []byte
        if signDesc.ControlBlock == nil </span><span class="cov0" title="0">{
                settleControlBlock := MakeTaprootCtrlBlock(
                        signDesc.WitnessScript, &amp;TaprootNUMSKey, scriptTree,
                )
                ctrlBytes, err := settleControlBlock.ToBytes()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">ctrlBlockBytes = ctrlBytes</span>
        } else<span class="cov0" title="0"> {
                ctrlBlockBytes = signDesc.ControlBlock
        }</span>

        // With the control block created, we'll now generate the signature we
        // need to authorize the spend.
        <span class="cov0" title="0">sweepSig, err := signer.SignOutputRaw(sweepTx, signDesc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // The final witness stack will be:
        //
        //  &lt;sweep sig&gt; &lt;sweep script&gt; &lt;control block&gt;
        <span class="cov0" title="0">witnessStack := make(wire.TxWitness, 3)
        witnessStack[0] = maybeAppendSighash(sweepSig, signDesc.HashType)
        witnessStack[1] = signDesc.WitnessScript
        witnessStack[2] = ctrlBlockBytes

        return witnessStack, nil</span>
}

// TaprootCommitSpendRevoke constructs a valid witness allowing a node to sweep
// the revoked taproot output of a malicious peer.
func TaprootCommitSpendRevoke(signer Signer, signDesc *SignDescriptor,
        revokeTx *wire.MsgTx,
        scriptTree *txscript.IndexedTapScriptTree) (wire.TxWitness, error) <span class="cov0" title="0">{

        // First, we'll need to construct a valid control block to execute the
        // leaf script for revocation path.
        var ctrlBlockBytes []byte
        if signDesc.ControlBlock == nil </span><span class="cov0" title="0">{
                revokeCtrlBlock := MakeTaprootCtrlBlock(
                        signDesc.WitnessScript, &amp;TaprootNUMSKey, scriptTree,
                )
                revokeBytes, err := revokeCtrlBlock.ToBytes()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">ctrlBlockBytes = revokeBytes</span>
        } else<span class="cov0" title="0"> {
                ctrlBlockBytes = signDesc.ControlBlock
        }</span>

        // With the control block created, we'll now generate the signature we
        // need to authorize the spend.
        <span class="cov0" title="0">revokeSig, err := signer.SignOutputRaw(revokeTx, signDesc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // The final witness stack will be:
        //
        //  &lt;revoke sig sig&gt; &lt;revoke script&gt; &lt;control block&gt;
        <span class="cov0" title="0">witnessStack := make(wire.TxWitness, 3)
        witnessStack[0] = maybeAppendSighash(revokeSig, signDesc.HashType)
        witnessStack[1] = signDesc.WitnessScript
        witnessStack[2] = ctrlBlockBytes

        return witnessStack, nil</span>
}

// LeaseCommitScriptToSelf constructs the public key script for the output on the
// commitment transaction paying to the "owner" of said commitment transaction.
// If the other party learns of the preimage to the revocation hash, then they
// can claim all the settled funds in the channel, plus the unsettled funds.
//
// Possible Input Scripts:
//
//        REVOKE:     &lt;sig&gt; 1
//        SENDRSWEEP: &lt;sig&gt; &lt;emptyvector&gt;
//
// Output Script:
//
//        OP_IF
//            &lt;revokeKey&gt;
//        OP_ELSE
//            &lt;absoluteLeaseExpiry&gt; OP_CHECKLOCKTIMEVERIFY OP_DROP
//            &lt;numRelativeBlocks&gt; OP_CHECKSEQUENCEVERIFY OP_DROP
//            &lt;selfKey&gt;
//        OP_ENDIF
//        OP_CHECKSIG
func LeaseCommitScriptToSelf(selfKey, revokeKey *btcec.PublicKey,
        csvTimeout, leaseExpiry uint32) ([]byte, error) <span class="cov0" title="0">{

        // This script is spendable under two conditions: either the
        // 'csvTimeout' has passed and we can redeem our funds, or they can
        // produce a valid signature with the revocation public key. The
        // revocation public key will *only* be known to the other party if we
        // have divulged the revocation hash, allowing them to homomorphically
        // derive the proper private key which corresponds to the revoke public
        // key.
        builder := txscript.NewScriptBuilder(txscript.WithScriptAllocSize(
                ToLocalScriptSize + LeaseWitnessScriptSizeOverhead,
        ))

        builder.AddOp(txscript.OP_IF)

        // If a valid signature using the revocation key is presented, then
        // allow an immediate spend provided the proper signature.
        builder.AddData(revokeKey.SerializeCompressed())

        builder.AddOp(txscript.OP_ELSE)

        // Otherwise, we can re-claim our funds after once the CLTV lease
        // maturity has been met, along with the CSV delay of 'csvTimeout'
        // timeout blocks, and a valid signature.
        builder.AddInt64(int64(leaseExpiry))
        builder.AddOp(txscript.OP_CHECKLOCKTIMEVERIFY)
        builder.AddOp(txscript.OP_DROP)

        builder.AddInt64(int64(csvTimeout))
        builder.AddOp(txscript.OP_CHECKSEQUENCEVERIFY)
        builder.AddOp(txscript.OP_DROP)

        builder.AddData(selfKey.SerializeCompressed())

        builder.AddOp(txscript.OP_ENDIF)

        // Finally, we'll validate the signature against the public key that's
        // left on the top of the stack.
        builder.AddOp(txscript.OP_CHECKSIG)

        return builder.Script()
}</span>

// CommitSpendTimeout constructs a valid witness allowing the owner of a
// particular commitment transaction to spend the output returning settled
// funds back to themselves after a relative block timeout.  In order to
// properly spend the transaction, the target input's sequence number should be
// set accordingly based off of the target relative block timeout within the
// redeem script.  Additionally, OP_CSV requires that the version of the
// transaction spending a pkscript with OP_CSV within it *must* be &gt;= 2.
func CommitSpendTimeout(signer Signer, signDesc *SignDescriptor,
        sweepTx *wire.MsgTx) (wire.TxWitness, error) <span class="cov0" title="0">{

        // Ensure the transaction version supports the validation of sequence
        // locks and CSV semantics.
        if sweepTx.Version &lt; 2 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("version of passed transaction MUST "+
                        "be &gt;= 2, not %v", sweepTx.Version)
        }</span>

        // With the sequence number in place, we're now able to properly sign
        // off on the sweep transaction.
        <span class="cov0" title="0">sweepSig, err := signer.SignOutputRaw(sweepTx, signDesc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Place an empty byte as the first item in the evaluated witness stack
        // to force script execution to the timeout spend clause. We need to
        // place an empty byte in order to ensure our script is still valid
        // from the PoV of nodes that are enforcing minimal OP_IF/OP_NOTIF.
        <span class="cov0" title="0">witnessStack := wire.TxWitness(make([][]byte, 3))
        witnessStack[0] = append(sweepSig.Serialize(), byte(signDesc.HashType))
        witnessStack[1] = nil
        witnessStack[2] = signDesc.WitnessScript

        return witnessStack, nil</span>
}

// CommitSpendRevoke constructs a valid witness allowing a node to sweep the
// settled output of a malicious counterparty who broadcasts a revoked
// commitment transaction.
//
// NOTE: The passed SignDescriptor should include the raw (untweaked)
// revocation base public key of the receiver and also the proper double tweak
// value based on the commitment secret of the revoked commitment.
func CommitSpendRevoke(signer Signer, signDesc *SignDescriptor,
        sweepTx *wire.MsgTx) (wire.TxWitness, error) <span class="cov0" title="0">{

        sweepSig, err := signer.SignOutputRaw(sweepTx, signDesc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Place a 1 as the first item in the evaluated witness stack to
        // force script execution to the revocation clause.
        <span class="cov0" title="0">witnessStack := wire.TxWitness(make([][]byte, 3))
        witnessStack[0] = append(sweepSig.Serialize(), byte(signDesc.HashType))
        witnessStack[1] = []byte{1}
        witnessStack[2] = signDesc.WitnessScript

        return witnessStack, nil</span>
}

// CommitSpendNoDelay constructs a valid witness allowing a node to spend their
// settled no-delay output on the counterparty's commitment transaction. If the
// tweakless field is true, then we'll omit the set where we tweak the pubkey
// with a random set of bytes, and use it directly in the witness stack.
//
// NOTE: The passed SignDescriptor should include the raw (untweaked) public
// key of the receiver and also the proper single tweak value based on the
// current commitment point.
func CommitSpendNoDelay(signer Signer, signDesc *SignDescriptor,
        sweepTx *wire.MsgTx, tweakless bool) (wire.TxWitness, error) <span class="cov0" title="0">{

        if signDesc.KeyDesc.PubKey == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot generate witness with nil " +
                        "KeyDesc pubkey")
        }</span>

        // This is just a regular p2wkh spend which looks something like:
        //  * witness: &lt;sig&gt; &lt;pubkey&gt;
        <span class="cov0" title="0">sweepSig, err := signer.SignOutputRaw(sweepTx, signDesc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Finally, we'll manually craft the witness. The witness here is the
        // exact same as a regular p2wkh witness, depending on the value of the
        // tweakless bool.
        <span class="cov0" title="0">witness := make([][]byte, 2)
        witness[0] = append(sweepSig.Serialize(), byte(signDesc.HashType))

        switch tweakless </span>{
        // If we're tweaking the key, then we use the tweaked public key as the
        // last item in the witness stack which was originally used to created
        // the pkScript we're spending.
        case false:<span class="cov0" title="0">
                witness[1] = TweakPubKeyWithTweak(
                        signDesc.KeyDesc.PubKey, signDesc.SingleTweak,
                ).SerializeCompressed()</span>

        // Otherwise, we can just use the raw pubkey, since there's no random
        // value to be combined.
        case true:<span class="cov0" title="0">
                witness[1] = signDesc.KeyDesc.PubKey.SerializeCompressed()</span>
        }

        <span class="cov0" title="0">return witness, nil</span>
}

// CommitScriptUnencumbered constructs the public key script on the commitment
// transaction paying to the "other" party. The constructed output is a normal
// p2wkh output spendable immediately, requiring no contestation period.
func CommitScriptUnencumbered(key *btcec.PublicKey) ([]byte, error) <span class="cov0" title="0">{
        // This script goes to the "other" party, and is spendable immediately.
        builder := txscript.NewScriptBuilder(txscript.WithScriptAllocSize(
                P2WPKHSize,
        ))
        builder.AddOp(txscript.OP_0)
        builder.AddData(btcutil.Hash160(key.SerializeCompressed()))

        return builder.Script()
}</span>

// CommitScriptToRemoteConfirmed constructs the script for the output on the
// commitment transaction paying to the remote party of said commitment
// transaction. The money can only be spend after one confirmation.
//
// Possible Input Scripts:
//
//        SWEEP: &lt;sig&gt;
//
// Output Script:
//
//        &lt;key&gt; OP_CHECKSIGVERIFY
//        1 OP_CHECKSEQUENCEVERIFY
func CommitScriptToRemoteConfirmed(key *btcec.PublicKey) ([]byte, error) <span class="cov0" title="0">{
        builder := txscript.NewScriptBuilder(txscript.WithScriptAllocSize(
                ToRemoteConfirmedScriptSize,
        ))

        // Only the given key can spend the output.
        builder.AddData(key.SerializeCompressed())
        builder.AddOp(txscript.OP_CHECKSIGVERIFY)

        // Check that the it has one confirmation.
        builder.AddOp(txscript.OP_1)
        builder.AddOp(txscript.OP_CHECKSEQUENCEVERIFY)

        return builder.Script()
}</span>

// NewRemoteCommitScriptTree constructs a new script tree for the remote party
// to sweep their funds after a hard coded 1 block delay.
func NewRemoteCommitScriptTree(remoteKey *btcec.PublicKey,
        auxLeaf AuxTapLeaf) (*CommitScriptTree, error) <span class="cov0" title="0">{

        // First, construct the remote party's tapscript they'll use to sweep
        // their outputs.
        builder := txscript.NewScriptBuilder()
        builder.AddData(schnorr.SerializePubKey(remoteKey))
        builder.AddOp(txscript.OP_CHECKSIG)
        builder.AddOp(txscript.OP_1)
        builder.AddOp(txscript.OP_CHECKSEQUENCEVERIFY)
        builder.AddOp(txscript.OP_DROP)

        remoteScript, err := builder.Script()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">tapLeaf := txscript.NewBaseTapLeaf(remoteScript)

        tapLeaves := []txscript.TapLeaf{tapLeaf}
        auxLeaf.WhenSome(func(l txscript.TapLeaf) </span><span class="cov0" title="0">{
                tapLeaves = append(tapLeaves, l)
        }</span>)

        // With this script constructed, we'll map that into a tapLeaf, then
        // make a new tapscript root from that.
        <span class="cov0" title="0">tapScriptTree := txscript.AssembleTaprootScriptTree(tapLeaves...)
        tapScriptRoot := tapScriptTree.RootNode.TapHash()

        // Now that we have our root, we can arrive at the final output script
        // by tweaking the internal key with this root.
        toRemoteOutputKey := txscript.ComputeTaprootOutputKey(
                &amp;TaprootNUMSKey, tapScriptRoot[:],
        )

        return &amp;CommitScriptTree{
                ScriptTree: ScriptTree{
                        TaprootKey:    toRemoteOutputKey,
                        TapscriptTree: tapScriptTree,
                        TapscriptRoot: tapScriptRoot[:],
                        InternalKey:   &amp;TaprootNUMSKey,
                },
                SettleLeaf: tapLeaf,
                AuxLeaf:    auxLeaf,
        }, nil</span>
}

// TaprootCommitScriptToRemote constructs a taproot witness program for the
// output on the commitment transaction for the remote party. For the top level
// key spend, we'll use a NUMs key to ensure that only the script path can be
// taken. Using a set NUMs key here also means that recovery solutions can scan
// the chain given knowledge of the public key for the remote party. We then
// commit to a single tapscript leaf that holds the normal CSV 1 delay
// script.
//
// Our single tapleaf will use the following script:
//
//        &lt;remotepubkey&gt; OP_CHECKSIG
//        1 OP_CHECKSEQUENCEVERIFY OP_DROP
func TaprootCommitScriptToRemote(remoteKey *btcec.PublicKey,
        auxLeaf AuxTapLeaf) (*btcec.PublicKey, error) <span class="cov0" title="0">{

        commitScriptTree, err := NewRemoteCommitScriptTree(remoteKey, auxLeaf)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return commitScriptTree.TaprootKey, nil</span>
}

// TaprootCommitRemoteSpend allows the remote party to sweep their output into
// their wallet after an enforced 1 block delay.
func TaprootCommitRemoteSpend(signer Signer, signDesc *SignDescriptor,
        sweepTx *wire.MsgTx,
        scriptTree *txscript.IndexedTapScriptTree) (wire.TxWitness, error) <span class="cov0" title="0">{

        // First, we'll need to construct a valid control block to execute the
        // leaf script for sweep settlement.
        var ctrlBlockBytes []byte
        if signDesc.ControlBlock == nil </span><span class="cov0" title="0">{
                settleControlBlock := MakeTaprootCtrlBlock(
                        signDesc.WitnessScript, &amp;TaprootNUMSKey, scriptTree,
                )
                ctrlBytes, err := settleControlBlock.ToBytes()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">ctrlBlockBytes = ctrlBytes</span>
        } else<span class="cov0" title="0"> {
                ctrlBlockBytes = signDesc.ControlBlock
        }</span>

        // With the control block created, we'll now generate the signature we
        // need to authorize the spend.
        <span class="cov0" title="0">sweepSig, err := signer.SignOutputRaw(sweepTx, signDesc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // The final witness stack will be:
        //
        //  &lt;sweep sig&gt; &lt;sweep script&gt; &lt;control block&gt;
        <span class="cov0" title="0">witnessStack := make(wire.TxWitness, 3)
        witnessStack[0] = maybeAppendSighash(sweepSig, signDesc.HashType)
        witnessStack[1] = signDesc.WitnessScript
        witnessStack[2] = ctrlBlockBytes

        return witnessStack, nil</span>
}

// LeaseCommitScriptToRemoteConfirmed constructs the script for the output on
// the commitment transaction paying to the remote party of said commitment
// transaction. The money can only be spend after one confirmation.
//
// Possible Input Scripts:
//
//        SWEEP: &lt;sig&gt;
//
// Output Script:
//
//                &lt;key&gt; OP_CHECKSIGVERIFY
//             &lt;lease maturity in blocks&gt; OP_CHECKLOCKTIMEVERIFY OP_DROP
//                1 OP_CHECKSEQUENCEVERIFY
func LeaseCommitScriptToRemoteConfirmed(key *btcec.PublicKey,
        leaseExpiry uint32) ([]byte, error) <span class="cov0" title="0">{

        builder := txscript.NewScriptBuilder(txscript.WithScriptAllocSize(45))

        // Only the given key can spend the output.
        builder.AddData(key.SerializeCompressed())
        builder.AddOp(txscript.OP_CHECKSIGVERIFY)

        // The channel initiator always has the additional channel lease
        // expiration constraint for outputs that pay to them which must be
        // satisfied.
        builder.AddInt64(int64(leaseExpiry))
        builder.AddOp(txscript.OP_CHECKLOCKTIMEVERIFY)
        builder.AddOp(txscript.OP_DROP)

        // Check that it has one confirmation.
        builder.AddOp(txscript.OP_1)
        builder.AddOp(txscript.OP_CHECKSEQUENCEVERIFY)

        return builder.Script()
}</span>

// CommitSpendToRemoteConfirmed constructs a valid witness allowing a node to
// spend their settled output on the counterparty's commitment transaction when
// it has one confirmetion. This is used for the anchor channel type. The
// spending key will always be non-tweaked for this output type.
func CommitSpendToRemoteConfirmed(signer Signer, signDesc *SignDescriptor,
        sweepTx *wire.MsgTx) (wire.TxWitness, error) <span class="cov0" title="0">{

        if signDesc.KeyDesc.PubKey == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot generate witness with nil " +
                        "KeyDesc pubkey")
        }</span>

        // Similar to non delayed output, only a signature is needed.
        <span class="cov0" title="0">sweepSig, err := signer.SignOutputRaw(sweepTx, signDesc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Finally, we'll manually craft the witness. The witness here is the
        // signature and the redeem script.
        <span class="cov0" title="0">witnessStack := make([][]byte, 2)
        witnessStack[0] = append(sweepSig.Serialize(), byte(signDesc.HashType))
        witnessStack[1] = signDesc.WitnessScript

        return witnessStack, nil</span>
}

// CommitScriptAnchor constructs the script for the anchor output spendable by
// the given key immediately, or by anyone after 16 confirmations.
//
// Possible Input Scripts:
//
//        By owner:                                &lt;sig&gt;
//        By anyone (after 16 conf):        &lt;emptyvector&gt;
//
// Output Script:
//
//        &lt;funding_pubkey&gt; OP_CHECKSIG OP_IFDUP
//        OP_NOTIF
//          OP_16 OP_CSV
//        OP_ENDIF
func CommitScriptAnchor(key *btcec.PublicKey) ([]byte, error) <span class="cov0" title="0">{
        builder := txscript.NewScriptBuilder(txscript.WithScriptAllocSize(
                AnchorScriptSize,
        ))

        // Spend immediately with key.
        builder.AddData(key.SerializeCompressed())
        builder.AddOp(txscript.OP_CHECKSIG)

        // Duplicate the value if true, since it will be consumed by the NOTIF.
        builder.AddOp(txscript.OP_IFDUP)

        // Otherwise spendable by anyone after 16 confirmations.
        builder.AddOp(txscript.OP_NOTIF)
        builder.AddOp(txscript.OP_16)
        builder.AddOp(txscript.OP_CHECKSEQUENCEVERIFY)
        builder.AddOp(txscript.OP_ENDIF)

        return builder.Script()
}</span>

// AnchorScriptTree holds all the contents needed to sweep a taproot anchor
// output on chain.
type AnchorScriptTree struct {
        ScriptTree

        // SweepLeaf is the leaf used to settle the output after the delay.
        SweepLeaf txscript.TapLeaf
}

// NewAnchorScriptTree makes a new script tree for an anchor output with the
// passed anchor key.
func NewAnchorScriptTree(
        anchorKey *btcec.PublicKey) (*AnchorScriptTree, error) <span class="cov0" title="0">{

        // The main script used is just a OP_16 CSV (anyone can sweep after 16
        // blocks).
        builder := txscript.NewScriptBuilder()
        builder.AddOp(txscript.OP_16)
        builder.AddOp(txscript.OP_CHECKSEQUENCEVERIFY)

        anchorScript, err := builder.Script()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // With the script, we can make our sole leaf, then derive the root
        // from that.
        <span class="cov0" title="0">tapLeaf := txscript.NewBaseTapLeaf(anchorScript)
        tapScriptTree := txscript.AssembleTaprootScriptTree(tapLeaf)
        tapScriptRoot := tapScriptTree.RootNode.TapHash()

        // Now that we have our root, we can arrive at the final output script
        // by tweaking the internal key with this root.
        anchorOutputKey := txscript.ComputeTaprootOutputKey(
                anchorKey, tapScriptRoot[:],
        )

        return &amp;AnchorScriptTree{
                ScriptTree: ScriptTree{
                        TaprootKey:    anchorOutputKey,
                        TapscriptTree: tapScriptTree,
                        TapscriptRoot: tapScriptRoot[:],
                        InternalKey:   anchorKey,
                },
                SweepLeaf: tapLeaf,
        }, nil</span>
}

// WitnessScriptToSign returns the witness script that we'll use when signing
// for the remote party, and also verifying signatures on our transactions. As
// an example, when we create an outgoing HTLC for the remote party, we want to
// sign their success path.
func (a *AnchorScriptTree) WitnessScriptToSign() []byte <span class="cov0" title="0">{
        return a.SweepLeaf.Script
}</span>

// WitnessScriptForPath returns the witness script for the given spending path.
// An error is returned if the path is unknown.
func (a *AnchorScriptTree) WitnessScriptForPath(
        path ScriptPath) ([]byte, error) <span class="cov0" title="0">{

        switch path </span>{
        case ScriptPathDelay:<span class="cov0" title="0">
                fallthrough</span>
        case ScriptPathSuccess:<span class="cov0" title="0">
                return a.SweepLeaf.Script, nil</span>

        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unknown script path: %v", path)</span>
        }
}

// CtrlBlockForPath returns the control block for the given spending path. For
// script types that don't have a control block, nil is returned.
func (a *AnchorScriptTree) CtrlBlockForPath(
        path ScriptPath) (*txscript.ControlBlock, error) <span class="cov0" title="0">{

        switch path </span>{
        case ScriptPathDelay:<span class="cov0" title="0">
                fallthrough</span>
        case ScriptPathSuccess:<span class="cov0" title="0">
                return lnutils.Ptr(MakeTaprootCtrlBlock(
                        a.SweepLeaf.Script, a.InternalKey,
                        a.TapscriptTree,
                )), nil</span>

        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unknown script path: %v", path)</span>
        }
}

// Tree returns the underlying ScriptTree of the AnchorScriptTree.
func (a *AnchorScriptTree) Tree() ScriptTree <span class="cov0" title="0">{
        return a.ScriptTree
}</span>

// A compile time check to ensure AnchorScriptTree implements the
// TapscriptDescriptor interface.
var _ TapscriptDescriptor = (*AnchorScriptTree)(nil)

// TaprootOutputKeyAnchor returns the segwit v1 (taproot) witness program that
// encodes the anchor output spending conditions: the passed key can be used
// for keyspend, with the OP_CSV 16 clause living within an internal tapscript
// leaf.
//
// Spend paths:
//   - Key spend: &lt;key_signature&gt;
//   - Script spend: OP_16 CSV &lt;control_block&gt;
func TaprootOutputKeyAnchor(key *btcec.PublicKey) (*btcec.PublicKey, error) <span class="cov0" title="0">{
        anchorScriptTree, err := NewAnchorScriptTree(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return anchorScriptTree.TaprootKey, nil</span>
}

// TaprootAnchorSpend constructs a valid witness allowing a node to sweep their
// anchor output.
func TaprootAnchorSpend(signer Signer, signDesc *SignDescriptor,
        sweepTx *wire.MsgTx) (wire.TxWitness, error) <span class="cov0" title="0">{

        // For this spend type, we only need a single signature which'll be a
        // keyspend using the anchor private key.
        sweepSig, err := signer.SignOutputRaw(sweepTx, signDesc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // The witness stack in this case is pretty simple: we only need to
        // specify the signature generated.
        <span class="cov0" title="0">witnessStack := make(wire.TxWitness, 1)
        witnessStack[0] = maybeAppendSighash(sweepSig, signDesc.HashType)

        return witnessStack, nil</span>
}

// TaprootAnchorSpendAny constructs a valid witness allowing anyone to sweep
// the anchor output after 16 blocks.
func TaprootAnchorSpendAny(anchorKey *btcec.PublicKey) (wire.TxWitness, error) <span class="cov0" title="0">{
        anchorScriptTree, err := NewAnchorScriptTree(anchorKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // For this spend, the only thing we need to do is create a valid
        // control block. Other than that, there're no restrictions to how the
        // output can be spent.
        <span class="cov0" title="0">scriptTree := anchorScriptTree.TapscriptTree
        sweepLeaf := anchorScriptTree.SweepLeaf
        sweepIdx := scriptTree.LeafProofIndex[sweepLeaf.TapHash()]
        sweepMerkleProof := scriptTree.LeafMerkleProofs[sweepIdx]
        sweepControlBlock := sweepMerkleProof.ToControlBlock(anchorKey)

        // The final witness stack will be:
        //
        //  &lt;sweep script&gt; &lt;control block&gt;
        witnessStack := make(wire.TxWitness, 2)
        witnessStack[0] = sweepLeaf.Script
        witnessStack[1], err = sweepControlBlock.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return witnessStack, nil</span>
}

// CommitSpendAnchor constructs a valid witness allowing a node to spend their
// anchor output on the commitment transaction using their funding key. This is
// used for the anchor channel type.
func CommitSpendAnchor(signer Signer, signDesc *SignDescriptor,
        sweepTx *wire.MsgTx) (wire.TxWitness, error) <span class="cov0" title="0">{

        if signDesc.KeyDesc.PubKey == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot generate witness with nil " +
                        "KeyDesc pubkey")
        }</span>

        // Create a signature.
        <span class="cov0" title="0">sweepSig, err := signer.SignOutputRaw(sweepTx, signDesc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // The witness here is just a signature and the redeem script.
        <span class="cov0" title="0">witnessStack := make([][]byte, 2)
        witnessStack[0] = append(sweepSig.Serialize(), byte(signDesc.HashType))
        witnessStack[1] = signDesc.WitnessScript

        return witnessStack, nil</span>
}

// CommitSpendAnchorAnyone constructs a witness allowing anyone to spend the
// anchor output after it has gotten 16 confirmations. Since no signing is
// required, only knowledge of the redeem script is necessary to spend it.
func CommitSpendAnchorAnyone(script []byte) (wire.TxWitness, error) <span class="cov0" title="0">{
        // The witness here is just the redeem script.
        witnessStack := make([][]byte, 2)
        witnessStack[0] = nil
        witnessStack[1] = script

        return witnessStack, nil
}</span>

// SingleTweakBytes computes set of bytes we call the single tweak. The purpose
// of the single tweak is to randomize all regular delay and payment base
// points. To do this, we generate a hash that binds the commitment point to
// the pay/delay base point. The end result is that the basePoint is
// tweaked as follows:
//
//   - key = basePoint + sha256(commitPoint || basePoint)*G
func SingleTweakBytes(commitPoint, basePoint *btcec.PublicKey) []byte <span class="cov0" title="0">{
        h := sha256.New()
        h.Write(commitPoint.SerializeCompressed())
        h.Write(basePoint.SerializeCompressed())
        return h.Sum(nil)
}</span>

// TweakPubKey tweaks a public base point given a per commitment point. The per
// commitment point is a unique point on our target curve for each commitment
// transaction. When tweaking a local base point for use in a remote commitment
// transaction, the remote party's current per commitment point is to be used.
// The opposite applies for when tweaking remote keys. Precisely, the following
// operation is used to "tweak" public keys:
//
//        tweakPub := basePoint + sha256(commitPoint || basePoint) * G
//                 := G*k + sha256(commitPoint || basePoint)*G
//                 := G*(k + sha256(commitPoint || basePoint))
//
// Therefore, if a party possess the value k, the private key of the base
// point, then they are able to derive the proper private key for the
// revokeKey by computing:
//
//        revokePriv := k + sha256(commitPoint || basePoint) mod N
//
// Where N is the order of the sub-group.
//
// The rationale for tweaking all public keys used within the commitment
// contracts is to ensure that all keys are properly delinearized to avoid any
// funny business when jointly collaborating to compute public and private
// keys. Additionally, the use of the per commitment point ensures that each
// commitment state houses a unique set of keys which is useful when creating
// blinded channel outsourcing protocols.
//
// TODO(roasbeef): should be using double-scalar mult here
func TweakPubKey(basePoint, commitPoint *btcec.PublicKey) *btcec.PublicKey <span class="cov0" title="0">{
        tweakBytes := SingleTweakBytes(commitPoint, basePoint)
        return TweakPubKeyWithTweak(basePoint, tweakBytes)
}</span>

// TweakPubKeyWithTweak is the exact same as the TweakPubKey function, however
// it accepts the raw tweak bytes directly rather than the commitment point.
func TweakPubKeyWithTweak(pubKey *btcec.PublicKey,
        tweakBytes []byte) *btcec.PublicKey <span class="cov0" title="0">{

        var (
                pubKeyJacobian btcec.JacobianPoint
                tweakJacobian  btcec.JacobianPoint
                resultJacobian btcec.JacobianPoint
        )
        tweakKey, _ := btcec.PrivKeyFromBytes(tweakBytes)
        btcec.ScalarBaseMultNonConst(&amp;tweakKey.Key, &amp;tweakJacobian)

        pubKey.AsJacobian(&amp;pubKeyJacobian)
        btcec.AddNonConst(&amp;pubKeyJacobian, &amp;tweakJacobian, &amp;resultJacobian)

        resultJacobian.ToAffine()
        return btcec.NewPublicKey(&amp;resultJacobian.X, &amp;resultJacobian.Y)
}</span>

// TweakPrivKey tweaks the private key of a public base point given a per
// commitment point. The per commitment secret is the revealed revocation
// secret for the commitment state in question. This private key will only need
// to be generated in the case that a channel counter party broadcasts a
// revoked state. Precisely, the following operation is used to derive a
// tweaked private key:
//
//   - tweakPriv := basePriv + sha256(commitment || basePub) mod N
//
// Where N is the order of the sub-group.
func TweakPrivKey(basePriv *btcec.PrivateKey,
        commitTweak []byte) *btcec.PrivateKey <span class="cov0" title="0">{

        // tweakInt := sha256(commitPoint || basePub)
        tweakScalar := new(btcec.ModNScalar)
        tweakScalar.SetByteSlice(commitTweak)

        tweakScalar.Add(&amp;basePriv.Key)

        return &amp;btcec.PrivateKey{Key: *tweakScalar}
}</span>

// DeriveRevocationPubkey derives the revocation public key given the
// counterparty's commitment key, and revocation preimage derived via a
// pseudo-random-function. In the event that we (for some reason) broadcast a
// revoked commitment transaction, then if the other party knows the revocation
// preimage, then they'll be able to derive the corresponding private key to
// this private key by exploiting the homomorphism in the elliptic curve group:
//   - https://en.wikipedia.org/wiki/Group_homomorphism#Homomorphisms_of_abelian_groups
//
// The derivation is performed as follows:
//
//        revokeKey := revokeBase * sha256(revocationBase || commitPoint) +
//                     commitPoint * sha256(commitPoint || revocationBase)
//
//                  := G*(revokeBasePriv * sha256(revocationBase || commitPoint)) +
//                     G*(commitSecret * sha256(commitPoint || revocationBase))
//
//                  := G*(revokeBasePriv * sha256(revocationBase || commitPoint) +
//                        commitSecret * sha256(commitPoint || revocationBase))
//
// Therefore, once we divulge the revocation secret, the remote peer is able to
// compute the proper private key for the revokeKey by computing:
//
//        revokePriv := (revokeBasePriv * sha256(revocationBase || commitPoint)) +
//                      (commitSecret * sha256(commitPoint || revocationBase)) mod N
//
// Where N is the order of the sub-group.
func DeriveRevocationPubkey(revokeBase,
        commitPoint *btcec.PublicKey) *btcec.PublicKey <span class="cov0" title="0">{

        // R = revokeBase * sha256(revocationBase || commitPoint)
        revokeTweakBytes := SingleTweakBytes(revokeBase, commitPoint)
        revokeTweakScalar := new(btcec.ModNScalar)
        revokeTweakScalar.SetByteSlice(revokeTweakBytes)

        var (
                revokeBaseJacobian btcec.JacobianPoint
                rJacobian          btcec.JacobianPoint
        )
        revokeBase.AsJacobian(&amp;revokeBaseJacobian)
        btcec.ScalarMultNonConst(
                revokeTweakScalar, &amp;revokeBaseJacobian, &amp;rJacobian,
        )

        // C = commitPoint * sha256(commitPoint || revocationBase)
        commitTweakBytes := SingleTweakBytes(commitPoint, revokeBase)
        commitTweakScalar := new(btcec.ModNScalar)
        commitTweakScalar.SetByteSlice(commitTweakBytes)

        var (
                commitPointJacobian btcec.JacobianPoint
                cJacobian           btcec.JacobianPoint
        )
        commitPoint.AsJacobian(&amp;commitPointJacobian)
        btcec.ScalarMultNonConst(
                commitTweakScalar, &amp;commitPointJacobian, &amp;cJacobian,
        )

        // Now that we have the revocation point, we add this to their commitment
        // public key in order to obtain the revocation public key.
        //
        // P = R + C
        var resultJacobian btcec.JacobianPoint
        btcec.AddNonConst(&amp;rJacobian, &amp;cJacobian, &amp;resultJacobian)

        resultJacobian.ToAffine()
        return btcec.NewPublicKey(&amp;resultJacobian.X, &amp;resultJacobian.Y)
}</span>

// DeriveRevocationPrivKey derives the revocation private key given a node's
// commitment private key, and the preimage to a previously seen revocation
// hash. Using this derived private key, a node is able to claim the output
// within the commitment transaction of a node in the case that they broadcast
// a previously revoked commitment transaction.
//
// The private key is derived as follows:
//
//        revokePriv := (revokeBasePriv * sha256(revocationBase || commitPoint)) +
//                      (commitSecret * sha256(commitPoint || revocationBase)) mod N
//
// Where N is the order of the sub-group.
func DeriveRevocationPrivKey(revokeBasePriv *btcec.PrivateKey,
        commitSecret *btcec.PrivateKey) *btcec.PrivateKey <span class="cov0" title="0">{

        // r = sha256(revokeBasePub || commitPoint)
        revokeTweakBytes := SingleTweakBytes(
                revokeBasePriv.PubKey(), commitSecret.PubKey(),
        )
        revokeTweakScalar := new(btcec.ModNScalar)
        revokeTweakScalar.SetByteSlice(revokeTweakBytes)

        // c = sha256(commitPoint || revokeBasePub)
        commitTweakBytes := SingleTweakBytes(
                commitSecret.PubKey(), revokeBasePriv.PubKey(),
        )
        commitTweakScalar := new(btcec.ModNScalar)
        commitTweakScalar.SetByteSlice(commitTweakBytes)

        // Finally to derive the revocation secret key we'll perform the
        // following operation:
        //
        //  k = (revocationPriv * r) + (commitSecret * c) mod N
        //
        // This works since:
        //  P = (G*a)*b + (G*c)*d
        //  P = G*(a*b) + G*(c*d)
        //  P = G*(a*b + c*d)
        revokeHalfPriv := revokeTweakScalar.Mul(&amp;revokeBasePriv.Key)
        commitHalfPriv := commitTweakScalar.Mul(&amp;commitSecret.Key)

        revocationPriv := revokeHalfPriv.Add(commitHalfPriv)

        return &amp;btcec.PrivateKey{Key: *revocationPriv}
}</span>

// ComputeCommitmentPoint generates a commitment point given a commitment
// secret. The commitment point for each state is used to randomize each key in
// the key-ring and also to used as a tweak to derive new public+private keys
// for the state.
func ComputeCommitmentPoint(commitSecret []byte) *btcec.PublicKey <span class="cov0" title="0">{
        _, pubKey := btcec.PrivKeyFromBytes(commitSecret)
        return pubKey
}</span>

// ScriptIsOpReturn returns true if the passed script is an OP_RETURN script.
//
// Lifted from the txscript package:
// https://github.com/btcsuite/btcd/blob/cc26860b40265e1332cca8748c5dbaf3c81cc094/txscript/standard.go#L493-L526.
//
//nolint:ll
func ScriptIsOpReturn(script []byte) bool <span class="cov0" title="0">{
        // A null script is of the form:
        //  OP_RETURN &lt;optional data&gt;
        //
        // Thus, it can either be a single OP_RETURN or an OP_RETURN followed by
        // a data push up to MaxDataCarrierSize bytes.

        // The script can't possibly be a null data script if it doesn't start
        // with OP_RETURN.  Fail fast to avoid more work below.
        if len(script) &lt; 1 || script[0] != txscript.OP_RETURN </span><span class="cov0" title="0">{
                return false
        }</span>

        // Single OP_RETURN.
        <span class="cov0" title="0">if len(script) == 1 </span><span class="cov0" title="0">{
                return true
        }</span>

        // OP_RETURN followed by data push up to MaxDataCarrierSize bytes.
        <span class="cov0" title="0">tokenizer := txscript.MakeScriptTokenizer(0, script[1:])

        return tokenizer.Next() &amp;&amp; tokenizer.Done() &amp;&amp;
                (txscript.IsSmallInt(tokenizer.Opcode()) ||
                        tokenizer.Opcode() &lt;= txscript.OP_PUSHDATA4) &amp;&amp;
                len(tokenizer.Data()) &lt;= txscript.MaxDataCarrierSize</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package input

import (
        "encoding/binary"
        "errors"
        "fmt"
        "io"

        "github.com/btcsuite/btcd/btcec/v2"
        "github.com/btcsuite/btcd/txscript"
        "github.com/btcsuite/btcd/wire"
        "github.com/lightningnetwork/lnd/keychain"
)

var (
        // ErrTweakOverdose signals a SignDescriptor is invalid because both of its
        // SingleTweak and DoubleTweak are non-nil.
        ErrTweakOverdose = errors.New("sign descriptor should only have one tweak")
)

// SignDescriptor houses the necessary information required to successfully
// sign a given segwit output. This struct is used by the Signer interface in
// order to gain access to critical data needed to generate a valid signature.
type SignDescriptor struct {
        // KeyDesc is a descriptor that precisely describes *which* key to use
        // for signing. This may provide the raw public key directly, or
        // require the Signer to re-derive the key according to the populated
        // derivation path.
        KeyDesc keychain.KeyDescriptor

        // SingleTweak is a scalar value that will be added to the private key
        // corresponding to the above public key to obtain the private key to
        // be used to sign this input. This value is typically derived via the
        // following computation:
        //
        //  * derivedKey = privkey + sha256(perCommitmentPoint || pubKey) mod N
        //
        // NOTE: If this value is nil, then the input can be signed using only
        // the above public key. Either a SingleTweak should be set or a
        // DoubleTweak, not both.
        SingleTweak []byte

        // DoubleTweak is a private key that will be used in combination with
        // its corresponding private key to derive the private key that is to
        // be used to sign the target input. Within the Lightning protocol,
        // this value is typically the commitment secret from a previously
        // revoked commitment transaction. This value is in combination with
        // two hash values, and the original private key to derive the private
        // key to be used when signing.
        //
        //  * k = (privKey*sha256(pubKey || tweakPub) +
        //        tweakPriv*sha256(tweakPub || pubKey)) mod N
        //
        // NOTE: If this value is nil, then the input can be signed using only
        // the above public key. Either a SingleTweak should be set or a
        // DoubleTweak, not both.
        DoubleTweak *btcec.PrivateKey

        // TapTweak is a 32-byte value that will be used to derive a taproot
        // output public key (or the corresponding private key) from an
        // internal key and this tweak. The transformation applied is:
        //  * outputKey = internalKey +
        //        tagged_hash("tapTweak", internalKey || tapTweak)
        //
        // When attempting to sign an output derived via BIP 86, then this
        // field should be an empty byte array.
        //
        // When attempting to sign for the key spend path of an output key that
        // commits to an actual script tree, the script root should be used.
        TapTweak []byte

        // WitnessScript is the full script required to properly redeem the
        // output. This field should be set to the full script if a p2wsh
        // output is being signed. For p2wkh it should be set to the hashed
        // script (PkScript).
        WitnessScript []byte

        // SignMethod specifies how the input should be signed. Depending on the
        // selected method, either the TapTweak, WitnessScript or both need to
        // be specified.
        SignMethod SignMethod

        // Output is the target output which should be signed. The PkScript and
        // Value fields within the output should be properly populated,
        // otherwise an invalid signature may be generated.
        Output *wire.TxOut

        // HashType is the target sighash type that should be used when
        // generating the final sighash, and signature.
        HashType txscript.SigHashType

        // SigHashes is the pre-computed sighash midstate to be used when
        // generating the final sighash for signing.
        SigHashes *txscript.TxSigHashes

        // PrevOutputFetcher is an interface that can return the output
        // information on all UTXOs that are being spent in this transaction.
        // This MUST be set when spending Taproot outputs.
        PrevOutputFetcher txscript.PrevOutputFetcher

        // ControlBlock is a fully serialized control block that contains the
        // merkle proof necessary to spend a taproot output. This may
        // optionally be set if the SignMethod is
        // input.TaprootScriptSpendSignMethod. In which case, this should be an
        // inclusion proof for the WitnessScript.
        ControlBlock []byte

        // InputIndex is the target input within the transaction that should be
        // signed.
        InputIndex int
}

// SignMethod defines the different ways a signer can sign, given a specific
// input.
type SignMethod uint8

const (
        // WitnessV0SignMethod denotes that a SegWit v0 (p2wkh, np2wkh, p2wsh)
        // input script should be signed.
        WitnessV0SignMethod SignMethod = 0

        // TaprootKeySpendBIP0086SignMethod denotes that a SegWit v1 (p2tr)
        // input should be signed by using the BIP0086 method (commit to
        // internal key only).
        TaprootKeySpendBIP0086SignMethod SignMethod = 1

        // TaprootKeySpendSignMethod denotes that a SegWit v1 (p2tr)
        // input should be signed by using a given taproot hash to commit to in
        // addition to the internal key.
        TaprootKeySpendSignMethod SignMethod = 2

        // TaprootScriptSpendSignMethod denotes that a SegWit v1 (p2tr) input
        // should be spent using the script path and that a specific leaf script
        // should be signed for.
        TaprootScriptSpendSignMethod SignMethod = 3
)

// String returns a human-readable representation of the signing method.
func (s SignMethod) String() string <span class="cov0" title="0">{
        switch s </span>{
        case WitnessV0SignMethod:<span class="cov0" title="0">
                return "witness_v0"</span>
        case TaprootKeySpendBIP0086SignMethod:<span class="cov0" title="0">
                return "taproot_key_spend_bip86"</span>
        case TaprootKeySpendSignMethod:<span class="cov0" title="0">
                return "taproot_key_spend"</span>
        case TaprootScriptSpendSignMethod:<span class="cov0" title="0">
                return "taproot_script_spend"</span>
        default:<span class="cov0" title="0">
                return fmt.Sprintf("unknown&lt;%d&gt;", s)</span>
        }
}

// PkScriptCompatible returns true if the given public key script is compatible
// with the sign method.
func (s SignMethod) PkScriptCompatible(pkScript []byte) bool <span class="cov0" title="0">{
        switch s </span>{
        // SegWit v0 can be p2wkh, np2wkh, p2wsh.
        case WitnessV0SignMethod:<span class="cov0" title="0">
                return txscript.IsPayToWitnessPubKeyHash(pkScript) ||
                        txscript.IsPayToWitnessScriptHash(pkScript) ||
                        txscript.IsPayToScriptHash(pkScript)</span>

        case TaprootKeySpendBIP0086SignMethod, TaprootKeySpendSignMethod,
                TaprootScriptSpendSignMethod:<span class="cov0" title="0">

                return txscript.IsPayToTaproot(pkScript)</span>

        default:<span class="cov0" title="0">
                return false</span>
        }
}

// WriteSignDescriptor serializes a SignDescriptor struct into the passed
// io.Writer stream.
//
// NOTE: We assume the SigHashes and InputIndex fields haven't been assigned
// yet, since that is usually done just before broadcast by the witness
// generator.
func WriteSignDescriptor(w io.Writer, sd *SignDescriptor) error <span class="cov0" title="0">{
        err := binary.Write(w, binary.BigEndian, sd.KeyDesc.Family)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = binary.Write(w, binary.BigEndian, sd.KeyDesc.Index)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = binary.Write(w, binary.BigEndian, sd.KeyDesc.PubKey != nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if sd.KeyDesc.PubKey != nil </span><span class="cov0" title="0">{
                serializedPubKey := sd.KeyDesc.PubKey.SerializeCompressed()
                if err := wire.WriteVarBytes(w, 0, serializedPubKey); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">if err := wire.WriteVarBytes(w, 0, sd.SingleTweak); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var doubleTweakBytes []byte
        if sd.DoubleTweak != nil </span><span class="cov0" title="0">{
                doubleTweakBytes = sd.DoubleTweak.Serialize()
        }</span>
        <span class="cov0" title="0">if err := wire.WriteVarBytes(w, 0, doubleTweakBytes); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := wire.WriteVarBytes(w, 0, sd.WitnessScript); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := writeTxOut(w, sd.Output); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var scratch [4]byte
        binary.BigEndian.PutUint32(scratch[:], uint32(sd.HashType))
        if _, err := w.Write(scratch[:]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ReadSignDescriptor deserializes a SignDescriptor struct from the passed
// io.Reader stream.
func ReadSignDescriptor(r io.Reader, sd *SignDescriptor) error <span class="cov0" title="0">{
        err := binary.Read(r, binary.BigEndian, &amp;sd.KeyDesc.Family)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = binary.Read(r, binary.BigEndian, &amp;sd.KeyDesc.Index)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var hasKey bool
        err = binary.Read(r, binary.BigEndian, &amp;hasKey)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if hasKey </span><span class="cov0" title="0">{
                pubKeyBytes, err := wire.ReadVarBytes(r, 0, 34, "pubkey")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">sd.KeyDesc.PubKey, err = btcec.ParsePubKey(pubKeyBytes)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">singleTweak, err := wire.ReadVarBytes(r, 0, 32, "singleTweak")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Serializing a SignDescriptor with a nil-valued SingleTweak results
        // in deserializing a zero-length slice. Since a nil-valued SingleTweak
        // has special meaning and a zero-length slice for a SingleTweak is
        // invalid, we can use the zero-length slice as the flag for a
        // nil-valued SingleTweak.
        <span class="cov0" title="0">if len(singleTweak) == 0 </span><span class="cov0" title="0">{
                sd.SingleTweak = nil
        }</span> else<span class="cov0" title="0"> {
                sd.SingleTweak = singleTweak
        }</span>

        <span class="cov0" title="0">doubleTweakBytes, err := wire.ReadVarBytes(r, 0, 32, "doubleTweak")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Serializing a SignDescriptor with a nil-valued DoubleTweak results
        // in deserializing a zero-length slice. Since a nil-valued DoubleTweak
        // has special meaning and a zero-length slice for a DoubleTweak is
        // invalid, we can use the zero-length slice as the flag for a
        // nil-valued DoubleTweak.
        <span class="cov0" title="0">if len(doubleTweakBytes) == 0 </span><span class="cov0" title="0">{
                sd.DoubleTweak = nil
        }</span> else<span class="cov0" title="0"> {
                sd.DoubleTweak, _ = btcec.PrivKeyFromBytes(doubleTweakBytes)
        }</span>

        // Only one tweak should ever be set, fail if both are present.
        <span class="cov0" title="0">if sd.SingleTweak != nil &amp;&amp; sd.DoubleTweak != nil </span><span class="cov0" title="0">{
                return ErrTweakOverdose
        }</span>

        <span class="cov0" title="0">witnessScript, err := wire.ReadVarBytes(r, 0, 500, "witnessScript")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">sd.WitnessScript = witnessScript

        txOut := &amp;wire.TxOut{}
        if err := readTxOut(r, txOut); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">sd.Output = txOut

        var hashType [4]byte
        if _, err := io.ReadFull(r, hashType[:]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">sd.HashType = txscript.SigHashType(binary.BigEndian.Uint32(hashType[:]))

        return nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package input

import (
        "github.com/btcsuite/btcd/blockchain"
        "github.com/btcsuite/btcd/txscript"
        "github.com/btcsuite/btcd/wire"
        "github.com/btcsuite/btcwallet/waddrmgr"
        "github.com/lightningnetwork/lnd/lntypes"
)

const (
        // witnessScaleFactor determines the level of "discount" witness data
        // receives compared to "base" data. A scale factor of 4, denotes that
        // witness data is 1/4 as cheap as regular non-witness data. Value copied
        // here for convenience.
        witnessScaleFactor = blockchain.WitnessScaleFactor

        // The weight(weight), which is different from the !size! (see BIP-141),
        // is calculated as:
        // Weight = 4 * BaseSize + WitnessSize (weight).
        // BaseSize - size of the transaction without witness data (bytes).
        // WitnessSize - witness size (bytes).
        // Weight - the metric for determining the weight of the transaction.

        // P2WPKHSize 22 bytes
        //        - OP_0: 1 byte
        //        - OP_DATA: 1 byte (PublicKeyHASH160 length)
        //        - PublicKeyHASH160: 20 bytes
        P2WPKHSize = 1 + 1 + 20

        // NestedP2WPKHSize 23 bytes
        //      - OP_DATA: 1 byte (P2WPKHSize)
        //      - P2WPKHWitnessProgram: 22 bytes
        NestedP2WPKHSize = 1 + P2WPKHSize

        // P2WSHSize 34 bytes
        //        - OP_0: 1 byte
        //        - OP_DATA: 1 byte (WitnessScriptSHA256 length)
        //        - WitnessScriptSHA256: 32 bytes
        P2WSHSize = 1 + 1 + 32

        // NestedP2WSHSize 35 bytes
        //      - OP_DATA: 1 byte (P2WSHSize)
        //      - P2WSHWitnessProgram: 34 bytes
        NestedP2WSHSize = 1 + P2WSHSize

        // UnknownWitnessSize 42 bytes
        //      - OP_x: 1 byte
        //      - OP_DATA: 1 byte (max-size length)
        //      - max-size: 40 bytes
        UnknownWitnessSize = 1 + 1 + 40

        // BaseOutputSize 9 bytes
        //     - value: 8 bytes
        //     - var_int: 1 byte (pkscript_length)
        BaseOutputSize = 8 + 1

        // P2PKHSize 25 bytes.
        P2PKHSize = 25

        // P2PKHOutputSize 34 bytes
        //      - value: 8 bytes
        //      - var_int: 1 byte (pkscript_length)
        //      - pkscript (p2pkh): 25 bytes
        P2PKHOutputSize = BaseOutputSize + P2PKHSize

        // P2WKHOutputSize 31 bytes
        //      - value: 8 bytes
        //      - var_int: 1 byte (pkscript_length)
        //      - pkscript (p2wpkh): 22 bytes
        P2WKHOutputSize = BaseOutputSize + P2WPKHSize

        // P2WSHOutputSize 43 bytes
        //      - value: 8 bytes
        //      - var_int: 1 byte (pkscript_length)
        //      - pkscript (p2wsh): 34 bytes
        P2WSHOutputSize = BaseOutputSize + P2WSHSize

        // P2SHSize 23 bytes.
        P2SHSize = 23

        // P2SHOutputSize 32 bytes
        //      - value: 8 bytes
        //      - var_int: 1 byte (pkscript_length)
        //      - pkscript (p2sh): 23 bytes
        P2SHOutputSize = BaseOutputSize + P2SHSize

        // P2TRSize 34 bytes
        //        - OP_0: 1 byte
        //        - OP_DATA: 1 byte (x-only public key length)
        //        - x-only public key length: 32 bytes
        P2TRSize = 34

        // P2TROutputSize 43 bytes
        //      - value: 8 bytes
        //      - var_int: 1 byte (pkscript_length)
        //      - pkscript (p2tr): 34 bytes
        P2TROutputSize = BaseOutputSize + P2TRSize

        // P2PKHScriptSigSize 108 bytes
        //      - OP_DATA: 1 byte (signature length)
        //      - signature
        //      - OP_DATA: 1 byte (pubkey length)
        //      - pubkey
        P2PKHScriptSigSize = 1 + 73 + 1 + 33

        // P2WKHWitnessSize 109 bytes
        //      - number_of_witness_elements: 1 byte
        //      - signature_length: 1 byte
        //      - signature
        //      - pubkey_length: 1 byte
        //      - pubkey
        P2WKHWitnessSize = 1 + 1 + 73 + 1 + 33

        // MultiSigSize 71 bytes
        //        - OP_2: 1 byte
        //        - OP_DATA: 1 byte (pubKeyAlice length)
        //        - pubKeyAlice: 33 bytes
        //        - OP_DATA: 1 byte (pubKeyBob length)
        //        - pubKeyBob: 33 bytes
        //        - OP_2: 1 byte
        //        - OP_CHECKMULTISIG: 1 byte
        MultiSigSize = 1 + 1 + 33 + 1 + 33 + 1 + 1

        // MultiSigWitnessSize 222 bytes
        //        - NumberOfWitnessElements: 1 byte
        //        - NilLength: 1 byte
        //        - sigAliceLength: 1 byte
        //        - sigAlice: 73 bytes
        //        - sigBobLength: 1 byte
        //        - sigBob: 73 bytes
        //        - WitnessScriptLength: 1 byte
        //        - WitnessScript (MultiSig)
        MultiSigWitnessSize = 1 + 1 + 1 + 73 + 1 + 73 + 1 + MultiSigSize

        // InputSize 41 bytes
        //        - PreviousOutPoint:
        //                - Hash: 32 bytes
        //                - Index: 4 bytes
        //        - OP_DATA: 1 byte (ScriptSigLength)
        //        - ScriptSig: 0 bytes
        //        - Witness &lt;----        we use "Witness" instead of "ScriptSig" for
        //                         transaction validation, but "Witness" is stored
        //                         separately and weight for it size is smaller. So
        //                         we separate the calculation of ordinary data
        //                         from witness data.
        //        - Sequence: 4 bytes
        InputSize = 32 + 4 + 1 + 4

        // FundingInputSize 41 bytes
        // FundingInputSize represents the size of an input to a funding
        // transaction, and is equivalent to the size of a standard segwit input
        // as calculated above.
        FundingInputSize = InputSize

        // CommitmentDelayOutput 43 bytes
        //        - Value: 8 bytes
        //        - VarInt: 1 byte (PkScript length)
        //        - PkScript (P2WSH)
        CommitmentDelayOutput = 8 + 1 + P2WSHSize

        // TaprootCommitmentOutput 43 bytes
        //        - Value: 8 bytes
        //        - VarInt: 1 byte (PkScript length)
        //        - PkScript (P2TR)
        TaprootCommitmentOutput = 8 + 1 + P2TRSize

        // CommitmentKeyHashOutput 31 bytes
        //        - Value: 8 bytes
        //        - VarInt: 1 byte (PkScript length)
        //        - PkScript (P2WPKH)
        CommitmentKeyHashOutput = 8 + 1 + P2WPKHSize

        // CommitmentAnchorOutput 43 bytes
        //        - Value: 8 bytes
        //        - VarInt: 1 byte (PkScript length)
        //        - PkScript (P2WSH)
        CommitmentAnchorOutput = 8 + 1 + P2WSHSize

        // TaprootCommitmentAnchorOutput 43 bytes
        //        - Value: 8 bytes
        //        - VarInt: 1 byte (PkScript length)
        //        - PkScript (P2TR)
        TaprootCommitmentAnchorOutput = 8 + 1 + P2TRSize

        // HTLCSize 43 bytes
        //        - Value: 8 bytes
        //        - VarInt: 1 byte (PkScript length)
        //        - PkScript (PW2SH)
        HTLCSize = 8 + 1 + P2WSHSize

        // WitnessHeaderSize 2 bytes
        //        - Flag: 1 byte
        //        - Marker: 1 byte
        WitnessHeaderSize = 1 + 1

        // BaseTxSize 8 bytes
        //      - Version: 4 bytes
        //      - LockTime: 4 bytes
        BaseTxSize = 4 + 4

        // BaseCommitmentTxSize 125 + 43 * num-htlc-outputs bytes
        //        - Version: 4 bytes
        //        - WitnessHeader &lt;---- part of the witness data
        //        - CountTxIn: 1 byte
        //        - TxIn: 41 bytes
        //                FundingInput
        //        - CountTxOut: 1 byte
        //        - TxOut: 74 + 43 * num-htlc-outputs bytes
        //                OutputPayingToThem,
        //                OutputPayingToUs,
        //                ....HTLCOutputs...
        //        - LockTime: 4 bytes
        BaseCommitmentTxSize = 4 + 1 + FundingInputSize + 1 +
                CommitmentDelayOutput + CommitmentKeyHashOutput + 4

        // BaseCommitmentTxWeight 500 weight
        BaseCommitmentTxWeight = witnessScaleFactor * BaseCommitmentTxSize

        // WitnessCommitmentTxWeight 224 weight
        WitnessCommitmentTxWeight = WitnessHeaderSize + MultiSigWitnessSize

        // BaseAnchorCommitmentTxSize 225 + 43 * num-htlc-outputs bytes
        //        - Version: 4 bytes
        //        - WitnessHeader &lt;---- part of the witness data
        //        - CountTxIn: 1 byte
        //        - TxIn: 41 bytes
        //                FundingInput
        //        - CountTxOut: 3 byte
        //        - TxOut: 4*43 + 43 * num-htlc-outputs bytes
        //                OutputPayingToThem,
        //                OutputPayingToUs,
        //                AnchorPayingToThem,
        //                AnchorPayingToUs,
        //                ....HTLCOutputs...
        //        - LockTime: 4 bytes
        BaseAnchorCommitmentTxSize = 4 + 1 + FundingInputSize + 3 +
                2*CommitmentDelayOutput + 2*CommitmentAnchorOutput + 4

        // BaseAnchorCommitmentTxWeight 900 weight.
        BaseAnchorCommitmentTxWeight = witnessScaleFactor * BaseAnchorCommitmentTxSize

        // BaseTaprootCommitmentTxWeight 225 + 43 * num-htlc-outputs bytes
        //        - Version: 4 bytes
        //        - WitnessHeader &lt;---- part of the witness data
        //        - CountTxIn: 1 byte
        //        - TxIn: 41 bytes
        //                FundingInput
        //        - CountTxOut: 3 byte
        //        - TxOut: 172 + 43 * num-htlc-outputs bytes
        //                OutputPayingToThem,
        //                OutputPayingToUs,
        //                ....HTLCOutputs...
        //        - LockTime: 4 bytes
        BaseTaprootCommitmentTxWeight = (4 + 1 + FundingInputSize + 3 +
                2*TaprootCommitmentOutput + 2*TaprootCommitmentAnchorOutput +
                4) * witnessScaleFactor

        // CommitWeight 724 weight.
        CommitWeight = BaseCommitmentTxWeight + WitnessCommitmentTxWeight

        // AnchorCommitWeight 1124 weight.
        AnchorCommitWeight = BaseAnchorCommitmentTxWeight + WitnessCommitmentTxWeight

        // TaprootCommitWeight 968 weight.
        TaprootCommitWeight = (BaseTaprootCommitmentTxWeight +
                WitnessHeaderSize + TaprootKeyPathWitnessSize)

        // HTLCWeight 172 weight.
        HTLCWeight = witnessScaleFactor * HTLCSize

        // HtlcTimeoutWeight 663 weight
        // HtlcTimeoutWeight is the weight of the HTLC timeout transaction
        // which will transition an outgoing HTLC to the delay-and-claim state.
        HtlcTimeoutWeight = 663

        // TaprootHtlcTimeoutWeight is the total weight of the taproot HTLC
        // timeout transaction.
        TaprootHtlcTimeoutWeight = 645

        // HtlcSuccessWeight 703 weight
        // HtlcSuccessWeight is the weight of the HTLC success transaction
        // which will transition an incoming HTLC to the delay-and-claim state.
        HtlcSuccessWeight = 703

        // TaprootHtlcSuccessWeight is the total weight of the taproot HTLC
        // success transaction.
        TaprootHtlcSuccessWeight = 705

        // HtlcConfirmedScriptOverhead 3 bytes
        // HtlcConfirmedScriptOverhead is the extra length of an HTLC script
        // that requires confirmation before it can be spent. These extra bytes
        // is a result of the extra CSV check.
        HtlcConfirmedScriptOverhead = 3

        // HtlcTimeoutWeightConfirmed 666 weight
        // HtlcTimeoutWeightConfirmed is the weight of the HTLC timeout
        // transaction which will transition an outgoing HTLC to the
        // delay-and-claim state, for the confirmed HTLC outputs. It is 3 bytes
        // larger because of the additional CSV check in the input script.
        HtlcTimeoutWeightConfirmed = HtlcTimeoutWeight + HtlcConfirmedScriptOverhead

        // HtlcSuccessWeightConfirmed 706 weight
        // HtlcSuccessWeightConfirmed is the weight of the HTLC success
        // transaction which will transition an incoming HTLC to the
        // delay-and-claim state, for the confirmed HTLC outputs. It is 3 bytes
        // larger because of the cdditional CSV check in the input script.
        HtlcSuccessWeightConfirmed = HtlcSuccessWeight + HtlcConfirmedScriptOverhead

        // MaxHTLCNumber 966
        // MaxHTLCNumber is the maximum number HTLCs which can be included in a
        // commitment transaction. This limit was chosen such that, in the case
        // of a contract breach, the punishment transaction is able to sweep
        // all the HTLC's yet still remain below the widely used standard
        // weight limits.
        MaxHTLCNumber = 966

        // ToLocalScriptSize 79 bytes
        //      - OP_IF: 1 byte
        //          - OP_DATA: 1 byte
        //          - revoke_key: 33 bytes
        //      - OP_ELSE: 1 byte
        //          - OP_DATA: 1 byte
        //          - csv_delay: 4 bytes
        //          - OP_CHECKSEQUENCEVERIFY: 1 byte
        //          - OP_DROP: 1 byte
        //          - OP_DATA: 1 byte
        //          - delay_key: 33 bytes
        //      - OP_ENDIF: 1 byte
        //      - OP_CHECKSIG: 1 byte
        ToLocalScriptSize = 1 + 1 + 33 + 1 + 1 + 4 + 1 + 1 + 1 + 33 + 1 + 1

        // LeaseWitnessScriptSizeOverhead represents the size overhead in bytes
        // of the witness scripts used within script enforced lease commitments.
        // This overhead results from the additional CLTV clause required to
        // spend.
        //
        //        - OP_DATA: 1 byte
        //         - lease_expiry: 4 bytes
        //         - OP_CHECKLOCKTIMEVERIFY: 1 byte
        //         - OP_DROP: 1 byte
        LeaseWitnessScriptSizeOverhead = 1 + 4 + 1 + 1

        // ToLocalTimeoutWitnessSize 156 bytes
        //      - number_of_witness_elements: 1 byte
        //      - local_delay_sig_length: 1 byte
        //      - local_delay_sig: 73 bytes
        //      - zero_length: 1 byte
        //      - witness_script_length: 1 byte
        //      - witness_script (to_local_script)
        ToLocalTimeoutWitnessSize = 1 + 1 + 73 + 1 + 1 + ToLocalScriptSize

        // ToLocalPenaltyWitnessSize 157 bytes
        //      - number_of_witness_elements: 1 byte
        //      - revocation_sig_length: 1 byte
        //      - revocation_sig: 73 bytes
        //      - OP_TRUE_length: 1 byte
        //      - OP_TRUE: 1 byte
        //      - witness_script_length: 1 byte
        //      - witness_script (to_local_script)
        ToLocalPenaltyWitnessSize = 1 + 1 + 73 + 1 + 1 + 1 + ToLocalScriptSize

        // ToRemoteConfirmedScriptSize 37 bytes
        //      - OP_DATA: 1 byte
        //      - to_remote_key: 33 bytes
        //      - OP_CHECKSIGVERIFY: 1 byte
        //      - OP_1: 1 byte
        //      - OP_CHECKSEQUENCEVERIFY: 1 byte
        ToRemoteConfirmedScriptSize = 1 + 33 + 1 + 1 + 1

        // ToRemoteConfirmedWitnessSize 113 bytes
        //      - number_of_witness_elements: 1 byte
        //      - sig_length: 1 byte
        //      - sig: 73 bytes
        //      - witness_script_length: 1 byte
        //      - witness_script (to_remote_delayed_script)
        ToRemoteConfirmedWitnessSize = 1 + 1 + 73 + 1 + ToRemoteConfirmedScriptSize

        // AcceptedHtlcScriptSize 140 bytes
        //      - OP_DUP: 1 byte
        //      - OP_HASH160: 1 byte
        //      - OP_DATA: 1 byte (RIPEMD160(SHA256(revocationkey)) length)
        //      - RIPEMD160(SHA256(revocationkey)): 20 bytes
        //      - OP_EQUAL: 1 byte
        //      - OP_IF: 1 byte
        //              - OP_CHECKSIG: 1 byte
        //      - OP_ELSE: 1 byte
        //              - OP_DATA: 1 byte (remotekey length)
        //              - remotekey: 33 bytes
        //              - OP_SWAP: 1 byte
        //              - OP_SIZE: 1 byte
        //              - OP_DATA: 1 byte (32 length)
        //              - 32: 1 byte
        //              - OP_EQUAL: 1 byte
        //              - OP_IF: 1 byte
        //                      - OP_HASH160: 1 byte
        //                      - OP_DATA: 1 byte (RIPEMD160(payment_hash) length)
        //                      - RIPEMD160(payment_hash): 20 bytes
        //                      - OP_EQUALVERIFY: 1 byte
        //                      - 2: 1 byte
        //                      - OP_SWAP: 1 byte
        //                      - OP_DATA: 1 byte (localkey length)
        //                      - localkey: 33 bytes
        //                      - 2: 1 byte
        //                      - OP_CHECKMULTISIG: 1 byte
        //              - OP_ELSE: 1 byte
        //                      - OP_DROP: 1 byte
        //                      - OP_DATA: 1 byte (cltv_expiry length)
        //                      - cltv_expiry: 4 bytes
        //                      - OP_CHECKLOCKTIMEVERIFY: 1 byte
        //                      - OP_DROP: 1 byte
        //                      - OP_CHECKSIG: 1 byte
        //              - OP_ENDIF: 1 byte
        //              - OP_1: 1 byte                // These 3 extra bytes are only
        //              - OP_CSV: 1 byte        // present for the confirmed
        //              - OP_DROP: 1 byte        // HTLC script types.
        //      - OP_ENDIF: 1 byte
        AcceptedHtlcScriptSize = 3*1 + 20 + 5*1 + 33 + 8*1 + 20 + 4*1 +
                33 + 5*1 + 4 + 5*1

        // AcceptedHtlcScriptSizeConfirmed 143 bytes.
        AcceptedHtlcScriptSizeConfirmed = AcceptedHtlcScriptSize +
                HtlcConfirmedScriptOverhead

        // AcceptedHtlcTimeoutWitnessSize 217 bytes
        //      - number_of_witness_elements: 1 byte
        //      - sender_sig_length: 1 byte
        //      - sender_sig: 73 bytes
        //      - nil_length: 1 byte
        //      - witness_script_length: 1 byte
        //      - witness_script: (accepted_htlc_script)
        AcceptedHtlcTimeoutWitnessSize = 1 + 1 + 73 + 1 + 1 + AcceptedHtlcScriptSize

        // AcceptedHtlcTimeoutWitnessSizeConfirmed 220 bytes.
        AcceptedHtlcTimeoutWitnessSizeConfirmed = 1 + 1 + 73 + 1 + 1 +
                AcceptedHtlcScriptSizeConfirmed

        // AcceptedHtlcPenaltyWitnessSize 250 bytes
        //      - number_of_witness_elements: 1 byte
        //      - revocation_sig_length: 1 byte
        //      - revocation_sig: 73 bytes
        //      - revocation_key_length: 1 byte
        //      - revocation_key: 33 bytes
        //      - witness_script_length: 1 byte
        //      - witness_script (accepted_htlc_script)
        AcceptedHtlcPenaltyWitnessSize = 1 + 1 + 73 + 1 + 33 + 1 + AcceptedHtlcScriptSize

        // AcceptedHtlcPenaltyWitnessSizeConfirmed 253 bytes.
        AcceptedHtlcPenaltyWitnessSizeConfirmed = 1 + 1 + 73 + 1 + 33 + 1 +
                AcceptedHtlcScriptSizeConfirmed

        // AcceptedHtlcSuccessWitnessSize 324 bytes
        //      - number_of_witness_elements: 1 byte
        //      - nil_length: 1 byte
        //      - sig_alice_length: 1 byte
        //      - sig_alice: 73 bytes
        //      - sig_bob_length: 1 byte
        //      - sig_bob: 73 bytes
        //      - preimage_length: 1 byte
        //      - preimage: 32 bytes
        //      - witness_script_length: 1 byte
        //      - witness_script (accepted_htlc_script)
        //
        // Input to second level success tx, spending non-delayed HTLC output.
        AcceptedHtlcSuccessWitnessSize = 1 + 1 + 1 + 73 + 1 + 73 + 1 + 32 + 1 +
                AcceptedHtlcScriptSize

        // AcceptedHtlcSuccessWitnessSizeConfirmed 327 bytes
        //
        // Input to second level success tx, spending 1 CSV delayed HTLC output.
        AcceptedHtlcSuccessWitnessSizeConfirmed = 1 + 1 + 1 + 73 + 1 + 73 + 1 + 32 + 1 +
                AcceptedHtlcScriptSizeConfirmed

        // OfferedHtlcScriptSize 133 bytes
        //      - OP_DUP: 1 byte
        //      - OP_HASH160: 1 byte
        //      - OP_DATA: 1 byte (RIPEMD160(SHA256(revocationkey)) length)
        //      - RIPEMD160(SHA256(revocationkey)): 20 bytes
        //      - OP_EQUAL: 1 byte
        //      - OP_IF: 1 byte
        //              - OP_CHECKSIG: 1 byte
        //      - OP_ELSE: 1 byte
        //              - OP_DATA: 1 byte (remotekey length)
        //              - remotekey: 33 bytes
        //              - OP_SWAP: 1 byte
        //              - OP_SIZE: 1 byte
        //              - OP_DATA: 1 byte (32 length)
        //              - 32: 1 byte
        //              - OP_EQUAL: 1 byte
        //              - OP_NOTIF: 1 byte
        //                      - OP_DROP: 1 byte
        //                      - 2: 1 byte
        //                      - OP_SWAP: 1 byte
        //                      - OP_DATA: 1 byte (localkey length)
        //                      - localkey: 33 bytes
        //                      - 2: 1 byte
        //                      - OP_CHECKMULTISIG: 1 byte
        //              - OP_ELSE: 1 byte
        //                      - OP_HASH160: 1 byte
        //                      - OP_DATA: 1 byte (RIPEMD160(payment_hash) length)
        //                      - RIPEMD160(payment_hash): 20 bytes
        //                      - OP_EQUALVERIFY: 1 byte
        //                      - OP_CHECKSIG: 1 byte
        //              - OP_ENDIF: 1 byte
        //              - OP_1: 1 byte                // These 3 extra bytes are only
        //              - OP_CSV: 1 byte        // present for the confirmed
        //              - OP_DROP: 1 byte        // HTLC script types.
        //      - OP_ENDIF: 1 byte
        OfferedHtlcScriptSize = 3*1 + 20 + 5*1 + 33 + 10*1 + 33 + 5*1 + 20 + 4*1

        // OfferedHtlcScriptSizeConfirmed 136 bytes.
        OfferedHtlcScriptSizeConfirmed = OfferedHtlcScriptSize +
                HtlcConfirmedScriptOverhead

        // OfferedHtlcSuccessWitnessSize 242 bytes
        //      - number_of_witness_elements: 1 byte
        //      - receiver_sig_length: 1 byte
        //      - receiver_sig: 73 bytes
        //      - payment_preimage_length: 1 byte
        //      - payment_preimage: 32 bytes
        //      - witness_script_length: 1 byte
        //      - witness_script (offered_htlc_script)
        OfferedHtlcSuccessWitnessSize = 1 + 1 + 73 + 1 + 32 + 1 + OfferedHtlcScriptSize

        // OfferedHtlcSuccessWitnessSizeConfirmed 245 bytes.
        OfferedHtlcSuccessWitnessSizeConfirmed = 1 + 1 + 73 + 1 + 32 + 1 +
                OfferedHtlcScriptSizeConfirmed

        // OfferedHtlcTimeoutWitnessSize 285 bytes
        //      - number_of_witness_elements: 1 byte
        //      - nil_length: 1 byte
        //      - sig_alice_length: 1 byte
        //      - sig_alice: 73 bytes
        //      - sig_bob_length: 1 byte
        //      - sig_bob: 73 bytes
        //      - nil_length: 1 byte
        //      - witness_script_length: 1 byte
        //      - witness_script (offered_htlc_script)
        //
        // Input to second level timeout tx, spending non-delayed HTLC output.
        OfferedHtlcTimeoutWitnessSize = 1 + 1 + 1 + 73 + 1 + 73 + 1 + 1 +
                OfferedHtlcScriptSize

        // OfferedHtlcTimeoutWitnessSizeConfirmed 288 bytes
        //
        // Input to second level timeout tx, spending 1 CSV delayed HTLC output.
        OfferedHtlcTimeoutWitnessSizeConfirmed = 1 + 1 + 1 + 73 + 1 + 73 + 1 + 1 +
                OfferedHtlcScriptSizeConfirmed

        // OfferedHtlcPenaltyWitnessSize 243 bytes
        //      - number_of_witness_elements: 1 byte
        //      - revocation_sig_length: 1 byte
        //      - revocation_sig: 73 bytes
        //      - revocation_key_length: 1 byte
        //      - revocation_key: 33 bytes
        //      - witness_script_length: 1 byte
        //      - witness_script (offered_htlc_script)
        OfferedHtlcPenaltyWitnessSize = 1 + 1 + 73 + 1 + 33 + 1 + OfferedHtlcScriptSize

        // OfferedHtlcPenaltyWitnessSizeConfirmed 246 bytes.
        OfferedHtlcPenaltyWitnessSizeConfirmed = 1 + 1 + 73 + 1 + 33 + 1 +
                OfferedHtlcScriptSizeConfirmed

        // AnchorScriptSize 40 bytes
        //      - pubkey_length: 1 byte
        //      - pubkey: 33 bytes
        //      - OP_CHECKSIG: 1 byte
        //      - OP_IFDUP: 1 byte
        //      - OP_NOTIF: 1 byte
        //              - OP_16: 1 byte
        //              - OP_CSV 1 byte
        //      - OP_ENDIF: 1 byte
        AnchorScriptSize = 1 + 33 + 6*1

        // AnchorWitnessSize 116 bytes
        //      - number_of_witnes_elements: 1 byte
        //      - signature_length: 1 byte
        //      - signature: 73 bytes
        //      - witness_script_length: 1 byte
        //      - witness_script (anchor_script)
        AnchorWitnessSize = 1 + 1 + 73 + 1 + AnchorScriptSize

        // TaprootSignatureWitnessSize 65 bytes
        //        - sigLength: 1 byte
        //        - sig: 64 bytes
        TaprootSignatureWitnessSize = 1 + 64

        // TaprootKeyPathWitnessSize 66 bytes
        //        - NumberOfWitnessElements: 1 byte
        //        - sigLength: 1 byte
        //        - sig: 64 bytes
        TaprootKeyPathWitnessSize = 1 + TaprootSignatureWitnessSize

        // TaprootKeyPathCustomSighashWitnessSize 67 bytes
        //        - NumberOfWitnessElements: 1 byte
        //        - sigLength: 1 byte
        //        - sig: 64 bytes
        //      - sighashFlag: 1 byte
        TaprootKeyPathCustomSighashWitnessSize = TaprootKeyPathWitnessSize + 1

        // TaprootBaseControlBlockWitnessSize 33 bytes
        //      - leafVersionAndParity: 1 byte
        //      - schnorrPubKey: 32 byte
        TaprootBaseControlBlockWitnessSize = 33

        // TaprootToLocalScriptSize
        //      - OP_DATA: 1 byte (pub key len)
        //      - local_key: 32 bytes
        //      - OP_CHECKSIG: 1 byte
        //      - OP_DATA: 1 byte (csv delay)
        //      - csv_delay: 4 bytes (worst case estimate)
        //      - OP_CSV: 1 byte
        //      - OP_DROP: 1 byte
        TaprootToLocalScriptSize = 41

        // TaprootToLocalWitnessSize: 175 bytes
        //      - number_of_witness_elements: 1 byte
        //      - sig_len: 1 byte
        //      - sweep_sig: 65 bytes (worst case w/o sighash default)
        //      - script_len: 1 byte
        //      - taproot_to_local_script_size: 41 bytes
        //      - ctrl_block_len: 1 byte
        //      - base_control_block_size: 33 bytes
        //      - sibling_merkle_hash: 32 bytes
        TaprootToLocalWitnessSize = 1 + 1 + 65 + 1 + TaprootToLocalScriptSize +
                1 + TaprootBaseControlBlockWitnessSize + 32

        // TaprootToLocalRevokeScriptSize: 68 bytes
        //        - OP_DATA: 1 byte
        //        - local key: 32 bytes
        //         - OP_DROP: 1 byte
        //         - OP_DATA: 1 byte
        //         - revocation key: 32 bytes
        //         - OP_CHECKSIG: 1 byte
        TaprootToLocalRevokeScriptSize = 1 + 32 + 1 + 1 + 32 + 1

        // TaprootToLocalRevokeWitnessSize: 202 bytes
        //         - NumberOfWitnessElements: 1 byte
        //         - sigLength: 1 byte
        //         - sweep sig: 65 bytes
        //         - script len: 1 byte
        //         - revocation script size: 68 bytes
        //         - ctrl block size: 1 byte
        //         - base control block: 33 bytes
        //        - merkle proof: 32
        TaprootToLocalRevokeWitnessSize = (1 + 1 + 65 + 1 +
                TaprootToLocalRevokeScriptSize + 1 + 33 + 32)

        // TaprootToRemoteScriptSize
        //         - OP_DATA: 1 byte
        //         - remote key: 32 bytes
        //         - OP_CHECKSIG: 1 byte
        //         - OP_1: 1 byte
        //         - OP_CHECKSEQUENCEVERIFY: 1 byte
        //         - OP_DROP: 1 byte
        TaprootToRemoteScriptSize = 1 + 32 + 1 + 1 + 1 + 1

        // TaprootToRemoteWitnessSize:
        //      - number_of_witness_elements: 1 byte
        //      - sig_len: 1 byte
        //      - sweep_sig: 65 bytes (worst case w/o sighash default)
        //      - script_len: 1 byte
        //      - taproot_to_local_script_size: 36 bytes
        //      - ctrl_block_len: 1 byte
        //      - base_control_block_size: 33 bytes
        TaprootToRemoteWitnessSize = (1 + 1 + 65 + 1 +
                TaprootToRemoteScriptSize + 1 +
                TaprootBaseControlBlockWitnessSize)

        // TaprootAnchorWitnessSize: 67 bytes
        //
        // In this case, we use the custom sighash size to give the most
        // pessemistic estimate.
        TaprootAnchorWitnessSize = TaprootKeyPathCustomSighashWitnessSize

        // TaprootSecondLevelHtlcScriptSize: 41 bytes
        //      - OP_DATA: 1 byte (pub key len)
        //      - local_key: 32 bytes
        //      - OP_CHECKSIG: 1 byte
        //      - OP_DATA: 1 byte (csv delay)
        //      - csv_delay: 4 bytes (worst case)
        //      - OP_CSV: 1 byte
        //      - OP_DROP: 1 byte
        TaprootSecondLevelHtlcScriptSize = 1 + 32 + 1 + 1 + 4 + 1 + 1

        // TaprootSecondLevelHtlcWitnessSize:
        //      - number_of_witness_elements: 1 byte
        //      - sig_len: 1 byte
        //      - sweep_sig: 65 bytes (worst case w/o sighash default)
        //      - script_len: 1 byte
        //      - taproot_second_level_htlc_script_size: 40 bytes
        //      - ctrl_block_len: 1 byte
        //      - base_control_block_size: 33 bytes
        TaprootSecondLevelHtlcWitnessSize = 1 + 1 + 65 + 1 +
                TaprootSecondLevelHtlcScriptSize + 1 +
                TaprootBaseControlBlockWitnessSize

        // TaprootSecondLevelRevokeWitnessSize
        //      - number_of_witness_elements: 1 byte
        //      - sig_len: 1 byte
        //      - sweep_sig: 65 bytes (worst case w/o sighash default)
        //nolint:ll
        TaprootSecondLevelRevokeWitnessSize = TaprootKeyPathCustomSighashWitnessSize

        // TaprootAcceptedRevokeWitnessSize:
        //      - number_of_witness_elements: 1 byte
        //      - sig_len: 1 byte
        //      - sweep_sig: 65 bytes (worst case w/o sighash default)
        //nolint:ll
        TaprootAcceptedRevokeWitnessSize = TaprootKeyPathCustomSighashWitnessSize

        // TaprootOfferedRevokeWitnessSize:
        //      - number_of_witness_elements: 1 byte
        //      - sig_len: 1 byte
        //      - sweep_sig: 65 bytes (worst case w/o sighash default)
        TaprootOfferedRevokeWitnessSize = TaprootKeyPathCustomSighashWitnessSize

        // TaprootHtlcOfferedRemoteTimeoutScriptSize: 42 bytes
        //        - OP_DATA: 1 byte (pub key len)
        //        - local_key: 32 bytes
        //        - OP_CHECKSIG: 1 byte
        //      - OP_1: 1 byte
        //      - OP_DROP: 1 byte
        //      - OP_CHECKSEQUENCEVERIFY: 1 byte
        //      - OP_DATA: 1 byte (cltv_expiry length)
        //      - cltv_expiry: 4 bytes
        //      - OP_CHECKLOCKTIMEVERIFY: 1 byte
        //      - OP_DROP: 1 byte
        TaprootHtlcOfferedRemoteTimeoutScriptSize = (1 + 32 + 1 + 1 + 1 + 1 +
                1 + 4 + 1 + 1)

        // TaprootHtlcOfferedRemoteTimeoutwitSize: 176 bytes
        //      - number_of_witness_elements: 1 byte
        //      - sig_len: 1 byte
        //      - sweep_sig: 65 bytes (worst case w/o sighash default)
        //      - script_len: 1 byte
        //      - taproot_offered_htlc_script_size: 42 bytes
        //      - ctrl_block_len: 1 byte
        //      - base_control_block_size: 33 bytes
        //      - sibilng_merkle_proof: 32 bytes
        TaprootHtlcOfferedRemoteTimeoutWitnessSize = 1 + 1 + 65 + 1 +
                TaprootHtlcOfferedRemoteTimeoutScriptSize + 1 +
                TaprootBaseControlBlockWitnessSize + 32

        // TaprootHtlcOfferedLocalTmeoutScriptSize:
        //        - OP_DATA: 1 byte (pub key len)
        //        - local_key: 32 bytes
        //        - OP_CHECKSIGVERIFY: 1 byte
        //        - OP_DATA: 1 byte (pub key len)
        //        - remote_key: 32 bytes
        //        - OP_CHECKSIG: 1 byte
        TaprootHtlcOfferedLocalTimeoutScriptSize = 1 + 32 + 1 + 1 + 32 + 1

        // TaprootOfferedLocalTimeoutWitnessSize
        //      - number_of_witness_elements: 1 byte
        //      - sig_len: 1 byte
        //      - sweep_sig: 65 bytes (worst case w/o sighash default)
        //      - sig_len: 1 byte
        //      - sweep_sig: 65 bytes (worst case w/o sighash default)
        //      - script_len: 1 byte
        //      - taproot_offered_htlc_script_timeout_size:
        //      - ctrl_block_len: 1 byte
        //      - base_control_block_size: 33 bytes
        //      - sibilng_merkle_proof: 32 bytes
        TaprootOfferedLocalTimeoutWitnessSize = 1 + 1 + 65 + 1 + 65 + 1 +
                TaprootHtlcOfferedLocalTimeoutScriptSize + 1 +
                TaprootBaseControlBlockWitnessSize + 32

        // TaprootHtlcAcceptedRemoteSuccessScriptSize:
        //      - OP_SIZE: 1 byte
        //      - OP_DATA: 1 byte
        //      - 32: 1 byte
        //      - OP_EQUALVERIFY: 1 byte
        //      - OP_HASH160: 1 byte
        //      - OP_DATA: 1 byte (RIPEMD160(payment_hash) length)
        //      - RIPEMD160(payment_hash): 20 bytes
        //      - OP_EQUALVERIFY: 1 byte
        //        - OP_DATA: 1 byte (pub key len)
        //        - remote_key: 32 bytes
        //        - OP_CHECKSIG: 1 byte
        //      - OP_1: 1 byte
        //      - OP_CSV: 1 byte
        //      - OP_DROP: 1 byte
        TaprootHtlcAcceptedRemoteSuccessScriptSize = 1 + 1 + 1 + 1 + 1 + 1 +
                1 + 20 + 1 + 32 + 1 + 1 + 1 + 1

        // TaprootHtlcAcceptedRemoteSuccessScriptSize:
        //      - number_of_witness_elements: 1 byte
        //      - sig_len: 1 byte
        //      - sweep_sig: 65 bytes (worst case w/o sighash default)
        //      - payment_preimage_length: 1 byte
        //      - payment_preimage: 32 bytes
        //      - script_len: 1 byte
        //      - taproot_offered_htlc_script_success_size:
        //      - ctrl_block_len: 1 byte
        //      - base_control_block_size: 33 bytes
        //      - sibilng_merkle_proof: 32 bytes
        TaprootHtlcAcceptedRemoteSuccessWitnessSize = 1 + 1 + 65 + 1 + 32 + 1 +
                TaprootHtlcAcceptedRemoteSuccessScriptSize + 1 +
                TaprootBaseControlBlockWitnessSize + 32

        // TaprootHtlcAcceptedLocalSuccessScriptSize:
        //      - OP_SIZE: 1 byte
        //      - OP_DATA: 1 byte
        //      - 32: 1 byte
        //      - OP_EQUALVERIFY: 1 byte
        //      - OP_HASH160: 1 byte
        //      - OP_DATA: 1 byte (RIPEMD160(payment_hash) length)
        //      - RIPEMD160(payment_hash): 20 bytes
        //      - OP_EQUALVERIFY: 1 byte
        //        - OP_DATA: 1 byte (pub key len)
        //        - local_key: 32 bytes
        //        - OP_CHECKSIGVERIFY: 1 byte
        //        - OP_DATA: 1 byte (pub key len)
        //        - remote_key: 32 bytes
        //        - OP_CHECKSIG: 1 byte
        TaprootHtlcAcceptedLocalSuccessScriptSize = 1 + 1 + 1 + 1 + 1 + 1 +
                20 + 1 + 1 + 32 + 1 + 1 + 32 + 1

        // TaprootHtlcAcceptedLocalSuccessWitnessSize:
        //      - number_of_witness_elements: 1 byte
        //      - sig_len: 1 byte
        //      - sweep_sig: 65 bytes (worst case w/o sighash default)
        //      - sig_len: 1 byte
        //      - sweep_sig: 65 bytes (worst case w/o sighash default)
        //      - payment_preimage_length: 1 byte
        //      - payment_preimage: 32 bytes
        //      - script_len: 1 byte
        //      - taproot_accepted_htlc_script_success_size:
        //      - ctrl_block_len: 1 byte
        //      - base_control_block_size: 33 bytes
        //      - sibilng_merkle_proof: 32 bytes
        TaprootHtlcAcceptedLocalSuccessWitnessSize = 1 + 1 + 65 + 1 + 65 + 1 +
                32 + 1 + TaprootHtlcAcceptedLocalSuccessScriptSize + 1 +
                TaprootBaseControlBlockWitnessSize + 32
)

// EstimateCommitTxWeight estimate commitment transaction weight depending on
// the precalculated weight of base transaction, witness data, which is needed
// for paying for funding tx, and htlc weight multiplied by their count.
func EstimateCommitTxWeight(count int, prediction bool) int64 <span class="cov0" title="0">{
        // Make prediction about the size of commitment transaction with
        // additional HTLC.
        if prediction </span><span class="cov0" title="0">{
                count++
        }</span>

        <span class="cov0" title="0">htlcWeight := int64(count * HTLCWeight)
        baseWeight := int64(BaseCommitmentTxWeight)
        witnessWeight := int64(WitnessCommitmentTxWeight)

        // TODO(roasbeef): need taproot modifier? also no anchor so wrong?

        return htlcWeight + baseWeight + witnessWeight</span>
}

// TxWeightEstimator is able to calculate weight estimates for transactions
// based on the input and output types. For purposes of estimation, all
// signatures are assumed to be of the maximum possible size, 73 bytes. Each
// method of the estimator returns an instance with the estimate applied. This
// allows callers to chain each of the methods
type TxWeightEstimator struct {
        hasWitness       bool
        inputCount       uint32
        outputCount      uint32
        inputSize        lntypes.VByte
        inputWitnessSize lntypes.WeightUnit
        outputSize       lntypes.VByte
}

// AddP2PKHInput updates the weight estimate to account for an additional input
// spending a P2PKH output.
func (twe *TxWeightEstimator) AddP2PKHInput() *TxWeightEstimator <span class="cov0" title="0">{
        twe.inputSize += InputSize + P2PKHScriptSigSize
        twe.inputWitnessSize++
        twe.inputCount++

        return twe
}</span>

// AddP2WKHInput updates the weight estimate to account for an additional input
// spending a native P2PWKH output.
func (twe *TxWeightEstimator) AddP2WKHInput() *TxWeightEstimator <span class="cov0" title="0">{
        twe.AddWitnessInput(P2WKHWitnessSize)

        return twe
}</span>

// AddWitnessInput updates the weight estimate to account for an additional
// input spending a native pay-to-witness output. This accepts the total size
// of the witness as a parameter.
func (twe *TxWeightEstimator) AddWitnessInput(
        witnessSize lntypes.WeightUnit) *TxWeightEstimator <span class="cov0" title="0">{

        twe.inputSize += InputSize
        twe.inputWitnessSize += witnessSize
        twe.inputCount++
        twe.hasWitness = true

        return twe
}</span>

// AddTapscriptInput updates the weight estimate to account for an additional
// input spending a segwit v1 pay-to-taproot output using the script path. This
// accepts the total size of the witness for the script leaf that is executed
// and adds the size of the control block to the total witness size.
//
// NOTE: The leaf witness size must be calculated without the byte that accounts
// for the number of witness elements, only the total size of all elements on
// the stack that are consumed by the revealed script should be counted.
func (twe *TxWeightEstimator) AddTapscriptInput(
        leafWitnessSize lntypes.WeightUnit,
        tapscript *waddrmgr.Tapscript) *TxWeightEstimator <span class="cov0" title="0">{

        // We add 1 byte for the total number of witness elements.
        controlBlockWitnessSize := 1 + TaprootBaseControlBlockWitnessSize +
                // 1 byte for the length of the element plus the element itself.
                1 + len(tapscript.RevealedScript) +
                1 + len(tapscript.ControlBlock.InclusionProof)

        twe.inputSize += InputSize
        twe.inputWitnessSize += leafWitnessSize + lntypes.WeightUnit(
                controlBlockWitnessSize,
        )
        twe.inputCount++
        twe.hasWitness = true

        return twe
}</span>

// AddTaprootKeySpendInput updates the weight estimate to account for an
// additional input spending a segwit v1 pay-to-taproot output using the key
// spend path. This accepts the sighash type being used since that has an
// influence on the total size of the signature.
func (twe *TxWeightEstimator) AddTaprootKeySpendInput(
        hashType txscript.SigHashType) *TxWeightEstimator <span class="cov0" title="0">{

        twe.inputSize += InputSize

        if hashType == txscript.SigHashDefault </span><span class="cov0" title="0">{
                twe.inputWitnessSize += TaprootKeyPathWitnessSize
        }</span> else<span class="cov0" title="0"> {
                twe.inputWitnessSize += TaprootKeyPathCustomSighashWitnessSize
        }</span>

        <span class="cov0" title="0">twe.inputCount++
        twe.hasWitness = true

        return twe</span>
}

// AddNestedP2WKHInput updates the weight estimate to account for an additional
// input spending a P2SH output with a nested P2WKH redeem script.
func (twe *TxWeightEstimator) AddNestedP2WKHInput() *TxWeightEstimator <span class="cov0" title="0">{
        twe.inputSize += InputSize + NestedP2WPKHSize
        twe.inputWitnessSize += P2WKHWitnessSize
        twe.inputCount++
        twe.hasWitness = true

        return twe
}</span>

// AddNestedP2WSHInput updates the weight estimate to account for an additional
// input spending a P2SH output with a nested P2WSH redeem script.
func (twe *TxWeightEstimator) AddNestedP2WSHInput(
        witnessSize lntypes.WeightUnit) *TxWeightEstimator <span class="cov0" title="0">{

        twe.inputSize += InputSize + NestedP2WSHSize
        twe.inputWitnessSize += witnessSize
        twe.inputCount++
        twe.hasWitness = true

        return twe
}</span>

// AddTxOutput adds a known TxOut to the weight estimator.
func (twe *TxWeightEstimator) AddTxOutput(txOut *wire.TxOut) *TxWeightEstimator <span class="cov0" title="0">{
        twe.outputSize += lntypes.VByte(txOut.SerializeSize())
        twe.outputCount++

        return twe
}</span>

// AddP2PKHOutput updates the weight estimate to account for an additional P2PKH
// output.
func (twe *TxWeightEstimator) AddP2PKHOutput() *TxWeightEstimator <span class="cov0" title="0">{
        twe.outputSize += P2PKHOutputSize
        twe.outputCount++

        return twe
}</span>

// AddP2WKHOutput updates the weight estimate to account for an additional
// native P2WKH output.
func (twe *TxWeightEstimator) AddP2WKHOutput() *TxWeightEstimator <span class="cov0" title="0">{
        twe.outputSize += P2WKHOutputSize
        twe.outputCount++

        return twe
}</span>

// AddP2WSHOutput updates the weight estimate to account for an additional
// native P2WSH output.
func (twe *TxWeightEstimator) AddP2WSHOutput() *TxWeightEstimator <span class="cov0" title="0">{
        twe.outputSize += P2WSHOutputSize
        twe.outputCount++

        return twe
}</span>

// AddP2TROutput updates the weight estimate to account for an additional native
// SegWit v1 P2TR output.
func (twe *TxWeightEstimator) AddP2TROutput() *TxWeightEstimator <span class="cov0" title="0">{
        twe.outputSize += P2TROutputSize
        twe.outputCount++

        return twe
}</span>

// AddP2SHOutput updates the weight estimate to account for an additional P2SH
// output.
func (twe *TxWeightEstimator) AddP2SHOutput() *TxWeightEstimator <span class="cov0" title="0">{
        twe.outputSize += P2SHOutputSize
        twe.outputCount++

        return twe
}</span>

// AddOutput estimates the weight of an output based on the pkScript.
func (twe *TxWeightEstimator) AddOutput(pkScript []byte) *TxWeightEstimator <span class="cov0" title="0">{
        twe.outputSize += BaseOutputSize + lntypes.VByte(len(pkScript))
        twe.outputCount++

        return twe
}</span>

// Weight gets the estimated weight of the transaction.
func (twe *TxWeightEstimator) Weight() lntypes.WeightUnit <span class="cov0" title="0">{
        inputCount := wire.VarIntSerializeSize(uint64(twe.inputCount))
        outputCount := wire.VarIntSerializeSize(uint64(twe.outputCount))
        txSizeStripped := BaseTxSize + lntypes.VByte(inputCount) +
                twe.inputSize + lntypes.VByte(outputCount) + twe.outputSize
        weight := lntypes.WeightUnit(txSizeStripped * witnessScaleFactor)

        if twe.hasWitness </span><span class="cov0" title="0">{
                weight += WitnessHeaderSize + twe.inputWitnessSize
        }</span>
        <span class="cov0" title="0">return weight</span>
}

// VSize gets the estimated virtual size of the transactions, in vbytes.
func (twe *TxWeightEstimator) VSize() int <span class="cov0" title="0">{
        // A tx's vsize is 1/4 of the weight, rounded up.
        return int(twe.Weight().ToVB())
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package input

import (
        "fmt"

        "github.com/btcsuite/btcd/btcec/v2"
        "github.com/btcsuite/btcd/btcec/v2/schnorr"
        "github.com/btcsuite/btcd/txscript"
        "github.com/btcsuite/btcd/wire"
        "github.com/btcsuite/btcwallet/waddrmgr"
        "github.com/lightningnetwork/lnd/fn/v2"
)

const (
        // PubKeyFormatCompressedOdd is the identifier prefix byte for a public
        // key whose Y coordinate is odd when serialized in the compressed
        // format per section 2.3.4 of
        // [SEC1](https://secg.org/sec1-v2.pdf#subsubsection.2.3.4).
        // This is copied from the github.com/decred/dcrd/dcrec/secp256k1/v4 to
        // avoid needing to directly reference (and by accident pull in
        // incompatible crypto primitives) the package.
        PubKeyFormatCompressedOdd byte = 0x03
)

// AuxTapLeaf is a type alias for an optional tapscript leaf that may be added
// to the tapscript tree of HTLC and commitment outputs.
type AuxTapLeaf = fn.Option[txscript.TapLeaf]

// NoneTapLeaf returns an empty optional tapscript leaf.
func NoneTapLeaf() AuxTapLeaf <span class="cov0" title="0">{
        return fn.None[txscript.TapLeaf]()
}</span>

// HtlcIndex represents the monotonically increasing counter that is used to
// identify HTLCs created by a peer.
type HtlcIndex = uint64

// HtlcAuxLeaf is a type that represents an auxiliary leaf for an HTLC output.
// An HTLC may have up to two aux leaves: one for the output on the commitment
// transaction, and one for the second level HTLC.
type HtlcAuxLeaf struct {
        AuxTapLeaf

        // SecondLevelLeaf is the auxiliary leaf for the second level HTLC
        // success or timeout transaction.
        SecondLevelLeaf AuxTapLeaf
}

// HtlcAuxLeaves is a type alias for a map of optional tapscript leaves.
type HtlcAuxLeaves = map[HtlcIndex]HtlcAuxLeaf

// NewTxSigHashesV0Only returns a new txscript.TxSigHashes instance that will
// only calculate the sighash midstate values for segwit v0 inputs and can
// therefore never be used for transactions that want to spend segwit v1
// (taproot) inputs.
func NewTxSigHashesV0Only(tx *wire.MsgTx) *txscript.TxSigHashes <span class="cov0" title="0">{
        // The canned output fetcher returns a wire.TxOut instance with the
        // given pk script and amount. We can get away with nil since the first
        // thing the TxSigHashes constructor checks is the length of the pk
        // script and whether it matches taproot output script length. If the
        // length doesn't match it assumes v0 inputs only.
        nilFetcher := txscript.NewCannedPrevOutputFetcher(nil, 0)
        return txscript.NewTxSigHashes(tx, nilFetcher)
}</span>

// MultiPrevOutFetcher returns a txscript.MultiPrevOutFetcher for the given set
// of inputs.
func MultiPrevOutFetcher(inputs []Input) (*txscript.MultiPrevOutFetcher, error) <span class="cov0" title="0">{
        fetcher := txscript.NewMultiPrevOutFetcher(nil)
        for _, inp := range inputs </span><span class="cov0" title="0">{
                op := inp.OutPoint()
                desc := inp.SignDesc()

                if op == EmptyOutPoint </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("missing input outpoint")
                }</span>

                <span class="cov0" title="0">if desc == nil || desc.Output == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("missing input utxo information")
                }</span>

                <span class="cov0" title="0">fetcher.AddPrevOut(op, desc.Output)</span>
        }

        <span class="cov0" title="0">return fetcher, nil</span>
}

// TapscriptFullTree creates a waddrmgr.Tapscript for the given internal key and
// tree leaves.
func TapscriptFullTree(internalKey *btcec.PublicKey,
        allTreeLeaves ...txscript.TapLeaf) *waddrmgr.Tapscript <span class="cov0" title="0">{

        tree := txscript.AssembleTaprootScriptTree(allTreeLeaves...)
        rootHash := tree.RootNode.TapHash()
        tapKey := txscript.ComputeTaprootOutputKey(internalKey, rootHash[:])

        var outputKeyYIsOdd bool
        if tapKey.SerializeCompressed()[0] == PubKeyFormatCompressedOdd </span><span class="cov0" title="0">{
                outputKeyYIsOdd = true
        }</span>

        <span class="cov0" title="0">return &amp;waddrmgr.Tapscript{
                Type: waddrmgr.TapscriptTypeFullTree,
                ControlBlock: &amp;txscript.ControlBlock{
                        InternalKey:     internalKey,
                        OutputKeyYIsOdd: outputKeyYIsOdd,
                        LeafVersion:     txscript.BaseLeafVersion,
                },
                Leaves: allTreeLeaves,
        }</span>
}

// TapscriptPartialReveal creates a waddrmgr.Tapscript for the given internal
// key and revealed script.
func TapscriptPartialReveal(internalKey *btcec.PublicKey,
        revealedLeaf txscript.TapLeaf,
        inclusionProof []byte) *waddrmgr.Tapscript <span class="cov0" title="0">{

        controlBlock := &amp;txscript.ControlBlock{
                InternalKey:    internalKey,
                LeafVersion:    txscript.BaseLeafVersion,
                InclusionProof: inclusionProof,
        }
        rootHash := controlBlock.RootHash(revealedLeaf.Script)
        tapKey := txscript.ComputeTaprootOutputKey(internalKey, rootHash)

        if tapKey.SerializeCompressed()[0] == PubKeyFormatCompressedOdd </span><span class="cov0" title="0">{
                controlBlock.OutputKeyYIsOdd = true
        }</span>

        <span class="cov0" title="0">return &amp;waddrmgr.Tapscript{
                Type:           waddrmgr.TapscriptTypePartialReveal,
                ControlBlock:   controlBlock,
                RevealedScript: revealedLeaf.Script,
        }</span>
}

// TapscriptRootHashOnly creates a waddrmgr.Tapscript for the given internal key
// and root hash.
func TapscriptRootHashOnly(internalKey *btcec.PublicKey,
        rootHash []byte) *waddrmgr.Tapscript <span class="cov0" title="0">{

        controlBlock := &amp;txscript.ControlBlock{
                InternalKey: internalKey,
        }

        tapKey := txscript.ComputeTaprootOutputKey(internalKey, rootHash)
        if tapKey.SerializeCompressed()[0] == PubKeyFormatCompressedOdd </span><span class="cov0" title="0">{
                controlBlock.OutputKeyYIsOdd = true
        }</span>

        <span class="cov0" title="0">return &amp;waddrmgr.Tapscript{
                Type:         waddrmgr.TaprootKeySpendRootHash,
                ControlBlock: controlBlock,
                RootHash:     rootHash,
        }</span>
}

// TapscriptFullKeyOnly creates a waddrmgr.Tapscript for the given full Taproot
// key.
func TapscriptFullKeyOnly(taprootKey *btcec.PublicKey) *waddrmgr.Tapscript <span class="cov0" title="0">{
        return &amp;waddrmgr.Tapscript{
                Type:          waddrmgr.TaprootFullKeyOnly,
                FullOutputKey: taprootKey,
        }
}</span>

// PayToTaprootScript creates a new script to pay to a version 1 (taproot)
// witness program. The passed public key will be serialized as an x-only key
// to create the witness program.
func PayToTaprootScript(taprootKey *btcec.PublicKey) ([]byte, error) <span class="cov0" title="0">{
        builder := txscript.NewScriptBuilder()

        builder.AddOp(txscript.OP_1)
        builder.AddData(schnorr.SerializePubKey(taprootKey))

        return builder.Script()
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package input

import (
        "bytes"
        "encoding/hex"
        "fmt"

        "github.com/btcsuite/btcd/btcec/v2"
        "github.com/btcsuite/btcd/btcec/v2/ecdsa"
        "github.com/btcsuite/btcd/btcec/v2/schnorr"
        "github.com/btcsuite/btcd/btcutil"
        "github.com/btcsuite/btcd/chaincfg"
        "github.com/btcsuite/btcd/chaincfg/chainhash"
        "github.com/btcsuite/btcd/txscript"
        "github.com/btcsuite/btcd/wire"
        "github.com/lightningnetwork/lnd/keychain"
)

var (

        // For simplicity a single priv key controls all of our test outputs.
        testWalletPrivKey = []byte{
                0x2b, 0xd8, 0x06, 0xc9, 0x7f, 0x0e, 0x00, 0xaf,
                0x1a, 0x1f, 0xc3, 0x32, 0x8f, 0xa7, 0x63, 0xa9,
                0x26, 0x97, 0x23, 0xc8, 0xdb, 0x8f, 0xac, 0x4f,
                0x93, 0xaf, 0x71, 0xdb, 0x18, 0x6d, 0x6e, 0x90,
        }

        // We're alice :)
        bobsPrivKey = []byte{
                0x81, 0xb6, 0x37, 0xd8, 0xfc, 0xd2, 0xc6, 0xda,
                0x63, 0x59, 0xe6, 0x96, 0x31, 0x13, 0xa1, 0x17,
                0xd, 0xe7, 0x95, 0xe4, 0xb7, 0x25, 0xb8, 0x4d,
                0x1e, 0xb, 0x4c, 0xfd, 0x9e, 0xc5, 0x8c, 0xe9,
        }

        // Use a hard-coded HD seed.
        testHdSeed = chainhash.Hash{
                0xb7, 0x94, 0x38, 0x5f, 0x2d, 0x1e, 0xf7, 0xab,
                0x4d, 0x92, 0x73, 0xd1, 0x90, 0x63, 0x81, 0xb4,
                0x4f, 0x2f, 0x6f, 0x25, 0x88, 0xa3, 0xef, 0xb9,
                0x6a, 0x49, 0x18, 0x83, 0x31, 0x98, 0x47, 0x53,
        }
)

// MockSigner is a simple implementation of the Signer interface. Each one has
// a set of private keys in a slice and can sign messages using the appropriate
// one.
type MockSigner struct {
        Privkeys  []*btcec.PrivateKey
        NetParams *chaincfg.Params

        *MusigSessionManager
}

// NewMockSigner returns a new instance of the MockSigner given a set of
// backing private keys.
func NewMockSigner(privKeys []*btcec.PrivateKey,
        netParams *chaincfg.Params) *MockSigner <span class="cov0" title="0">{

        signer := &amp;MockSigner{
                Privkeys:  privKeys,
                NetParams: netParams,
        }

        keyFetcher := func(*keychain.KeyDescriptor) (*btcec.PrivateKey, error) </span><span class="cov0" title="0">{
                return signer.Privkeys[0], nil
        }</span>
        <span class="cov0" title="0">signer.MusigSessionManager = NewMusigSessionManager(keyFetcher)

        return signer</span>
}

// SignOutputRaw generates a signature for the passed transaction according to
// the data within the passed SignDescriptor.
func (m *MockSigner) SignOutputRaw(tx *wire.MsgTx,
        signDesc *SignDescriptor) (Signature, error) <span class="cov0" title="0">{

        pubkey := signDesc.KeyDesc.PubKey
        switch </span>{
        case signDesc.SingleTweak != nil:<span class="cov0" title="0">
                pubkey = TweakPubKeyWithTweak(pubkey, signDesc.SingleTweak)</span>
        case signDesc.DoubleTweak != nil:<span class="cov0" title="0">
                pubkey = DeriveRevocationPubkey(pubkey, signDesc.DoubleTweak.PubKey())</span>
        }

        <span class="cov0" title="0">hash160 := btcutil.Hash160(pubkey.SerializeCompressed())
        privKey := m.findKey(hash160, signDesc.SingleTweak, signDesc.DoubleTweak)
        if privKey == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("mock signer does not have key")
        }</span>

        // In case of a taproot output any signature is always a Schnorr
        // signature, based on the new tapscript sighash algorithm.
        <span class="cov0" title="0">if txscript.IsPayToTaproot(signDesc.Output.PkScript) </span><span class="cov0" title="0">{
                sigHashes := txscript.NewTxSigHashes(
                        tx, signDesc.PrevOutputFetcher,
                )

                // Are we spending a script path or the key path? The API is
                // slightly different, so we need to account for that to get
                // the raw signature.
                var (
                        rawSig []byte
                        err    error
                )
                switch signDesc.SignMethod </span>{
                case TaprootKeySpendBIP0086SignMethod,
                        TaprootKeySpendSignMethod:<span class="cov0" title="0">

                        // This function tweaks the private key using the tap
                        // root key supplied as the tweak.
                        rawSig, err = txscript.RawTxInTaprootSignature(
                                tx, sigHashes, signDesc.InputIndex,
                                signDesc.Output.Value, signDesc.Output.PkScript,
                                signDesc.TapTweak, signDesc.HashType,
                                privKey,
                        )
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                case TaprootScriptSpendSignMethod:<span class="cov0" title="0">
                        leaf := txscript.TapLeaf{
                                LeafVersion: txscript.BaseLeafVersion,
                                Script:      signDesc.WitnessScript,
                        }
                        rawSig, err = txscript.RawTxInTapscriptSignature(
                                tx, sigHashes, signDesc.InputIndex,
                                signDesc.Output.Value, signDesc.Output.PkScript,
                                leaf, signDesc.HashType, privKey,
                        )
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }

                // The signature returned above might have a sighash flag
                // attached if a non-default type was used. We'll slice this
                // off if it exists to ensure we can properly parse the raw
                // signature.
                <span class="cov0" title="0">sig, err := schnorr.ParseSignature(
                        rawSig[:schnorr.SignatureSize],
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">return sig, nil</span>
        }

        <span class="cov0" title="0">sig, err := txscript.RawTxInWitnessSignature(
                tx, signDesc.SigHashes, signDesc.InputIndex,
                signDesc.Output.Value, signDesc.WitnessScript,
                signDesc.HashType, privKey,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return ecdsa.ParseDERSignature(sig[:len(sig)-1])</span>
}

// ComputeInputScript generates a complete InputIndex for the passed transaction
// with the signature as defined within the passed SignDescriptor. This method
// should be capable of generating the proper input script for both regular
// p2wkh output and p2wkh outputs nested within a regular p2sh output.
func (m *MockSigner) ComputeInputScript(tx *wire.MsgTx, signDesc *SignDescriptor) (*Script, error) <span class="cov0" title="0">{
        scriptType, addresses, _, err := txscript.ExtractPkScriptAddrs(
                signDesc.Output.PkScript, m.NetParams)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">switch scriptType </span>{
        case txscript.PubKeyHashTy:<span class="cov0" title="0">
                privKey := m.findKey(addresses[0].ScriptAddress(), signDesc.SingleTweak,
                        signDesc.DoubleTweak)
                if privKey == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("mock signer does not have key for "+
                                "address %v", addresses[0])
                }</span>

                <span class="cov0" title="0">sigScript, err := txscript.SignatureScript(
                        tx, signDesc.InputIndex, signDesc.Output.PkScript,
                        txscript.SigHashAll, privKey, true,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">return &amp;Script{SigScript: sigScript}, nil</span>

        case txscript.WitnessV0PubKeyHashTy:<span class="cov0" title="0">
                privKey := m.findKey(addresses[0].ScriptAddress(), signDesc.SingleTweak,
                        signDesc.DoubleTweak)
                if privKey == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("mock signer does not have key for "+
                                "address %v", addresses[0])
                }</span>

                <span class="cov0" title="0">witnessScript, err := txscript.WitnessSignature(tx, signDesc.SigHashes,
                        signDesc.InputIndex, signDesc.Output.Value,
                        signDesc.Output.PkScript, txscript.SigHashAll, privKey, true)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">return &amp;Script{Witness: witnessScript}, nil</span>

        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unexpected script type: %v", scriptType)</span>
        }
}

// findKey searches through all stored private keys and returns one
// corresponding to the hashed pubkey if it can be found. The public key may
// either correspond directly to the private key or to the private key with a
// tweak applied.
func (m *MockSigner) findKey(needleHash160 []byte, singleTweak []byte,
        doubleTweak *btcec.PrivateKey) *btcec.PrivateKey <span class="cov0" title="0">{

        for _, privkey := range m.Privkeys </span><span class="cov0" title="0">{
                // First check whether public key is directly derived from
                // private key.
                hash160 := btcutil.Hash160(privkey.PubKey().SerializeCompressed())
                if bytes.Equal(hash160, needleHash160) </span><span class="cov0" title="0">{
                        return privkey
                }</span>

                // Otherwise check if public key is derived from tweaked
                // private key.
                <span class="cov0" title="0">switch </span>{
                case singleTweak != nil:<span class="cov0" title="0">
                        privkey = TweakPrivKey(privkey, singleTweak)</span>
                case doubleTweak != nil:<span class="cov0" title="0">
                        privkey = DeriveRevocationPrivKey(privkey, doubleTweak)</span>
                default:<span class="cov0" title="0">
                        continue</span>
                }
                <span class="cov0" title="0">hash160 = btcutil.Hash160(privkey.PubKey().SerializeCompressed())
                if bytes.Equal(hash160, needleHash160) </span><span class="cov0" title="0">{
                        return privkey
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// pubkeyFromHex parses a Bitcoin public key from a hex encoded string.
func pubkeyFromHex(keyHex string) (*btcec.PublicKey, error) <span class="cov0" title="0">{
        bytes, err := hex.DecodeString(keyHex)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return btcec.ParsePubKey(bytes)</span>
}

// privkeyFromHex parses a Bitcoin private key from a hex encoded string.
func privkeyFromHex(keyHex string) (*btcec.PrivateKey, error) <span class="cov0" title="0">{
        bytes, err := hex.DecodeString(keyHex)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">key, _ := btcec.PrivKeyFromBytes(bytes)
        return key, nil</span>

}

// pubkeyToHex serializes a Bitcoin public key to a hex encoded string.
func pubkeyToHex(key *btcec.PublicKey) string <span class="cov0" title="0">{
        return hex.EncodeToString(key.SerializeCompressed())
}</span>

// privkeyFromHex serializes a Bitcoin private key to a hex encoded string.
func privkeyToHex(key *btcec.PrivateKey) string <span class="cov0" title="0">{
        return hex.EncodeToString(key.Serialize())
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package input

import (
        "encoding/binary"
        "io"

        "github.com/btcsuite/btcd/wire"
)

// writeTxOut serializes a wire.TxOut struct into the passed io.Writer stream.
func writeTxOut(w io.Writer, txo *wire.TxOut) error <span class="cov0" title="0">{
        var scratch [8]byte

        binary.BigEndian.PutUint64(scratch[:], uint64(txo.Value))
        if _, err := w.Write(scratch[:]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := wire.WriteVarBytes(w, 0, txo.PkScript); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// readTxOut deserializes a wire.TxOut struct from the passed io.Reader stream.
func readTxOut(r io.Reader, txo *wire.TxOut) error <span class="cov0" title="0">{
        var scratch [8]byte

        if _, err := io.ReadFull(r, scratch[:]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">value := int64(binary.BigEndian.Uint64(scratch[:]))

        pkScript, err := wire.ReadVarBytes(r, 0, 80, "pkScript")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">*txo = wire.TxOut{
                Value:    value,
                PkScript: pkScript,
        }

        return nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package input

import (
        "fmt"

        "github.com/btcsuite/btcd/txscript"
        "github.com/btcsuite/btcd/wire"
        "github.com/lightningnetwork/lnd/lntypes"
)

// WitnessGenerator represents a function that is able to generate the final
// witness for a particular public key script. Additionally, if required, this
// function will also return the sigScript for spending nested P2SH witness
// outputs. This function acts as an abstraction layer, hiding the details of
// the underlying script.
type WitnessGenerator func(tx *wire.MsgTx, hc *txscript.TxSigHashes,
        inputIndex int) (*Script, error)

// WitnessType determines how an output's witness will be generated. This
// interface can be implemented to be used for custom sweep scripts if the
// pre-defined StandardWitnessType list doesn't provide a suitable one.
type WitnessType interface {
        // String returns a human readable version of the WitnessType.
        String() string

        // WitnessGenerator will return a WitnessGenerator function that an
        // output uses to generate the witness and optionally the sigScript for
        // a sweep transaction.
        WitnessGenerator(signer Signer,
                descriptor *SignDescriptor) WitnessGenerator

        // SizeUpperBound returns the maximum length of the witness of this
        // WitnessType if it would be included in a tx. It also returns if the
        // output itself is a nested p2sh output, if so then we need to take
        // into account the extra sigScript data size.
        SizeUpperBound() (lntypes.WeightUnit, bool, error)

        // AddWeightEstimation adds the estimated size of the witness in bytes
        // to the given weight estimator.
        AddWeightEstimation(e *TxWeightEstimator) error
}

// StandardWitnessType is a numeric representation of standard pre-defined types
// of witness configurations.
type StandardWitnessType uint16

// A compile time check to ensure StandardWitnessType implements the
// WitnessType interface.
var _ WitnessType = (StandardWitnessType)(0)

// NOTE: When adding a new `StandardWitnessType`, also update the `WitnessType`
// protobuf enum and the `allWitnessTypes` map in the `walletrpc` package.
const (
        // CommitmentTimeLock is a witness that allows us to spend our output
        // on our local commitment transaction after a relative lock-time
        // lockout.
        CommitmentTimeLock StandardWitnessType = 0

        // CommitmentNoDelay is a witness that allows us to spend a settled
        // no-delay output immediately on a counterparty's commitment
        // transaction.
        CommitmentNoDelay StandardWitnessType = 1

        // CommitmentRevoke is a witness that allows us to sweep the settled
        // output of a malicious counterparty's who broadcasts a revoked
        // commitment transaction.
        CommitmentRevoke StandardWitnessType = 2

        // HtlcOfferedRevoke is a witness that allows us to sweep an HTLC which
        // we offered to the remote party in the case that they broadcast a
        // revoked commitment state.
        HtlcOfferedRevoke StandardWitnessType = 3

        // HtlcAcceptedRevoke is a witness that allows us to sweep an HTLC
        // output sent to us in the case that the remote party broadcasts a
        // revoked commitment state.
        HtlcAcceptedRevoke StandardWitnessType = 4

        // HtlcOfferedTimeoutSecondLevel is a witness that allows us to sweep
        // an HTLC output that we extended to a party, but was never fulfilled.
        // This HTLC output isn't directly on the commitment transaction, but
        // is the result of a confirmed second-level HTLC transaction. As a
        // result, we can only spend this after a CSV delay.
        HtlcOfferedTimeoutSecondLevel StandardWitnessType = 5

        // HtlcOfferedTimeoutSecondLevelInputConfirmed is a witness that allows
        // us to sweep an HTLC output that we extended to a party, but was
        // never fulfilled. This _is_ the HTLC output directly on our
        // commitment transaction, and the input to the second-level HTLC
        // timeout transaction. It can only be spent after CLTV expiry, and
        // commitment confirmation.
        HtlcOfferedTimeoutSecondLevelInputConfirmed StandardWitnessType = 15

        // HtlcAcceptedSuccessSecondLevel is a witness that allows us to sweep
        // an HTLC output that was offered to us, and for which we have a
        // payment preimage. This HTLC output isn't directly on our commitment
        // transaction, but is the result of confirmed second-level HTLC
        // transaction. As a result, we can only spend this after a CSV delay.
        HtlcAcceptedSuccessSecondLevel StandardWitnessType = 6

        // HtlcAcceptedSuccessSecondLevelInputConfirmed is a witness that
        // allows us to sweep an HTLC output that was offered to us, and for
        // which we have a payment preimage. This _is_ the HTLC output directly
        // on our commitment transaction, and the input to the second-level
        // HTLC success transaction.  It can only be spent after the commitment
        // has confirmed.
        HtlcAcceptedSuccessSecondLevelInputConfirmed StandardWitnessType = 16

        // HtlcOfferedRemoteTimeout is a witness that allows us to sweep an
        // HTLC that we offered to the remote party which lies in the
        // commitment transaction of the remote party. We can spend this output
        // after the absolute CLTV timeout of the HTLC as passed.
        HtlcOfferedRemoteTimeout StandardWitnessType = 7

        // HtlcAcceptedRemoteSuccess is a witness that allows us to sweep an
        // HTLC that was offered to us by the remote party. We use this witness
        // in the case that the remote party goes to chain, and we know the
        // pre-image to the HTLC. We can sweep this without any additional
        // timeout.
        HtlcAcceptedRemoteSuccess StandardWitnessType = 8

        // HtlcSecondLevelRevoke is a witness that allows us to sweep an HTLC
        // from the remote party's commitment transaction in the case that the
        // broadcast a revoked commitment, but then also immediately attempt to
        // go to the second level to claim the HTLC.
        HtlcSecondLevelRevoke StandardWitnessType = 9

        // WitnessKeyHash is a witness type that allows us to spend a regular
        // p2wkh output that's sent to an output which is under complete
        // control of the backing wallet.
        WitnessKeyHash StandardWitnessType = 10

        // NestedWitnessKeyHash is a witness type that allows us to sweep an
        // output that sends to a nested P2SH script that pays to a key solely
        // under our control. The witness generated needs to include the
        NestedWitnessKeyHash StandardWitnessType = 11

        // CommitSpendNoDelayTweakless is similar to the CommitSpendNoDelay
        // type, but it omits the tweak that randomizes the key we need to
        // spend with a channel peer supplied set of randomness.
        CommitSpendNoDelayTweakless StandardWitnessType = 12

        // CommitmentToRemoteConfirmed is a witness that allows us to spend our
        // output on the counterparty's commitment transaction after a
        // confirmation.
        CommitmentToRemoteConfirmed StandardWitnessType = 13

        // CommitmentAnchor is a witness that allows us to spend our anchor on
        // the commitment transaction.
        CommitmentAnchor StandardWitnessType = 14

        // LeaseCommitmentTimeLock is a witness that allows us to spend our
        // output on our local commitment transaction after a relative and
        // absolute lock-time lockout as part of the script enforced lease
        // commitment type.
        LeaseCommitmentTimeLock StandardWitnessType = 17

        // LeaseCommitmentToRemoteConfirmed is a witness that allows us to spend
        // our output on the counterparty's commitment transaction after a
        // confirmation and absolute locktime as part of the script enforced
        // lease commitment type.
        LeaseCommitmentToRemoteConfirmed StandardWitnessType = 18

        // LeaseHtlcOfferedTimeoutSecondLevel is a witness that allows us to
        // sweep an HTLC output that we extended to a party, but was never
        // fulfilled. This HTLC output isn't directly on the commitment
        // transaction, but is the result of a confirmed second-level HTLC
        // transaction. As a result, we can only spend this after a CSV delay
        // and CLTV locktime as part of the script enforced lease commitment
        // type.
        LeaseHtlcOfferedTimeoutSecondLevel StandardWitnessType = 19

        // LeaseHtlcAcceptedSuccessSecondLevel is a witness that allows us to
        // sweep an HTLC output that was offered to us, and for which we have a
        // payment preimage. This HTLC output isn't directly on our commitment
        // transaction, but is the result of confirmed second-level HTLC
        // transaction. As a result, we can only spend this after a CSV delay
        // and CLTV locktime as part of the script enforced lease commitment
        // type.
        LeaseHtlcAcceptedSuccessSecondLevel StandardWitnessType = 20

        // TaprootPubKeySpend is a witness type that allows us to spend a
        // regular p2tr output that's sent to an output which is under complete
        // control of the backing wallet.
        TaprootPubKeySpend StandardWitnessType = 21

        // TaprootLocalCommitSpend is a witness type that allows us to spend
        // our settled local commitment after a CSV delay when we force close
        // the channel.
        TaprootLocalCommitSpend StandardWitnessType = 22

        // TaprootRemoteCommitSpend is a witness type that allows us to spend
        // our settled local commitment after a CSV delay when the remote party
        // has force closed the channel.
        TaprootRemoteCommitSpend StandardWitnessType = 23

        // TaprootAnchorSweepSpend is the witness type we'll use for spending
        // our own anchor output.
        TaprootAnchorSweepSpend StandardWitnessType = 24

        // TaprootHtlcOfferedTimeoutSecondLevel is a witness that allows us to
        // timeout an HTLC we offered to the remote party on our commitment
        // transaction. We use this when we need to go on chain to time out an
        // HTLC.
        TaprootHtlcOfferedTimeoutSecondLevel StandardWitnessType = 25

        // TaprootHtlcAcceptedSuccessSecondLevel is a witness that allows us to
        // sweep an HTLC we accepted on our commitment transaction after we go
        // to the second level on chain.
        TaprootHtlcAcceptedSuccessSecondLevel StandardWitnessType = 26

        // TaprootHtlcSecondLevelRevoke is a witness that allows us to sweep an
        // HTLC on the revoked transaction of the remote party that goes to the
        // second level.
        TaprootHtlcSecondLevelRevoke StandardWitnessType = 27

        // TaprootHtlcAcceptedRevoke is a witness that allows us to sweep an
        // HTLC sent to us by the remote party in the event that they broadcast
        // a revoked state.
        TaprootHtlcAcceptedRevoke StandardWitnessType = 28

        // TaprootHtlcOfferedRevoke is a witness that allows us to sweep an
        // HTLC we offered to the remote party if they broadcast a revoked
        // commitment.
        TaprootHtlcOfferedRevoke StandardWitnessType = 29

        // TaprootHtlcOfferedRemoteTimeout is a witness that allows us to sweep
        // an HTLC we offered to the remote party that lies on the commitment
        // transaction for the remote party. We can spend this output after the
        // absolute CLTV timeout of the HTLC as passed.
        TaprootHtlcOfferedRemoteTimeout StandardWitnessType = 30

        // TaprootHtlcLocalOfferedTimeout is a witness type that allows us to
        // sign the second level HTLC timeout transaction when spending from an
        // HTLC residing on our local commitment transaction.
        //
        // This is used by the sweeper to re-sign inputs if it needs to
        // aggregate several second level HTLCs.
        TaprootHtlcLocalOfferedTimeout StandardWitnessType = 31

        // TaprootHtlcAcceptedRemoteSuccess is a witness that allows us to
        // sweep an HTLC that was offered to us by the remote party for a
        // taproot channels. We use this witness in the case that the remote
        // party goes to chain, and we know the pre-image to the HTLC. We can
        // sweep this without any additional timeout.
        TaprootHtlcAcceptedRemoteSuccess StandardWitnessType = 32

        // TaprootHtlcAcceptedLocalSuccess is a witness type that allows us to
        // sweep the HTLC offered to us on our local commitment transaction.
        // We'll use this when we need to go on chain to sweep the HTLC. In
        // this case, this is the second level HTLC success transaction.
        TaprootHtlcAcceptedLocalSuccess StandardWitnessType = 33

        // TaprootCommitmentRevoke is a witness that allows us to sweep the
        // settled output of a malicious counterparty's who broadcasts a
        // revoked taproot commitment transaction.
        TaprootCommitmentRevoke StandardWitnessType = 34
)

// String returns a human readable version of the target WitnessType.
//
// NOTE: This is part of the WitnessType interface.
func (wt StandardWitnessType) String() string <span class="cov0" title="0">{
        switch wt </span>{
        case CommitmentTimeLock:<span class="cov0" title="0">
                return "CommitmentTimeLock"</span>

        case CommitmentToRemoteConfirmed:<span class="cov0" title="0">
                return "CommitmentToRemoteConfirmed"</span>

        case CommitmentAnchor:<span class="cov0" title="0">
                return "CommitmentAnchor"</span>

        case CommitmentNoDelay:<span class="cov0" title="0">
                return "CommitmentNoDelay"</span>

        case CommitSpendNoDelayTweakless:<span class="cov0" title="0">
                return "CommitmentNoDelayTweakless"</span>

        case CommitmentRevoke:<span class="cov0" title="0">
                return "CommitmentRevoke"</span>

        case HtlcOfferedRevoke:<span class="cov0" title="0">
                return "HtlcOfferedRevoke"</span>

        case HtlcAcceptedRevoke:<span class="cov0" title="0">
                return "HtlcAcceptedRevoke"</span>

        case HtlcOfferedTimeoutSecondLevel:<span class="cov0" title="0">
                return "HtlcOfferedTimeoutSecondLevel"</span>

        case HtlcOfferedTimeoutSecondLevelInputConfirmed:<span class="cov0" title="0">
                return "HtlcOfferedTimeoutSecondLevelInputConfirmed"</span>

        case HtlcAcceptedSuccessSecondLevel:<span class="cov0" title="0">
                return "HtlcAcceptedSuccessSecondLevel"</span>

        case HtlcAcceptedSuccessSecondLevelInputConfirmed:<span class="cov0" title="0">
                return "HtlcAcceptedSuccessSecondLevelInputConfirmed"</span>

        case HtlcOfferedRemoteTimeout:<span class="cov0" title="0">
                return "HtlcOfferedRemoteTimeout"</span>

        case HtlcAcceptedRemoteSuccess:<span class="cov0" title="0">
                return "HtlcAcceptedRemoteSuccess"</span>

        case HtlcSecondLevelRevoke:<span class="cov0" title="0">
                return "HtlcSecondLevelRevoke"</span>

        case WitnessKeyHash:<span class="cov0" title="0">
                return "WitnessKeyHash"</span>

        case NestedWitnessKeyHash:<span class="cov0" title="0">
                return "NestedWitnessKeyHash"</span>

        case LeaseCommitmentTimeLock:<span class="cov0" title="0">
                return "LeaseCommitmentTimeLock"</span>

        case LeaseCommitmentToRemoteConfirmed:<span class="cov0" title="0">
                return "LeaseCommitmentToRemoteConfirmed"</span>

        case LeaseHtlcOfferedTimeoutSecondLevel:<span class="cov0" title="0">
                return "LeaseHtlcOfferedTimeoutSecondLevel"</span>

        case LeaseHtlcAcceptedSuccessSecondLevel:<span class="cov0" title="0">
                return "LeaseHtlcAcceptedSuccessSecondLevel"</span>

        case TaprootPubKeySpend:<span class="cov0" title="0">
                return "TaprootPubKeySpend"</span>

        case TaprootLocalCommitSpend:<span class="cov0" title="0">
                return "TaprootLocalCommitSpend"</span>

        case TaprootRemoteCommitSpend:<span class="cov0" title="0">
                return "TaprootRemoteCommitSpend"</span>

        case TaprootAnchorSweepSpend:<span class="cov0" title="0">
                return "TaprootAnchorSweepSpend"</span>

        case TaprootHtlcOfferedTimeoutSecondLevel:<span class="cov0" title="0">
                return "TaprootHtlcOfferedTimeoutSecondLevel"</span>

        case TaprootHtlcAcceptedSuccessSecondLevel:<span class="cov0" title="0">
                return "TaprootHtlcAcceptedSuccessSecondLevel"</span>

        case TaprootHtlcSecondLevelRevoke:<span class="cov0" title="0">
                return "TaprootHtlcSecondLevelRevoke"</span>

        case TaprootHtlcAcceptedRevoke:<span class="cov0" title="0">
                return "TaprootHtlcAcceptedRevoke"</span>

        case TaprootHtlcOfferedRevoke:<span class="cov0" title="0">
                return "TaprootHtlcOfferedRevoke"</span>

        case TaprootHtlcOfferedRemoteTimeout:<span class="cov0" title="0">
                return "TaprootHtlcOfferedRemoteTimeout"</span>

        case TaprootHtlcLocalOfferedTimeout:<span class="cov0" title="0">
                return "TaprootHtlcLocalOfferedTimeout"</span>

        case TaprootHtlcAcceptedRemoteSuccess:<span class="cov0" title="0">
                return "TaprootHtlcAcceptedRemoteSuccess"</span>

        case TaprootHtlcAcceptedLocalSuccess:<span class="cov0" title="0">
                return "TaprootHtlcAcceptedLocalSuccess"</span>

        case TaprootCommitmentRevoke:<span class="cov0" title="0">
                return "TaprootCommitmentRevoke"</span>

        default:<span class="cov0" title="0">
                return fmt.Sprintf("Unknown WitnessType: %v", uint32(wt))</span>
        }
}

// WitnessGenerator will return a WitnessGenerator function that an output uses
// to generate the witness and optionally the sigScript for a sweep
// transaction. The sigScript will be generated if the witness type warrants
// one for spending, such as the NestedWitnessKeyHash witness type.
//
// NOTE: This is part of the WitnessType interface.
func (wt StandardWitnessType) WitnessGenerator(signer Signer,
        descriptor *SignDescriptor) WitnessGenerator <span class="cov0" title="0">{

        return func(tx *wire.MsgTx, hc *txscript.TxSigHashes,
                inputIndex int) (*Script, error) </span><span class="cov0" title="0">{

                // TODO(roasbeef): copy the desc?
                desc := descriptor
                desc.SigHashes = hc
                desc.InputIndex = inputIndex

                switch wt </span>{
                case CommitmentTimeLock, LeaseCommitmentTimeLock:<span class="cov0" title="0">
                        witness, err := CommitSpendTimeout(signer, desc, tx)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov0" title="0">return &amp;Script{
                                Witness: witness,
                        }, nil</span>

                case CommitmentToRemoteConfirmed, LeaseCommitmentToRemoteConfirmed:<span class="cov0" title="0">
                        witness, err := CommitSpendToRemoteConfirmed(
                                signer, desc, tx,
                        )
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov0" title="0">return &amp;Script{
                                Witness: witness,
                        }, nil</span>

                case CommitmentAnchor:<span class="cov0" title="0">
                        witness, err := CommitSpendAnchor(signer, desc, tx)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov0" title="0">return &amp;Script{
                                Witness: witness,
                        }, nil</span>

                case CommitmentNoDelay:<span class="cov0" title="0">
                        witness, err := CommitSpendNoDelay(signer, desc, tx, false)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov0" title="0">return &amp;Script{
                                Witness: witness,
                        }, nil</span>

                case CommitSpendNoDelayTweakless:<span class="cov0" title="0">
                        witness, err := CommitSpendNoDelay(signer, desc, tx, true)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov0" title="0">return &amp;Script{
                                Witness: witness,
                        }, nil</span>

                case CommitmentRevoke:<span class="cov0" title="0">
                        witness, err := CommitSpendRevoke(signer, desc, tx)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov0" title="0">return &amp;Script{
                                Witness: witness,
                        }, nil</span>

                case HtlcOfferedRevoke:<span class="cov0" title="0">
                        witness, err := ReceiverHtlcSpendRevoke(signer, desc, tx)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov0" title="0">return &amp;Script{
                                Witness: witness,
                        }, nil</span>

                case HtlcAcceptedRevoke:<span class="cov0" title="0">
                        witness, err := SenderHtlcSpendRevoke(signer, desc, tx)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov0" title="0">return &amp;Script{
                                Witness: witness,
                        }, nil</span>

                case HtlcOfferedTimeoutSecondLevel,
                        LeaseHtlcOfferedTimeoutSecondLevel,
                        HtlcAcceptedSuccessSecondLevel,
                        LeaseHtlcAcceptedSuccessSecondLevel:<span class="cov0" title="0">

                        witness, err := HtlcSecondLevelSpend(signer, desc, tx)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov0" title="0">return &amp;Script{
                                Witness: witness,
                        }, nil</span>

                case HtlcOfferedRemoteTimeout:<span class="cov0" title="0">
                        // We pass in a value of -1 for the timeout, as we
                        // expect the caller to have already set the lock time
                        // value.
                        witness, err := ReceiverHtlcSpendTimeout(signer, desc, tx, -1)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov0" title="0">return &amp;Script{
                                Witness: witness,
                        }, nil</span>

                case HtlcSecondLevelRevoke:<span class="cov0" title="0">
                        witness, err := HtlcSpendRevoke(signer, desc, tx)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov0" title="0">return &amp;Script{
                                Witness: witness,
                        }, nil</span>

                case WitnessKeyHash:<span class="cov0" title="0">
                        fallthrough</span>
                case TaprootPubKeySpend:<span class="cov0" title="0">
                        fallthrough</span>
                case NestedWitnessKeyHash:<span class="cov0" title="0">
                        return signer.ComputeInputScript(tx, desc)</span>

                case TaprootLocalCommitSpend:<span class="cov0" title="0">
                        // Ensure that the sign desc has the proper sign method
                        // set, and a valid prev output fetcher.
                        desc.SignMethod = TaprootScriptSpendSignMethod

                        // The control block bytes must be set at this point.
                        if desc.ControlBlock == nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("control block must " +
                                        "be set for taproot spend")
                        }</span>

                        <span class="cov0" title="0">witness, err := TaprootCommitSpendSuccess(
                                signer, desc, tx, nil,
                        )
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov0" title="0">return &amp;Script{
                                Witness: witness,
                        }, nil</span>

                case TaprootRemoteCommitSpend:<span class="cov0" title="0">
                        // Ensure that the sign desc has the proper sign method
                        // set, and a valid prev output fetcher.
                        desc.SignMethod = TaprootScriptSpendSignMethod

                        // The control block bytes must be set at this point.
                        if desc.ControlBlock == nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("control block must " +
                                        "be set for taproot spend")
                        }</span>

                        <span class="cov0" title="0">witness, err := TaprootCommitRemoteSpend(
                                signer, desc, tx, nil,
                        )
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov0" title="0">return &amp;Script{
                                Witness: witness,
                        }, nil</span>

                case TaprootAnchorSweepSpend:<span class="cov0" title="0">
                        // Ensure that the sign desc has the proper sign method
                        // set, and a valid prev output fetcher.
                        desc.SignMethod = TaprootKeySpendSignMethod

                        // The tap tweak must be set at this point.
                        if desc.TapTweak == nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("tap tweak must be " +
                                        "set for keyspend")
                        }</span>

                        <span class="cov0" title="0">witness, err := TaprootAnchorSpend(
                                signer, desc, tx,
                        )
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov0" title="0">return &amp;Script{
                                Witness: witness,
                        }, nil</span>

                case TaprootHtlcOfferedTimeoutSecondLevel,
                        TaprootHtlcAcceptedSuccessSecondLevel:<span class="cov0" title="0">
                        // Ensure that the sign desc has the proper sign method
                        // set, and a valid prev output fetcher.
                        desc.SignMethod = TaprootScriptSpendSignMethod

                        // The control block bytes must be set at this point.
                        if desc.ControlBlock == nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("control block must " +
                                        "be set for taproot spend")
                        }</span>

                        <span class="cov0" title="0">witness, err := TaprootHtlcSpendSuccess(
                                signer, desc, tx, nil, nil,
                        )
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov0" title="0">return &amp;Script{
                                Witness: witness,
                        }, nil</span>

                case TaprootHtlcSecondLevelRevoke:<span class="cov0" title="0">
                        // Ensure that the sign desc has the proper sign method
                        // set, and a valid prev output fetcher.
                        desc.SignMethod = TaprootKeySpendSignMethod

                        // The tap tweak must be set at this point.
                        if desc.TapTweak == nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("tap tweak must be " +
                                        "set for keyspend")
                        }</span>

                        <span class="cov0" title="0">witness, err := TaprootHtlcSpendRevoke(
                                signer, desc, tx,
                        )
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov0" title="0">return &amp;Script{
                                Witness: witness,
                        }, nil</span>

                case TaprootHtlcOfferedRevoke:<span class="cov0" title="0">
                        // Ensure that the sign desc has the proper sign method
                        // set, and a valid prev output fetcher.
                        desc.SignMethod = TaprootKeySpendSignMethod

                        // The tap tweak must be set at this point.
                        if desc.TapTweak == nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("tap tweak must be " +
                                        "set for keyspend")
                        }</span>

                        <span class="cov0" title="0">witness, err := SenderHTLCScriptTaprootRevoke(
                                signer, desc, tx,
                        )
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov0" title="0">return &amp;Script{
                                Witness: witness,
                        }, nil</span>

                case TaprootHtlcAcceptedRevoke:<span class="cov0" title="0">
                        // Ensure that the sign desc has the proper sign method
                        // set, and a valid prev output fetcher.
                        desc.SignMethod = TaprootKeySpendSignMethod

                        // The tap tweak must be set at this point.
                        if desc.TapTweak == nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("tap tweak must be " +
                                        "set for keyspend")
                        }</span>

                        <span class="cov0" title="0">witness, err := ReceiverHTLCScriptTaprootRevoke(
                                signer, desc, tx,
                        )
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov0" title="0">return &amp;Script{
                                Witness: witness,
                        }, nil</span>

                case TaprootHtlcOfferedRemoteTimeout:<span class="cov0" title="0">
                        // Ensure that the sign desc has the proper sign method
                        // set, and a valid prev output fetcher.
                        desc.SignMethod = TaprootScriptSpendSignMethod

                        // The control block bytes must be set at this point.
                        if desc.ControlBlock == nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("control block " +
                                        "must be set for taproot spend")
                        }</span>

                        <span class="cov0" title="0">witness, err := ReceiverHTLCScriptTaprootTimeout(
                                signer, desc, tx, -1, nil, nil,
                        )
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov0" title="0">return &amp;Script{
                                Witness: witness,
                        }, nil</span>

                case TaprootCommitmentRevoke:<span class="cov0" title="0">
                        // Ensure that the sign desc has the proper sign method
                        // set, and a valid prev output fetcher.
                        desc.SignMethod = TaprootScriptSpendSignMethod

                        // The control block bytes must be set at this point.
                        if desc.ControlBlock == nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("control block " +
                                        "must be set for taproot spend")
                        }</span>

                        <span class="cov0" title="0">witness, err := TaprootCommitSpendRevoke(
                                signer, desc, tx, nil,
                        )
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov0" title="0">return &amp;Script{
                                Witness: witness,
                        }, nil</span>

                default:<span class="cov0" title="0">
                        return nil, fmt.Errorf("unknown witness type: %v", wt)</span>
                }
        }
}

// SizeUpperBound returns the maximum length of the witness of this witness
// type if it would be included in a tx. We also return if the output itself is
// a nested p2sh output, if so then we need to take into account the extra
// sigScript data size.
//
// NOTE: This is part of the WitnessType interface.
func (wt StandardWitnessType) SizeUpperBound() (lntypes.WeightUnit,
        bool, error) <span class="cov0" title="0">{

        switch wt </span>{
        // Outputs on a remote commitment transaction that pay directly to us.
        case CommitSpendNoDelayTweakless:<span class="cov0" title="0">
                fallthrough</span>
        case WitnessKeyHash:<span class="cov0" title="0">
                fallthrough</span>
        case CommitmentNoDelay:<span class="cov0" title="0">
                return P2WKHWitnessSize, false, nil</span>

        // Outputs on a past commitment transaction that pay directly
        // to us.
        case CommitmentTimeLock:<span class="cov0" title="0">
                return ToLocalTimeoutWitnessSize, false, nil</span>
        case LeaseCommitmentTimeLock:<span class="cov0" title="0">
                size := ToLocalTimeoutWitnessSize +
                        LeaseWitnessScriptSizeOverhead

                return lntypes.WeightUnit(size), false, nil</span>

        // 1 CSV time locked output to us on remote commitment.
        case CommitmentToRemoteConfirmed:<span class="cov0" title="0">
                return ToRemoteConfirmedWitnessSize, false, nil</span>
        case LeaseCommitmentToRemoteConfirmed:<span class="cov0" title="0">
                size := ToRemoteConfirmedWitnessSize +
                        LeaseWitnessScriptSizeOverhead

                return lntypes.WeightUnit(size), false, nil</span>

        // Anchor output on the commitment transaction.
        case CommitmentAnchor:<span class="cov0" title="0">
                return AnchorWitnessSize, false, nil</span>

        // Outgoing second layer HTLC's that have confirmed within the
        // chain, and the output they produced is now mature enough to
        // sweep.
        case HtlcOfferedTimeoutSecondLevel:<span class="cov0" title="0">
                return ToLocalTimeoutWitnessSize, false, nil</span>
        case LeaseHtlcOfferedTimeoutSecondLevel:<span class="cov0" title="0">
                size := ToLocalTimeoutWitnessSize +
                        LeaseWitnessScriptSizeOverhead

                return lntypes.WeightUnit(size), false, nil</span>

        // Input to the outgoing HTLC second layer timeout transaction.
        case HtlcOfferedTimeoutSecondLevelInputConfirmed:<span class="cov0" title="0">
                return OfferedHtlcTimeoutWitnessSizeConfirmed, false, nil</span>

        // Incoming second layer HTLC's that have confirmed within the
        // chain, and the output they produced is now mature enough to
        // sweep.
        case HtlcAcceptedSuccessSecondLevel:<span class="cov0" title="0">
                return ToLocalTimeoutWitnessSize, false, nil</span>
        case LeaseHtlcAcceptedSuccessSecondLevel:<span class="cov0" title="0">
                size := ToLocalTimeoutWitnessSize +
                        LeaseWitnessScriptSizeOverhead

                return lntypes.WeightUnit(size), false, nil</span>

        // Input to the incoming second-layer HTLC success transaction.
        case HtlcAcceptedSuccessSecondLevelInputConfirmed:<span class="cov0" title="0">
                return AcceptedHtlcSuccessWitnessSizeConfirmed, false, nil</span>

        // An HTLC on the commitment transaction of the remote party,
        // that has had its absolute timelock expire.
        case HtlcOfferedRemoteTimeout:<span class="cov0" title="0">
                return AcceptedHtlcTimeoutWitnessSize, false, nil</span>

        // An HTLC on the commitment transaction of the remote party,
        // that can be swept with the preimage.
        case HtlcAcceptedRemoteSuccess:<span class="cov0" title="0">
                return OfferedHtlcSuccessWitnessSize, false, nil</span>

        // A nested P2SH input that has a p2wkh witness script. We'll mark this
        // as nested P2SH so the caller can estimate the weight properly
        // including the sigScript.
        case NestedWitnessKeyHash:<span class="cov0" title="0">
                return P2WKHWitnessSize, true, nil</span>

        // The revocation output on a revoked commitment transaction.
        case CommitmentRevoke:<span class="cov0" title="0">
                return ToLocalPenaltyWitnessSize, false, nil</span>

        // The revocation output on a revoked HTLC that we offered to the remote
        // party.
        case HtlcOfferedRevoke:<span class="cov0" title="0">
                return OfferedHtlcPenaltyWitnessSize, false, nil</span>

        // The revocation output on a revoked HTLC that was sent to us.
        case HtlcAcceptedRevoke:<span class="cov0" title="0">
                return AcceptedHtlcPenaltyWitnessSize, false, nil</span>

        // The revocation output of a second level output of an HTLC.
        case HtlcSecondLevelRevoke:<span class="cov0" title="0">
                return ToLocalPenaltyWitnessSize, false, nil</span>

        case TaprootPubKeySpend:<span class="cov0" title="0">
                return TaprootKeyPathCustomSighashWitnessSize, false, nil</span>

        // Sweeping a self output after a delay for taproot channels.
        case TaprootLocalCommitSpend:<span class="cov0" title="0">
                return TaprootToLocalWitnessSize, false, nil</span>

        // Sweeping a self output after the remote party fro ce closes. Must
        // wait 1 CSV.
        case TaprootRemoteCommitSpend:<span class="cov0" title="0">
                return TaprootToRemoteWitnessSize, false, nil</span>

        // Sweeping our anchor output with a key spend witness.
        case TaprootAnchorSweepSpend:<span class="cov0" title="0">
                return TaprootAnchorWitnessSize, false, nil</span>

        case TaprootHtlcOfferedTimeoutSecondLevel,
                TaprootHtlcAcceptedSuccessSecondLevel:<span class="cov0" title="0">

                return TaprootSecondLevelHtlcWitnessSize, false, nil</span>

        case TaprootHtlcSecondLevelRevoke:<span class="cov0" title="0">
                return TaprootSecondLevelRevokeWitnessSize, false, nil</span>

        case TaprootHtlcAcceptedRevoke:<span class="cov0" title="0">
                return TaprootAcceptedRevokeWitnessSize, false, nil</span>

        case TaprootHtlcOfferedRevoke:<span class="cov0" title="0">
                return TaprootOfferedRevokeWitnessSize, false, nil</span>

        case TaprootHtlcOfferedRemoteTimeout:<span class="cov0" title="0">
                return TaprootHtlcOfferedRemoteTimeoutWitnessSize, false, nil</span>

        case TaprootHtlcLocalOfferedTimeout:<span class="cov0" title="0">
                return TaprootOfferedLocalTimeoutWitnessSize, false, nil</span>

        case TaprootHtlcAcceptedRemoteSuccess:<span class="cov0" title="0">
                return TaprootHtlcAcceptedRemoteSuccessWitnessSize, false, nil</span>

        case TaprootHtlcAcceptedLocalSuccess:<span class="cov0" title="0">
                return TaprootHtlcAcceptedLocalSuccessWitnessSize, false, nil</span>

        case TaprootCommitmentRevoke:<span class="cov0" title="0">
                return TaprootToLocalRevokeWitnessSize, false, nil</span>
        }

        <span class="cov0" title="0">return 0, false, fmt.Errorf("unexpected witness type: %v", wt)</span>
}

// AddWeightEstimation adds the estimated size of the witness in bytes to the
// given weight estimator.
//
// NOTE: This is part of the WitnessType interface.
func (wt StandardWitnessType) AddWeightEstimation(e *TxWeightEstimator) error <span class="cov0" title="0">{
        // For fee estimation purposes, we'll now attempt to obtain an
        // upper bound on the weight this input will add when fully
        // populated.
        size, isNestedP2SH, err := wt.SizeUpperBound()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // If this is a nested P2SH input, then we'll need to factor in
        // the additional data push within the sigScript.
        <span class="cov0" title="0">if isNestedP2SH </span><span class="cov0" title="0">{
                e.AddNestedP2WSHInput(size)
        }</span> else<span class="cov0" title="0"> {
                e.AddWitnessInput(size)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">// Copyright (c) 2013-2022 The btcsuite developers

package musig2v040

import (
        "fmt"

        "github.com/btcsuite/btcd/btcec/v2"
        "github.com/btcsuite/btcd/btcec/v2/schnorr"
)

var (
        // ErrSignersNotSpecified is returned when a caller attempts to create
        // a context without specifying either the total number of signers, or
        // the complete set of singers.
        ErrSignersNotSpecified = fmt.Errorf("total number of signers or all " +
                "signers must be known")

        // ErrSignerNotInKeySet is returned when a the private key for a signer
        // isn't included in the set of signing public keys.
        ErrSignerNotInKeySet = fmt.Errorf("signing key is not found in key" +
                " set")

        // ErrAlredyHaveAllNonces is called when RegisterPubNonce is called too
        // many times for a given signing session.
        ErrAlredyHaveAllNonces = fmt.Errorf("already have all nonces")

        // ErrNotEnoughSigners is returned when a caller attempts to create a
        // session from a context, but before all the required signers are
        // known.
        ErrNotEnoughSigners = fmt.Errorf("not enough signers")

        // ErrAlredyHaveAllNonces is returned when a caller attempts to
        // register a signer, once we already have the total set of known
        // signers.
        ErrAlreadyHaveAllSigners = fmt.Errorf("all signers registered")

        // ErrAlredyHaveAllSigs is called when CombineSig is called too many
        // times for a given signing session.
        ErrAlredyHaveAllSigs = fmt.Errorf("already have all sigs")

        // ErrSigningContextReuse is returned if a user attempts to sign using
        // the same signing context more than once.
        ErrSigningContextReuse = fmt.Errorf("nonce already used")

        // ErrFinalSigInvalid is returned when the combined signature turns out
        // to be invalid.
        ErrFinalSigInvalid = fmt.Errorf("final signature is invalid")

        // ErrCombinedNonceUnavailable is returned when a caller attempts to
        // sign a partial signature, without first having collected all the
        // required combined nonces.
        ErrCombinedNonceUnavailable = fmt.Errorf("missing combined nonce")

        // ErrTaprootInternalKeyUnavailable is returned when a user attempts to
        // obtain the
        ErrTaprootInternalKeyUnavailable = fmt.Errorf("taproot tweak not used")

        // ErrNotEnoughSigners is returned if a caller attempts to obtain an
        // early nonce when it wasn't specified
        ErrNoEarlyNonce = fmt.Errorf("no early nonce available")
)

// Context is a managed signing context for musig2. It takes care of things
// like securely generating secret nonces, aggregating keys and nonces, etc.
type Context struct {
        // signingKey is the key we'll use for signing.
        signingKey *btcec.PrivateKey

        // pubKey is our even-y coordinate public  key.
        pubKey *btcec.PublicKey

        // combinedKey is the aggregated public key.
        combinedKey *AggregateKey

        // uniqueKeyIndex is the index of the second unique key in the keySet.
        // This is used to speed up signing and verification computations.
        uniqueKeyIndex int

        // keysHash is the hash of all the keys as defined in musig2.
        keysHash []byte

        // opts is the set of options for the context.
        opts *contextOptions

        // shouldSort keeps track of if the public keys should be sorted before
        // any operations.
        shouldSort bool

        // sessionNonce will be populated if the earlyNonce option is true.
        // After the first session is created, this nonce will be blanked out.
        sessionNonce *Nonces
}

// ContextOption is a functional option argument that allows callers to modify
// the musig2 signing is done within a context.
type ContextOption func(*contextOptions)

// contextOptions houses the set of functional options that can be used to
// musig2 signing protocol.
type contextOptions struct {
        // tweaks is the set of optinoal tweaks to apply to the combined public
        // key.
        tweaks []KeyTweakDesc

        // taprootTweak specifies the taproot tweak. If specified, then we'll
        // use this as the script root for the BIP 341 taproot (x-only) tweak.
        // Normally we'd just apply the raw 32 byte tweak, but for taproot, we
        // first need to compute the aggregated key before tweaking, and then
        // use it as the internal key. This is required as the taproot tweak
        // also commits to the public key, which in this case is the aggregated
        // key before the tweak.
        taprootTweak []byte

        // bip86Tweak if true, then the weak will just be
        // h_tapTweak(internalKey) as there is no true script root.
        bip86Tweak bool

        // keySet is the complete set of signers for this context.
        keySet []*btcec.PublicKey

        // numSigners is the total number of signers that will eventually be a
        // part of the context.
        numSigners int

        // earlyNonce determines if a nonce should be generated during context
        // creation, to be automatically passed to the created session.
        earlyNonce bool
}

// defaultContextOptions returns the default context options.
func defaultContextOptions() *contextOptions <span class="cov0" title="0">{
        return &amp;contextOptions{}
}</span>

// WithTweakedContext specifies that within the context, the aggregated public
// key should be tweaked with the specified tweaks.
func WithTweakedContext(tweaks ...KeyTweakDesc) ContextOption <span class="cov0" title="0">{
        return func(o *contextOptions) </span><span class="cov0" title="0">{
                o.tweaks = tweaks
        }</span>
}

// WithTaprootTweakCtx specifies that within this context, the final key should
// use the taproot tweak as defined in BIP 341: outputKey = internalKey +
// h_tapTweak(internalKey || scriptRoot). In this case, the aggreaged key
// before the tweak will be used as the internal key.
func WithTaprootTweakCtx(scriptRoot []byte) ContextOption <span class="cov0" title="0">{
        return func(o *contextOptions) </span><span class="cov0" title="0">{
                o.taprootTweak = scriptRoot
        }</span>
}

// WithBip86TweakCtx specifies that within this context, the final key should
// use the taproot tweak as defined in BIP 341, with the BIP 86 modification:
// outputKey = internalKey + h_tapTweak(internalKey)*G. In this case, the
// aggreaged key before the tweak will be used as the internal key.
func WithBip86TweakCtx() ContextOption <span class="cov0" title="0">{
        return func(o *contextOptions) </span><span class="cov0" title="0">{
                o.bip86Tweak = true
        }</span>
}

// WithKnownSigners is an optional parameter that should be used if a session
// can be created as soon as all the singers are known.
func WithKnownSigners(signers []*btcec.PublicKey) ContextOption <span class="cov0" title="0">{
        return func(o *contextOptions) </span><span class="cov0" title="0">{
                o.keySet = signers
                o.numSigners = len(signers)
        }</span>
}

// WithNumSigners is a functional option used to specify that a context should
// be created without knowing all the signers. Instead the total number of
// signers is specified to ensure that a session can only be created once all
// the signers are known.
//
// NOTE: Either WithKnownSigners or WithNumSigners MUST be specified.
func WithNumSigners(n int) ContextOption <span class="cov0" title="0">{
        return func(o *contextOptions) </span><span class="cov0" title="0">{
                o.numSigners = n
        }</span>
}

// WithEarlyNonceGen allow a caller to specify that a nonce should be generated
// early, before the session is created. This should be used in protocols that
// require some partial nonce exchange before all the signers are known.
//
// NOTE: This option must only be specified with the WithNumSigners option.
func WithEarlyNonceGen() ContextOption <span class="cov0" title="0">{
        return func(o *contextOptions) </span><span class="cov0" title="0">{
                o.earlyNonce = true
        }</span>
}

// NewContext creates a new signing context with the passed singing key and set
// of public keys for each of the other signers.
//
// NOTE: This struct should be used over the raw Sign API whenever possible.
func NewContext(signingKey *btcec.PrivateKey, shouldSort bool,
        ctxOpts ...ContextOption) (*Context, error) <span class="cov0" title="0">{

        // First, parse the set of optional context options.
        opts := defaultContextOptions()
        for _, option := range ctxOpts </span><span class="cov0" title="0">{
                option(opts)
        }</span>

        <span class="cov0" title="0">pubKey, err := schnorr.ParsePubKey(
                schnorr.SerializePubKey(signingKey.PubKey()),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">ctx := &amp;Context{
                signingKey: signingKey,
                pubKey:     pubKey,
                opts:       opts,
                shouldSort: shouldSort,
        }

        switch </span>{

        // We know all the signers, so we can compute the aggregated key, along
        // with all the other intermediate state we need to do signing and
        // verification.
        case opts.keySet != nil:<span class="cov0" title="0">
                if err := ctx.combineSignerKeys(); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

        // The total signers are known, so we add ourselves, and skip key
        // aggregation.
        case opts.numSigners != 0:<span class="cov0" title="0">
                // Otherwise, we'll add ourselves as the only known signer, and
                // await further calls to RegisterSigner before a session can
                // be created.
                opts.keySet = make([]*btcec.PublicKey, 0, opts.numSigners)
                opts.keySet = append(opts.keySet, pubKey)

                // If early nonce generation is specified, then we'll generate
                // the nonce now to pass in to the session once all the callers
                // are known.
                if opts.earlyNonce </span><span class="cov0" title="0">{
                        ctx.sessionNonce, err = GenNonces()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }

        default:<span class="cov0" title="0">
                return nil, ErrSignersNotSpecified</span>
        }

        <span class="cov0" title="0">return ctx, nil</span>
}

// combineSignerKeys is used to compute the aggregated signer key once all the
// signers are known.
func (c *Context) combineSignerKeys() error <span class="cov0" title="0">{
        // As a sanity check, make sure the signing key is actually
        // amongst the sit of signers.
        var keyFound bool
        for _, key := range c.opts.keySet </span><span class="cov0" title="0">{
                if key.IsEqual(c.pubKey) </span><span class="cov0" title="0">{
                        keyFound = true
                        break</span>
                }
        }
        <span class="cov0" title="0">if !keyFound </span><span class="cov0" title="0">{
                return ErrSignerNotInKeySet
        }</span>

        // Now that we know that we're actually a signer, we'll
        // generate the key hash finger print and second unique key
        // index so we can speed up signing later.
        <span class="cov0" title="0">c.keysHash = keyHashFingerprint(c.opts.keySet, c.shouldSort)
        c.uniqueKeyIndex = secondUniqueKeyIndex(
                c.opts.keySet, c.shouldSort,
        )

        keyAggOpts := []KeyAggOption{
                WithKeysHash(c.keysHash),
                WithUniqueKeyIndex(c.uniqueKeyIndex),
        }
        switch </span>{
        case c.opts.bip86Tweak:<span class="cov0" title="0">
                keyAggOpts = append(
                        keyAggOpts, WithBIP86KeyTweak(),
                )</span>
        case c.opts.taprootTweak != nil:<span class="cov0" title="0">
                keyAggOpts = append(
                        keyAggOpts, WithTaprootKeyTweak(c.opts.taprootTweak),
                )</span>
        case len(c.opts.tweaks) != 0:<span class="cov0" title="0">
                keyAggOpts = append(keyAggOpts, WithKeyTweaks(c.opts.tweaks...))</span>
        }

        // Next, we'll use this information to compute the aggregated
        // public key that'll be used for signing in practice.
        <span class="cov0" title="0">var err error
        c.combinedKey, _, _, err = AggregateKeys(
                c.opts.keySet, c.shouldSort, keyAggOpts...,
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// EarlySessionNonce returns the early session nonce, if available.
func (c *Context) EarlySessionNonce() (*Nonces, error) <span class="cov0" title="0">{
        if c.sessionNonce == nil </span><span class="cov0" title="0">{
                return nil, ErrNoEarlyNonce
        }</span>

        <span class="cov0" title="0">return c.sessionNonce, nil</span>
}

// RegisterSigner allows a caller to register a signer after the context has
// been created. This will be used in scenarios where the total number of
// signers is known, but nonce exchange needs to happen before all the signers
// are known.
//
// A bool is returned which indicates if all the signers have been registered.
//
// NOTE: If the set of keys are not to be sorted during signing, then the
// ordering each key is registered with MUST match the desired ordering.
func (c *Context) RegisterSigner(pub *btcec.PublicKey) (bool, error) <span class="cov0" title="0">{
        haveAllSigners := len(c.opts.keySet) == c.opts.numSigners
        if haveAllSigners </span><span class="cov0" title="0">{
                return false, ErrAlreadyHaveAllSigners
        }</span>

        <span class="cov0" title="0">c.opts.keySet = append(c.opts.keySet, pub)

        // If we have the expected number of signers at this point, then we can
        // generate the aggregated key and other necessary information.
        haveAllSigners = len(c.opts.keySet) == c.opts.numSigners
        if haveAllSigners </span><span class="cov0" title="0">{
                if err := c.combineSignerKeys(); err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
        }

        <span class="cov0" title="0">return haveAllSigners, nil</span>
}

// NumRegisteredSigners returns the total number of registered signers.
func (c *Context) NumRegisteredSigners() int <span class="cov0" title="0">{
        return len(c.opts.keySet)
}</span>

// CombinedKey returns the combined public key that will be used to generate
// multi-signatures  against.
func (c *Context) CombinedKey() (*btcec.PublicKey, error) <span class="cov0" title="0">{
        // If the caller hasn't registered all the signers at this point, then
        // the combined key won't be available.
        if c.combinedKey == nil </span><span class="cov0" title="0">{
                return nil, ErrNotEnoughSigners
        }</span>

        <span class="cov0" title="0">return c.combinedKey.FinalKey, nil</span>
}

// PubKey returns the public key of the signer of this session.
func (c *Context) PubKey() btcec.PublicKey <span class="cov0" title="0">{
        return *c.pubKey
}</span>

// SigningKeys returns the set of keys used for signing.
func (c *Context) SigningKeys() []*btcec.PublicKey <span class="cov0" title="0">{
        keys := make([]*btcec.PublicKey, len(c.opts.keySet))
        copy(keys, c.opts.keySet)

        return keys
}</span>

// TaprootInternalKey returns the internal taproot key, which is the aggregated
// key _before_ the tweak is applied. If a taproot tweak was specified, then
// CombinedKey() will return the fully tweaked output key, with this method
// returning the internal key. If a taproot tweak wasn't specified, then this
// method will return an error.
func (c *Context) TaprootInternalKey() (*btcec.PublicKey, error) <span class="cov0" title="0">{
        // If the caller hasn't registered all the signers at this point, then
        // the combined key won't be available.
        if c.combinedKey == nil </span><span class="cov0" title="0">{
                return nil, ErrNotEnoughSigners
        }</span>

        <span class="cov0" title="0">if c.opts.taprootTweak == nil &amp;&amp; !c.opts.bip86Tweak </span><span class="cov0" title="0">{
                return nil, ErrTaprootInternalKeyUnavailable
        }</span>

        <span class="cov0" title="0">return c.combinedKey.PreTweakedKey, nil</span>
}

// SessionOption is a functional option argument that allows callers to modify
// the musig2 signing is done within a session.
type SessionOption func(*sessionOptions)

// sessionOptions houses the set of functional options that can be used to
// modify the musig2 signing protocol.
type sessionOptions struct {
        externalNonce *Nonces
}

// defaultSessionOptions returns the default session options.
func defaultSessionOptions() *sessionOptions <span class="cov0" title="0">{
        return &amp;sessionOptions{}
}</span>

// WithPreGeneratedNonce allows a caller to start a session using a nonce
// they've generated themselves. This may be useful in protocols where all the
// signer keys may not be known before nonce exchange needs to occur.
func WithPreGeneratedNonce(nonce *Nonces) SessionOption <span class="cov0" title="0">{
        return func(o *sessionOptions) </span><span class="cov0" title="0">{
                o.externalNonce = nonce
        }</span>
}

// Session represents a musig2 signing session. A new instance should be
// created each time a multi-signature is needed. The session struct handles
// nonces management, incremental partial sig vitrifaction, as well as final
// signature combination. Errors are returned when unsafe behavior such as
// nonce re-use is attempted.
//
// NOTE: This struct should be used over the raw Sign API whenever possible.
type Session struct {
        opts *sessionOptions

        ctx *Context

        localNonces *Nonces

        pubNonces [][PubNonceSize]byte

        combinedNonce *[PubNonceSize]byte

        msg [32]byte

        ourSig *PartialSignature
        sigs   []*PartialSignature

        finalSig *schnorr.Signature
}

// NewSession creates a new musig2 signing session.
func (c *Context) NewSession(options ...SessionOption) (*Session, error) <span class="cov0" title="0">{
        opts := defaultSessionOptions()
        for _, opt := range options </span><span class="cov0" title="0">{
                opt(opts)
        }</span>

        // At this point we verify that we know of all the signers, as
        // otherwise we can't proceed with the session. This check is intended
        // to catch misuse of the API wherein a caller forgets to register the
        // remaining signers if they're doing nonce generation ahead of time.
        <span class="cov0" title="0">if len(c.opts.keySet) != c.opts.numSigners </span><span class="cov0" title="0">{
                return nil, ErrNotEnoughSigners
        }</span>

        // If an early nonce was specified, then we'll automatically add the
        // corresponding session option for the caller.
        <span class="cov0" title="0">var localNonces *Nonces
        if c.sessionNonce != nil </span><span class="cov0" title="0">{
                // Apply the early nonce to the session, and also blank out the
                // session nonce on the context to ensure it isn't ever re-used
                // for another session.
                localNonces = c.sessionNonce
                c.sessionNonce = nil
        }</span> else<span class="cov0" title="0"> if opts.externalNonce != nil </span><span class="cov0" title="0">{
                // Otherwise if there's a custom nonce passed in via the
                // session options, then use that instead.
                localNonces = opts.externalNonce
        }</span>

        // Now that we know we have enough signers, we'll either use the caller
        // specified nonce, or generate a fresh set.
        <span class="cov0" title="0">var err error
        if localNonces == nil </span><span class="cov0" title="0">{
                // At this point we need to generate a fresh nonce. We'll pass
                // in some auxiliary information to strengthen the nonce
                // generated.
                localNonces, err = GenNonces(
                        WithNonceSecretKeyAux(c.signingKey),
                        WithNonceCombinedKeyAux(c.combinedKey.FinalKey),
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">s := &amp;Session{
                opts:        opts,
                ctx:         c,
                localNonces: localNonces,
                pubNonces:   make([][PubNonceSize]byte, 0, c.opts.numSigners),
                sigs:        make([]*PartialSignature, 0, c.opts.numSigners),
        }

        s.pubNonces = append(s.pubNonces, localNonces.PubNonce)

        return s, nil</span>
}

// PublicNonce returns the public nonce for a signer. This should be sent to
// other parties before signing begins, so they can compute the aggregated
// public nonce.
func (s *Session) PublicNonce() [PubNonceSize]byte <span class="cov0" title="0">{
        return s.localNonces.PubNonce
}</span>

// NumRegisteredNonces returns the total number of nonces that have been
// regsitered so far.
func (s *Session) NumRegisteredNonces() int <span class="cov0" title="0">{
        return len(s.pubNonces)
}</span>

// RegisterPubNonce should be called for each public nonce from the set of
// signers. This method returns true once all the public nonces have been
// accounted for.
func (s *Session) RegisterPubNonce(nonce [PubNonceSize]byte) (bool, error) <span class="cov0" title="0">{
        // If we already have all the nonces, then this method was called too
        // many times.
        haveAllNonces := len(s.pubNonces) == s.ctx.opts.numSigners
        if haveAllNonces </span><span class="cov0" title="0">{
                return false, ErrAlredyHaveAllNonces
        }</span>

        // Add this nonce and check again if we already have tall the nonces we
        // need.
        <span class="cov0" title="0">s.pubNonces = append(s.pubNonces, nonce)
        haveAllNonces = len(s.pubNonces) == s.ctx.opts.numSigners

        // If we have all the nonces, then we can go ahead and combine them
        // now.
        if haveAllNonces </span><span class="cov0" title="0">{
                combinedNonce, err := AggregateNonces(s.pubNonces)
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>

                <span class="cov0" title="0">s.combinedNonce = &amp;combinedNonce</span>
        }

        <span class="cov0" title="0">return haveAllNonces, nil</span>
}

// Sign generates a partial signature for the target message, using the target
// context. If this method is called more than once per context, then an error
// is returned, as that means a nonce was re-used.
func (s *Session) Sign(msg [32]byte,
        signOpts ...SignOption) (*PartialSignature, error) <span class="cov0" title="0">{

        switch </span>{
        // If no local nonce is present, then this means we already signed, so
        // we'll return an error to prevent nonce re-use.
        case s.localNonces == nil:<span class="cov0" title="0">
                return nil, ErrSigningContextReuse</span>

        // We also need to make sure we have the combined nonce, otherwise this
        // function was called too early.
        case s.combinedNonce == nil:<span class="cov0" title="0">
                return nil, ErrCombinedNonceUnavailable</span>
        }

        <span class="cov0" title="0">switch </span>{
        case s.ctx.opts.bip86Tweak:<span class="cov0" title="0">
                signOpts = append(
                        signOpts, WithBip86SignTweak(),
                )</span>
        case s.ctx.opts.taprootTweak != nil:<span class="cov0" title="0">
                signOpts = append(
                        signOpts, WithTaprootSignTweak(s.ctx.opts.taprootTweak),
                )</span>
        case len(s.ctx.opts.tweaks) != 0:<span class="cov0" title="0">
                signOpts = append(signOpts, WithTweaks(s.ctx.opts.tweaks...))</span>
        }

        <span class="cov0" title="0">partialSig, err := Sign(
                s.localNonces.SecNonce, s.ctx.signingKey, *s.combinedNonce,
                s.ctx.opts.keySet, msg, signOpts...,
        )

        // Now that we've generated our signature, we'll make sure to blank out
        // our signing nonce.
        s.localNonces = nil

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">s.msg = msg

        s.ourSig = partialSig
        s.sigs = append(s.sigs, partialSig)

        return partialSig, nil</span>
}

// CombineSig buffers a partial signature received from a signing party. The
// method returns true once all the signatures are available, and can be
// combined into the final signature.
func (s *Session) CombineSig(sig *PartialSignature) (bool, error) <span class="cov0" title="0">{
        // First check if we already have all the signatures we need. We
        // already accumulated our own signature when we generated the sig.
        haveAllSigs := len(s.sigs) == len(s.ctx.opts.keySet)
        if haveAllSigs </span><span class="cov0" title="0">{
                return false, ErrAlredyHaveAllSigs
        }</span>

        // TODO(roasbeef): incremental check for invalid sig, or just detect at
        // the very end?

        // Accumulate this sig, and check again if we have all the sigs we
        // need.
        <span class="cov0" title="0">s.sigs = append(s.sigs, sig)
        haveAllSigs = len(s.sigs) == len(s.ctx.opts.keySet)

        // If we have all the signatures, then we can combine them all into the
        // final signature.
        if haveAllSigs </span><span class="cov0" title="0">{
                var combineOpts []CombineOption
                switch </span>{
                case s.ctx.opts.bip86Tweak:<span class="cov0" title="0">
                        combineOpts = append(
                                combineOpts, WithBip86TweakedCombine(
                                        s.msg, s.ctx.opts.keySet,
                                        s.ctx.shouldSort,
                                ),
                        )</span>
                case s.ctx.opts.taprootTweak != nil:<span class="cov0" title="0">
                        combineOpts = append(
                                combineOpts, WithTaprootTweakedCombine(
                                        s.msg, s.ctx.opts.keySet,
                                        s.ctx.opts.taprootTweak, s.ctx.shouldSort,
                                ),
                        )</span>
                case len(s.ctx.opts.tweaks) != 0:<span class="cov0" title="0">
                        combineOpts = append(
                                combineOpts, WithTweakedCombine(
                                        s.msg, s.ctx.opts.keySet,
                                        s.ctx.opts.tweaks, s.ctx.shouldSort,
                                ),
                        )</span>
                }

                <span class="cov0" title="0">finalSig := CombineSigs(s.ourSig.R, s.sigs, combineOpts...)

                // We'll also verify the signature at this point to ensure it's
                // valid.
                //
                // TODO(roasbef): allow skipping?
                if !finalSig.Verify(s.msg[:], s.ctx.combinedKey.FinalKey) </span><span class="cov0" title="0">{
                        return false, ErrFinalSigInvalid
                }</span>

                <span class="cov0" title="0">s.finalSig = finalSig</span>
        }

        <span class="cov0" title="0">return haveAllSigs, nil</span>
}

// FinalSig returns the final combined multi-signature, if present.
func (s *Session) FinalSig() *schnorr.Signature <span class="cov0" title="0">{
        return s.finalSig
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">// Copyright 2013-2022 The btcsuite developers

package musig2v040

import (
        "bytes"
        "fmt"
        "sort"

        "github.com/btcsuite/btcd/btcec/v2"
        "github.com/btcsuite/btcd/btcec/v2/schnorr"
        "github.com/btcsuite/btcd/chaincfg/chainhash"
        secp "github.com/decred/dcrd/dcrec/secp256k1/v4"
)

var (
        // KeyAggTagList is the tagged hash tag used to compute the hash of the
        // list of sorted public keys.
        KeyAggTagList = []byte("KeyAgg list")

        // KeyAggTagCoeff is the tagged hash tag used to compute the key
        // aggregation coefficient for each key.
        KeyAggTagCoeff = []byte("KeyAgg coefficient")

        // ErrTweakedKeyIsInfinity is returned if while tweaking a key, we end
        // up with the point at infinity.
        ErrTweakedKeyIsInfinity = fmt.Errorf("tweaked key is infinity point")

        // ErrTweakedKeyOverflows is returned if a tweaking key is larger than
        // 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141.
        ErrTweakedKeyOverflows = fmt.Errorf("tweaked key is to large")
)

// sortableKeys defines a type of slice of public keys that implements the sort
// interface for BIP 340 keys.
type sortableKeys []*btcec.PublicKey

// Less reports whether the element with index i must sort before the element
// with index j.
func (s sortableKeys) Less(i, j int) bool <span class="cov0" title="0">{
        // TODO(roasbeef): more efficient way to compare...
        keyIBytes := schnorr.SerializePubKey(s[i])
        keyJBytes := schnorr.SerializePubKey(s[j])

        return bytes.Compare(keyIBytes, keyJBytes) == -1
}</span>

// Swap swaps the elements with indexes i and j.
func (s sortableKeys) Swap(i, j int) <span class="cov0" title="0">{
        s[i], s[j] = s[j], s[i]
}</span>

// Len is the number of elements in the collection.
func (s sortableKeys) Len() int <span class="cov0" title="0">{
        return len(s)
}</span>

// sortKeys takes a set of schnorr public keys and returns a new slice that is
// a copy of the keys sorted in lexicographical order bytes on the x-only
// pubkey serialization.
func sortKeys(keys []*btcec.PublicKey) []*btcec.PublicKey <span class="cov0" title="0">{
        keySet := sortableKeys(keys)
        if sort.IsSorted(keySet) </span><span class="cov0" title="0">{
                return keys
        }</span>

        <span class="cov0" title="0">sort.Sort(keySet)
        return keySet</span>
}

// keyHashFingerprint computes the tagged hash of the series of (sorted) public
// keys passed as input. This is used to compute the aggregation coefficient
// for each key. The final computation is:
//   - H(tag=KeyAgg list, pk1 || pk2..)
func keyHashFingerprint(keys []*btcec.PublicKey, sort bool) []byte <span class="cov0" title="0">{
        if sort </span><span class="cov0" title="0">{
                keys = sortKeys(keys)
        }</span>

        // We'll create a single buffer and slice into that so the bytes buffer
        // doesn't continually need to grow the underlying buffer.
        <span class="cov0" title="0">keyAggBuf := make([]byte, 32*len(keys))
        keyBytes := bytes.NewBuffer(keyAggBuf[0:0])
        for _, key := range keys </span><span class="cov0" title="0">{
                keyBytes.Write(schnorr.SerializePubKey(key))
        }</span>

        <span class="cov0" title="0">h := chainhash.TaggedHash(KeyAggTagList, keyBytes.Bytes())
        return h[:]</span>
}

// keyBytesEqual returns true if two keys are the same from the PoV of BIP
// 340's 32-byte x-only public keys.
func keyBytesEqual(a, b *btcec.PublicKey) bool <span class="cov0" title="0">{
        return bytes.Equal(
                schnorr.SerializePubKey(a),
                schnorr.SerializePubKey(b),
        )
}</span>

// aggregationCoefficient computes the key aggregation coefficient for the
// specified target key. The coefficient is computed as:
//   - H(tag=KeyAgg coefficient, keyHashFingerprint(pks) || pk)
func aggregationCoefficient(keySet []*btcec.PublicKey,
        targetKey *btcec.PublicKey, keysHash []byte,
        secondKeyIdx int) *btcec.ModNScalar <span class="cov0" title="0">{

        var mu btcec.ModNScalar

        // If this is the second key, then this coefficient is just one.
        if secondKeyIdx != -1 &amp;&amp; keyBytesEqual(keySet[secondKeyIdx], targetKey) </span><span class="cov0" title="0">{
                return mu.SetInt(1)
        }</span>

        // Otherwise, we'll compute the full finger print hash for this given
        // key and then use that to compute the coefficient tagged hash:
        //  * H(tag=KeyAgg coefficient, keyHashFingerprint(pks, pk) || pk)
        <span class="cov0" title="0">var coefficientBytes [64]byte
        copy(coefficientBytes[:], keysHash[:])
        copy(coefficientBytes[32:], schnorr.SerializePubKey(targetKey))

        muHash := chainhash.TaggedHash(KeyAggTagCoeff, coefficientBytes[:])

        mu.SetByteSlice(muHash[:])

        return &amp;mu</span>
}

// secondUniqueKeyIndex returns the index of the second unique key. If all keys
// are the same, then a value of -1 is returned.
func secondUniqueKeyIndex(keySet []*btcec.PublicKey, sort bool) int <span class="cov0" title="0">{
        if sort </span><span class="cov0" title="0">{
                keySet = sortKeys(keySet)
        }</span>

        // Find the first key that isn't the same as the very first key (second
        // unique key).
        <span class="cov0" title="0">for i := range keySet </span><span class="cov0" title="0">{
                if !keyBytesEqual(keySet[i], keySet[0]) </span><span class="cov0" title="0">{
                        return i
                }</span>
        }

        // A value of negative one is used to indicate that all the keys in the
        // sign set are actually equal, which in practice actually makes musig2
        // useless, but we need a value to distinguish this case.
        <span class="cov0" title="0">return -1</span>
}

// KeyTweakDesc describes a tweak to be applied to the aggregated public key
// generation and signing process. The IsXOnly specifies if the target key
// should be converted to an x-only public key before tweaking.
type KeyTweakDesc struct {
        // Tweak is the 32-byte value that will modify the public key.
        Tweak [32]byte

        // IsXOnly if true, then the public key will be mapped to an x-only key
        // before the tweaking operation is applied.
        IsXOnly bool
}

// KeyAggOption is a functional option argument that allows callers to specify
// more or less information that has been pre-computed to the main routine.
type KeyAggOption func(*keyAggOption)

// keyAggOption houses the set of functional options that modify key
// aggregation.
type keyAggOption struct {
        // keyHash is the output of keyHashFingerprint for a given set of keys.
        keyHash []byte

        // uniqueKeyIndex is the pre-computed index of the second unique key.
        uniqueKeyIndex *int

        // tweaks specifies a series of tweaks to be applied to the aggregated
        // public key.
        tweaks []KeyTweakDesc

        // taprootTweak controls if the tweaks above should be applied in a BIP
        // 340 style.
        taprootTweak bool

        // bip86Tweak specifies that the taproot tweak should be done in a BIP
        // 86 style, where we don't expect an actual tweak and instead just
        // commit to the public key itself.
        bip86Tweak bool
}

// WithKeysHash allows key aggregation to be optimize, by allowing the caller
// to specify the hash of all the keys.
func WithKeysHash(keyHash []byte) KeyAggOption <span class="cov0" title="0">{
        return func(o *keyAggOption) </span><span class="cov0" title="0">{
                o.keyHash = keyHash
        }</span>
}

// WithUniqueKeyIndex allows the caller to specify the index of the second
// unique key.
func WithUniqueKeyIndex(idx int) KeyAggOption <span class="cov0" title="0">{
        return func(o *keyAggOption) </span><span class="cov0" title="0">{
                i := idx
                o.uniqueKeyIndex = &amp;i
        }</span>
}

// WithKeyTweaks allows a caller to specify a series of 32-byte tweaks that
// should be applied to the final aggregated public key.
func WithKeyTweaks(tweaks ...KeyTweakDesc) KeyAggOption <span class="cov0" title="0">{
        return func(o *keyAggOption) </span><span class="cov0" title="0">{
                o.tweaks = tweaks
        }</span>
}

// WithTaprootKeyTweak specifies that within this context, the final key should
// use the taproot tweak as defined in BIP 341: outputKey = internalKey +
// h_tapTweak(internalKey || scriptRoot). In this case, the aggregated key
// before the tweak will be used as the internal key.
//
// This option should be used instead of WithKeyTweaks when the aggregated key
// is intended to be used as a taproot output key that commits to a script
// root.
func WithTaprootKeyTweak(scriptRoot []byte) KeyAggOption <span class="cov0" title="0">{
        return func(o *keyAggOption) </span><span class="cov0" title="0">{
                var tweak [32]byte
                copy(tweak[:], scriptRoot[:])

                o.tweaks = []KeyTweakDesc{
                        {
                                Tweak:   tweak,
                                IsXOnly: true,
                        },
                }
                o.taprootTweak = true
        }</span>
}

// WithBIP86KeyTweak specifies that then during key aggregation, the BIP 86
// tweak which just commits to the hash of the serialized public key should be
// used. This option should be used when signing with a key that was derived
// using BIP 86.
func WithBIP86KeyTweak() KeyAggOption <span class="cov0" title="0">{
        return func(o *keyAggOption) </span><span class="cov0" title="0">{
                o.tweaks = []KeyTweakDesc{
                        {
                                IsXOnly: true,
                        },
                }
                o.taprootTweak = true
                o.bip86Tweak = true
        }</span>
}

// defaultKeyAggOptions returns the set of default arguments for key
// aggregation.
func defaultKeyAggOptions() *keyAggOption <span class="cov0" title="0">{
        return &amp;keyAggOption{}
}</span>

// hasEvenY returns true if the affine representation of the passed jacobian
// point has an even y coordinate.
//
// TODO(roasbeef): double check, can just check the y coord even not jacobian?
func hasEvenY(pJ btcec.JacobianPoint) bool <span class="cov0" title="0">{
        pJ.ToAffine()
        p := btcec.NewPublicKey(&amp;pJ.X, &amp;pJ.Y)
        keyBytes := p.SerializeCompressed()
        return keyBytes[0] == secp.PubKeyFormatCompressedEven
}</span>

// tweakKey applies a tweaks to the passed public key using the specified
// tweak. The parityAcc and tweakAcc are returned (in that order) which
// includes the accumulate ration of the parity factor and the tweak multiplied
// by the parity factor. The xOnly bool specifies if this is to be an x-only
// tweak or not.
func tweakKey(keyJ btcec.JacobianPoint, parityAcc btcec.ModNScalar, tweak [32]byte,
        tweakAcc btcec.ModNScalar,
        xOnly bool) (btcec.JacobianPoint, btcec.ModNScalar, btcec.ModNScalar, error) <span class="cov0" title="0">{

        // First we'll compute the new parity factor for this key. If the key has
        // an odd y coordinate (not even), then we'll need to negate it (multiply
        // by -1 mod n, in this case).
        var parityFactor btcec.ModNScalar
        if xOnly &amp;&amp; !hasEvenY(keyJ) </span><span class="cov0" title="0">{
                parityFactor.SetInt(1).Negate()
        }</span> else<span class="cov0" title="0"> {
                parityFactor.SetInt(1)
        }</span>

        // Next, map the tweak into a mod n integer so we can use it for
        // manipulations below.
        <span class="cov0" title="0">tweakInt := new(btcec.ModNScalar)
        overflows := tweakInt.SetBytes(&amp;tweak)
        if overflows == 1 </span><span class="cov0" title="0">{
                return keyJ, parityAcc, tweakAcc, ErrTweakedKeyOverflows
        }</span>

        // Next, we'll compute: Q_i = g*Q + t*G, where g is our parityFactor and t
        // is the tweakInt above. We'll space things out a bit to make it easier to
        // follow.
        //
        // First compute t*G:
        <span class="cov0" title="0">var tweakedGenerator btcec.JacobianPoint
        btcec.ScalarBaseMultNonConst(tweakInt, &amp;tweakedGenerator)

        // Next compute g*Q:
        btcec.ScalarMultNonConst(&amp;parityFactor, &amp;keyJ, &amp;keyJ)

        // Finally add both of them together to get our final
        // tweaked point.
        btcec.AddNonConst(&amp;tweakedGenerator, &amp;keyJ, &amp;keyJ)

        // As a sanity check, make sure that we didn't just end up with the
        // point at infinity.
        if keyJ == infinityPoint </span><span class="cov0" title="0">{
                return keyJ, parityAcc, tweakAcc, ErrTweakedKeyIsInfinity
        }</span>

        // As a final wrap up step, we'll accumulate the parity
        // factor and also this tweak into the final set of accumulators.
        <span class="cov0" title="0">parityAcc.Mul(&amp;parityFactor)
        tweakAcc.Mul(&amp;parityFactor).Add(tweakInt)

        return keyJ, parityAcc, tweakAcc, nil</span>
}

// AggregateKey is a final aggregated key along with a possible version of the
// key without any tweaks applied.
type AggregateKey struct {
        // FinalKey is the final aggregated key which may include one or more
        // tweaks applied to it.
        FinalKey *btcec.PublicKey

        // PreTweakedKey is the aggregated *before* any tweaks have been
        // applied.  This should be used as the internal key in taproot
        // contexts.
        PreTweakedKey *btcec.PublicKey
}

// AggregateKeys takes a list of possibly unsorted keys and returns a single
// aggregated key as specified by the musig2 key aggregation algorithm. A nil
// value can be passed for keyHash, which causes this function to re-derive it.
// In addition to the combined public key, the parity accumulator and the tweak
// accumulator are returned as well.
func AggregateKeys(keys []*btcec.PublicKey, sort bool,
        keyOpts ...KeyAggOption) (
        *AggregateKey, *btcec.ModNScalar, *btcec.ModNScalar, error) <span class="cov0" title="0">{

        // First, parse the set of optional signing options.
        opts := defaultKeyAggOptions()
        for _, option := range keyOpts </span><span class="cov0" title="0">{
                option(opts)
        }</span>

        // Sort the set of public key so we know we're working with them in
        // sorted order for all the routines below.
        <span class="cov0" title="0">if sort </span><span class="cov0" title="0">{
                keys = sortKeys(keys)
        }</span>

        // The caller may provide the hash of all the keys as an optimization
        // during signing, as it already needs to be computed.
        <span class="cov0" title="0">if opts.keyHash == nil </span><span class="cov0" title="0">{
                opts.keyHash = keyHashFingerprint(keys, sort)
        }</span>

        // A caller may also specify the unique key index themselves so we
        // don't need to re-compute it.
        <span class="cov0" title="0">if opts.uniqueKeyIndex == nil </span><span class="cov0" title="0">{
                idx := secondUniqueKeyIndex(keys, sort)
                opts.uniqueKeyIndex = &amp;idx
        }</span>

        // For each key, we'll compute the intermediate blinded key: a_i*P_i,
        // where a_i is the aggregation coefficient for that key, and P_i is
        // the key itself, then accumulate that (addition) into the main final
        // key: P = P_1 + P_2 ... P_N.
        <span class="cov0" title="0">var finalKeyJ btcec.JacobianPoint
        for _, key := range keys </span><span class="cov0" title="0">{
                // Port the key over to Jacobian coordinates as we need it in
                // this format for the routines below.
                var keyJ btcec.JacobianPoint
                key.AsJacobian(&amp;keyJ)

                // Compute the aggregation coefficient for the key, then
                // multiply it by the key itself: P_i' = a_i*P_i.
                var tweakedKeyJ btcec.JacobianPoint
                a := aggregationCoefficient(
                        keys, key, opts.keyHash, *opts.uniqueKeyIndex,
                )
                btcec.ScalarMultNonConst(a, &amp;keyJ, &amp;tweakedKeyJ)

                // Finally accumulate this into the final key in an incremental
                // fashion.
                btcec.AddNonConst(&amp;finalKeyJ, &amp;tweakedKeyJ, &amp;finalKeyJ)
        }</span>

        // We'll copy over the key at this point, since this represents the
        // aggregated key before any tweaks have been applied. This'll be used
        // as the internal key for script path proofs.
        <span class="cov0" title="0">finalKeyJ.ToAffine()
        combinedKey := btcec.NewPublicKey(&amp;finalKeyJ.X, &amp;finalKeyJ.Y)

        // At this point, if this is a taproot tweak, then we'll modify the
        // base tweak value to use the BIP 341 tweak value.
        if opts.taprootTweak </span><span class="cov0" title="0">{
                // Emulate the same behavior as txscript.ComputeTaprootOutputKey
                // which only operates on the x-only public key.
                key, _ := schnorr.ParsePubKey(schnorr.SerializePubKey(
                        combinedKey,
                ))

                // We only use the actual tweak bytes if we're not committing
                // to a BIP-0086 key only spend output. Otherwise, we just
                // commit to the internal key and an empty byte slice as the
                // root hash.
                tweakBytes := []byte{}
                if !opts.bip86Tweak </span><span class="cov0" title="0">{
                        tweakBytes = opts.tweaks[0].Tweak[:]
                }</span>

                // Compute the taproot key tagged hash of:
                // h_tapTweak(internalKey || scriptRoot). We only do this for
                // the first one, as you can only specify a single tweak when
                // using the taproot mode with this API.
                <span class="cov0" title="0">tapTweakHash := chainhash.TaggedHash(
                        chainhash.TagTapTweak, schnorr.SerializePubKey(key),
                        tweakBytes,
                )
                opts.tweaks[0].Tweak = *tapTweakHash</span>
        }

        <span class="cov0" title="0">var (
                err       error
                tweakAcc  btcec.ModNScalar
                parityAcc btcec.ModNScalar
        )
        parityAcc.SetInt(1)

        // In this case we have a set of tweaks, so we'll incrementally apply
        // each one, until we have our final tweaked key, and the related
        // accumulators.
        for i := 1; i &lt;= len(opts.tweaks); i++ </span><span class="cov0" title="0">{
                finalKeyJ, parityAcc, tweakAcc, err = tweakKey(
                        finalKeyJ, parityAcc, opts.tweaks[i-1].Tweak, tweakAcc,
                        opts.tweaks[i-1].IsXOnly,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, nil, err
                }</span>
        }

        <span class="cov0" title="0">finalKeyJ.ToAffine()
        finalKey := btcec.NewPublicKey(&amp;finalKeyJ.X, &amp;finalKeyJ.Y)

        return &amp;AggregateKey{
                PreTweakedKey: combinedKey,
                FinalKey:      finalKey,
        }, &amp;parityAcc, &amp;tweakAcc, nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">// Copyright 2013-2022 The btcsuite developers

package musig2v040

import (
        "bytes"
        "crypto/rand"
        "encoding/binary"
        "io"

        "github.com/btcsuite/btcd/btcec/v2"
        "github.com/btcsuite/btcd/btcec/v2/schnorr"
        "github.com/btcsuite/btcd/chaincfg/chainhash"
)

const (
        // PubNonceSize is the size of the public nonces. Each public nonce is
        // serialized the full compressed encoding, which uses 32 bytes for each
        // nonce.
        PubNonceSize = 66

        // SecNonceSize is the size of the secret nonces for musig2. The secret
        // nonces are the corresponding private keys to the public nonce points.
        SecNonceSize = 64
)

var (
        // NonceAuxTag is the tag used to optionally mix in the secret key with
        // the set of aux randomness.
        NonceAuxTag = []byte("MuSig/aux")

        // NonceGenTag is used to generate the value (from a set of required an
        // optional field) that will be used as the part of the secret nonce.
        NonceGenTag = []byte("MuSig/nonce")

        byteOrder = binary.BigEndian
)

// zeroSecNonce is a secret nonce that's all zeroes. This is used to check that
// we're not attempting to re-use a nonce, and also protect callers from it.
var zeroSecNonce [SecNonceSize]byte

// Nonces holds the public and secret nonces required for musig2.
//
// TODO(roasbeef): methods on this to help w/ parsing, etc?
type Nonces struct {
        // PubNonce holds the two 33-byte compressed encoded points that serve
        // as the public set of nonces.
        PubNonce [PubNonceSize]byte

        // SecNonce holds the two 32-byte scalar values that are the private
        // keys to the two public nonces.
        SecNonce [SecNonceSize]byte
}

// secNonceToPubNonce takes our two secrete nonces, and produces their two
// corresponding EC points, serialized in compressed format.
func secNonceToPubNonce(secNonce [SecNonceSize]byte) [PubNonceSize]byte <span class="cov0" title="0">{
        var k1Mod, k2Mod btcec.ModNScalar
        k1Mod.SetByteSlice(secNonce[:btcec.PrivKeyBytesLen])
        k2Mod.SetByteSlice(secNonce[btcec.PrivKeyBytesLen:])

        var r1, r2 btcec.JacobianPoint
        btcec.ScalarBaseMultNonConst(&amp;k1Mod, &amp;r1)
        btcec.ScalarBaseMultNonConst(&amp;k2Mod, &amp;r2)

        // Next, we'll convert the key in jacobian format to a normal public
        // key expressed in affine coordinates.
        r1.ToAffine()
        r2.ToAffine()
        r1Pub := btcec.NewPublicKey(&amp;r1.X, &amp;r1.Y)
        r2Pub := btcec.NewPublicKey(&amp;r2.X, &amp;r2.Y)

        var pubNonce [PubNonceSize]byte

        // The public nonces are serialized as: R1 || R2, where both keys are
        // serialized in compressed format.
        copy(pubNonce[:], r1Pub.SerializeCompressed())
        copy(
                pubNonce[btcec.PubKeyBytesLenCompressed:],
                r2Pub.SerializeCompressed(),
        )

        return pubNonce
}</span>

// NonceGenOption is a function option that allows callers to modify how nonce
// generation happens.
type NonceGenOption func(*nonceGenOpts)

// nonceGenOpts is the set of options that control how nonce generation
// happens.
type nonceGenOpts struct {
        // randReader is what we'll use to generate a set of random bytes. If
        // unspecified, then the normal crypto/rand rand.Read method will be
        // used in place.
        randReader io.Reader

        // secretKey is an optional argument that's used to further augment the
        // generated nonce by xor'ing it with this secret key.
        secretKey []byte

        // combinedKey is an optional argument that if specified, will be
        // combined along with the nonce generation.
        combinedKey []byte

        // msg is an optional argument that will be mixed into the nonce
        // derivation algorithm.
        msg []byte

        // auxInput is an optional argument that will be mixed into the nonce
        // derivation algorithm.
        auxInput []byte
}

// cryptoRandAdapter is an adapter struct that allows us to pass in the package
// level Read function from crypto/rand into a context that accepts an
// io.Reader.
type cryptoRandAdapter struct {
}

// Read implements the io.Reader interface for the crypto/rand package.  By
// default, we always use the crypto/rand reader, but the caller is able to
// specify their own generation, which can be useful for deterministic tests.
func (c *cryptoRandAdapter) Read(p []byte) (n int, err error) <span class="cov0" title="0">{
        return rand.Read(p)
}</span>

// defaultNonceGenOpts returns the default set of nonce generation options.
func defaultNonceGenOpts() *nonceGenOpts <span class="cov0" title="0">{
        return &amp;nonceGenOpts{
                randReader: &amp;cryptoRandAdapter{},
        }
}</span>

// WithCustomRand allows a caller to use a custom random number generator in
// place for crypto/rand. This should only really be used to generate
// determinstic tests.
func WithCustomRand(r io.Reader) NonceGenOption <span class="cov0" title="0">{
        return func(o *nonceGenOpts) </span><span class="cov0" title="0">{
                o.randReader = r
        }</span>
}

// WithNonceSecretKeyAux allows a caller to optionally specify a secret key
// that should be used to augment the randomness used to generate the nonces.
func WithNonceSecretKeyAux(secKey *btcec.PrivateKey) NonceGenOption <span class="cov0" title="0">{
        return func(o *nonceGenOpts) </span><span class="cov0" title="0">{
                o.secretKey = secKey.Serialize()
        }</span>
}

// WithNonceCombinedKeyAux allows a caller to optionally specify the combined
// key used in this signing session to further augment the randomness used to
// generate nonces.
func WithNonceCombinedKeyAux(combinedKey *btcec.PublicKey) NonceGenOption <span class="cov0" title="0">{
        return func(o *nonceGenOpts) </span><span class="cov0" title="0">{
                o.combinedKey = schnorr.SerializePubKey(combinedKey)
        }</span>
}

// WithNonceMessageAux allows a caller to optionally specify a message to be
// mixed into the randomness generated to create the nonce.
func WithNonceMessageAux(msg [32]byte) NonceGenOption <span class="cov0" title="0">{
        return func(o *nonceGenOpts) </span><span class="cov0" title="0">{
                o.msg = msg[:]
        }</span>
}

// WithNonceAuxInput is a set of auxiliary randomness, similar to BIP 340 that
// can be used to further augment the nonce generation process.
func WithNonceAuxInput(aux []byte) NonceGenOption <span class="cov0" title="0">{
        return func(o *nonceGenOpts) </span><span class="cov0" title="0">{
                o.auxInput = aux
        }</span>
}

// withCustomOptions allows a caller to pass a complete set of custom
// nonceGenOpts, without needing to create custom and checked structs such as
// *btcec.PrivateKey. This is mainly used to match the testcases provided by
// the MuSig2 BIP.
func withCustomOptions(customOpts nonceGenOpts) NonceGenOption <span class="cov0" title="0">{
        return func(o *nonceGenOpts) </span><span class="cov0" title="0">{
                o.randReader = customOpts.randReader
                o.secretKey = customOpts.secretKey
                o.combinedKey = customOpts.combinedKey
                o.msg = customOpts.msg
                o.auxInput = customOpts.auxInput
        }</span>
}

// lengthWriter is a function closure that allows a caller to control how the
// length prefix of a byte slice is written.
type lengthWriter func(w io.Writer, b []byte) error

// uint8Writer is an implementation of lengthWriter that writes the length of
// the byte slice using 1 byte.
func uint8Writer(w io.Writer, b []byte) error <span class="cov0" title="0">{
        return binary.Write(w, byteOrder, uint8(len(b)))
}</span>

// uint32Writer is an implementation of lengthWriter that writes the length of
// the byte slice using 4 bytes.
func uint32Writer(w io.Writer, b []byte) error <span class="cov0" title="0">{
        return binary.Write(w, byteOrder, uint32(len(b)))
}</span>

// writeBytesPrefix is used to write out: len(b) || b, to the passed io.Writer.
// The lengthWriter function closure is used to allow the caller to specify the
// precise byte packing of the length.
func writeBytesPrefix(w io.Writer, b []byte, lenWriter lengthWriter) error <span class="cov0" title="0">{
        // Write out the length of the byte first, followed by the set of bytes
        // itself.
        if err := lenWriter(w, b); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if _, err := w.Write(b); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// genNonceAuxBytes writes out the full byte string used to derive a secret
// nonce based on some initial randomness as well as the series of optional
// fields. The byte string used for derivation is:
//   - tagged_hash("MuSig/nonce", rand || len(aggpk) || aggpk || len(m)
//     || m || len(in) || in || i).
//
// where i is the ith secret nonce being generated.
func genNonceAuxBytes(rand []byte, i int,
        opts *nonceGenOpts) (*chainhash.Hash, error) <span class="cov0" title="0">{

        var w bytes.Buffer

        // First, write out the randomness generated in the prior step.
        if _, err := w.Write(rand); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Next, we'll write out: len(aggpk) || aggpk.
        <span class="cov0" title="0">err := writeBytesPrefix(&amp;w, opts.combinedKey, uint8Writer)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Next, we'll write out the length prefixed message.
        <span class="cov0" title="0">err = writeBytesPrefix(&amp;w, opts.msg, uint8Writer)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Finally we'll write out the auxiliary input.
        <span class="cov0" title="0">err = writeBytesPrefix(&amp;w, opts.auxInput, uint32Writer)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Next we'll write out the interaction/index number which will
        // uniquely generate two nonces given the rest of the possibly static
        // parameters.
        <span class="cov0" title="0">if err := binary.Write(&amp;w, byteOrder, uint8(i)); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // With the message buffer complete, we'll now derive the tagged hash
        // using our set of params.
        <span class="cov0" title="0">return chainhash.TaggedHash(NonceGenTag, w.Bytes()), nil</span>
}

// GenNonces generates the secret nonces, as well as the public nonces which
// correspond to an EC point generated using the secret nonce as a private key.
func GenNonces(options ...NonceGenOption) (*Nonces, error) <span class="cov0" title="0">{
        opts := defaultNonceGenOpts()
        for _, opt := range options </span><span class="cov0" title="0">{
                opt(opts)
        }</span>

        // First, we'll start out by generating 32 random bytes drawn from our
        // CSPRNG.
        <span class="cov0" title="0">var randBytes [32]byte
        if _, err := opts.randReader.Read(randBytes[:]); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // If the options contain a secret key, we XOR it with with the tagged
        // random bytes.
        <span class="cov0" title="0">if len(opts.secretKey) == 32 </span><span class="cov0" title="0">{
                taggedHash := chainhash.TaggedHash(NonceAuxTag, randBytes[:])

                for i := 0; i &lt; chainhash.HashSize; i++ </span><span class="cov0" title="0">{
                        randBytes[i] = opts.secretKey[i] ^ taggedHash[i]
                }</span>
        }

        // Using our randomness and the set of optional params, generate our
        // two secret nonces: k1 and k2.
        <span class="cov0" title="0">k1, err := genNonceAuxBytes(randBytes[:], 0, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">k2, err := genNonceAuxBytes(randBytes[:], 1, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var k1Mod, k2Mod btcec.ModNScalar
        k1Mod.SetBytes((*[32]byte)(k1))
        k2Mod.SetBytes((*[32]byte)(k2))

        // The secret nonces are serialized as the concatenation of the two 32
        // byte secret nonce values.
        var nonces Nonces
        k1Mod.PutBytesUnchecked(nonces.SecNonce[:])
        k2Mod.PutBytesUnchecked(nonces.SecNonce[btcec.PrivKeyBytesLen:])

        // Next, we'll generate R_1 = k_1*G and R_2 = k_2*G. Along the way we
        // need to map our nonce values into mod n scalars so we can work with
        // the btcec API.
        nonces.PubNonce = secNonceToPubNonce(nonces.SecNonce)

        return &amp;nonces, nil</span>
}

// AggregateNonces aggregates the set of a pair of public nonces for each party
// into a single aggregated nonces to be used for multi-signing.
func AggregateNonces(pubNonces [][PubNonceSize]byte) ([PubNonceSize]byte, error) <span class="cov0" title="0">{
        // combineNonces is a helper function that aggregates (adds) up a
        // series of nonces encoded in compressed format. It uses a slicing
        // function to extra 33 bytes at a time from the packed 2x public
        // nonces.
        type nonceSlicer func([PubNonceSize]byte) []byte
        combineNonces := func(slicer nonceSlicer) (btcec.JacobianPoint, error) </span><span class="cov0" title="0">{
                // Convert the set of nonces into jacobian coordinates we can
                // use to accumulate them all into each other.
                pubNonceJs := make([]*btcec.JacobianPoint, len(pubNonces))
                for i, pubNonceBytes := range pubNonces </span><span class="cov0" title="0">{
                        // Using the slicer, extract just the bytes we need to
                        // decode.
                        var nonceJ btcec.JacobianPoint

                        nonceJ, err := btcec.ParseJacobian(slicer(pubNonceBytes))
                        if err != nil </span><span class="cov0" title="0">{
                                return btcec.JacobianPoint{}, err
                        }</span>

                        <span class="cov0" title="0">pubNonceJs[i] = &amp;nonceJ</span>
                }

                // Now that we have the set of complete nonces, we'll aggregate
                // them: R = R_i + R_i+1 + ... + R_i+n.
                <span class="cov0" title="0">var aggregateNonce btcec.JacobianPoint
                for _, pubNonceJ := range pubNonceJs </span><span class="cov0" title="0">{
                        btcec.AddNonConst(
                                &amp;aggregateNonce, pubNonceJ, &amp;aggregateNonce,
                        )
                }</span>

                <span class="cov0" title="0">aggregateNonce.ToAffine()
                return aggregateNonce, nil</span>
        }

        // The final nonce public nonce is actually two nonces, one that
        // aggregate the first nonce of all the parties, and the other that
        // aggregates the second nonce of all the parties.
        <span class="cov0" title="0">var finalNonce [PubNonceSize]byte
        combinedNonce1, err := combineNonces(func(n [PubNonceSize]byte) []byte </span><span class="cov0" title="0">{
                return n[:btcec.PubKeyBytesLenCompressed]
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return finalNonce, err
        }</span>

        <span class="cov0" title="0">combinedNonce2, err := combineNonces(func(n [PubNonceSize]byte) []byte </span><span class="cov0" title="0">{
                return n[btcec.PubKeyBytesLenCompressed:]
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return finalNonce, err
        }</span>

        <span class="cov0" title="0">copy(finalNonce[:], btcec.JacobianToByteSlice(combinedNonce1))
        copy(
                finalNonce[btcec.PubKeyBytesLenCompressed:],
                btcec.JacobianToByteSlice(combinedNonce2),
        )

        return finalNonce, nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">// Copyright 2013-2022 The btcsuite developers

package musig2v040

import (
        "bytes"
        "fmt"
        "io"

        "github.com/btcsuite/btcd/btcec/v2"
        "github.com/btcsuite/btcd/btcec/v2/schnorr"
        "github.com/btcsuite/btcd/chaincfg/chainhash"
        secp "github.com/decred/dcrd/dcrec/secp256k1/v4"
)

var (
        // NonceBlindTag is that tag used to construct the value b, which
        // blinds the second public nonce of each party.
        NonceBlindTag = []byte("MuSig/noncecoef")

        // ChallengeHashTag is the tag used to construct the challenge hash
        ChallengeHashTag = []byte("BIP0340/challenge")

        // ErrNoncePointAtInfinity is returned if during signing, the fully
        // combined public nonce is the point at infinity.
        ErrNoncePointAtInfinity = fmt.Errorf("signing nonce is the infinity " +
                "point")

        // ErrPrivKeyZero is returned when the private key for signing is
        // actually zero.
        ErrPrivKeyZero = fmt.Errorf("priv key is zero")

        // ErrPartialSigInvalid is returned when a partial is found to be
        // invalid.
        ErrPartialSigInvalid = fmt.Errorf("partial signature is invalid")

        // ErrSecretNonceZero is returned when a secret nonce is passed in a
        // zero.
        ErrSecretNonceZero = fmt.Errorf("secret nonce is blank")
)

// infinityPoint is the jacobian representation of the point at infinity.
var infinityPoint btcec.JacobianPoint

// PartialSignature reprints a partial (s-only) musig2 multi-signature. This
// isn't a valid schnorr signature by itself, as it needs to be aggregated
// along with the other partial signatures to be completed.
type PartialSignature struct {
        S *btcec.ModNScalar

        R *btcec.PublicKey
}

// NewPartialSignature returns a new instances of the partial sig struct.
func NewPartialSignature(s *btcec.ModNScalar,
        r *btcec.PublicKey) PartialSignature <span class="cov0" title="0">{

        return PartialSignature{
                S: s,
                R: r,
        }
}</span>

// Encode writes a serialized version of the partial signature to the passed
// io.Writer
func (p *PartialSignature) Encode(w io.Writer) error <span class="cov0" title="0">{
        var sBytes [32]byte
        p.S.PutBytes(&amp;sBytes)

        if _, err := w.Write(sBytes[:]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Decode attempts to parse a serialized PartialSignature stored in the passed
// io reader.
func (p *PartialSignature) Decode(r io.Reader) error <span class="cov0" title="0">{
        p.S = new(btcec.ModNScalar)

        var sBytes [32]byte
        if _, err := io.ReadFull(r, sBytes[:]); err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">overflows := p.S.SetBytes(&amp;sBytes)
        if overflows == 1 </span><span class="cov0" title="0">{
                return ErrPartialSigInvalid
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// SignOption is a functional option argument that allows callers to modify the
// way we generate musig2 schnorr signatures.
type SignOption func(*signOptions)

// signOptions houses the set of functional options that can be used to modify
// the method used to generate the musig2 partial signature.
type signOptions struct {
        // fastSign determines if we'll skip the check at the end of the
        // routine where we attempt to verify the produced signature.
        fastSign bool

        // sortKeys determines if the set of keys should be sorted before doing
        // key aggregation.
        sortKeys bool

        // tweaks specifies a series of tweaks to be applied to the aggregated
        // public key, which also partially carries over into the signing
        // process.
        tweaks []KeyTweakDesc

        // taprootTweak specifies a taproot specific tweak.  of the tweaks
        // specified above. Normally we'd just apply the raw 32 byte tweak, but
        // for taproot, we first need to compute the aggregated key before
        // tweaking, and then use it as the internal key. This is required as
        // the taproot tweak also commits to the public key, which in this case
        // is the aggregated key before the tweak.
        taprootTweak []byte

        // bip86Tweak specifies that the taproot tweak should be done in a BIP
        // 86 style, where we don't expect an actual tweak and instead just
        // commit to the public key itself.
        bip86Tweak bool
}

// defaultSignOptions returns the default set of signing operations.
func defaultSignOptions() *signOptions <span class="cov0" title="0">{
        return &amp;signOptions{}
}</span>

// WithFastSign forces signing to skip the extra verification step at the end.
// Performance sensitive applications may opt to use this option to speed up
// the signing operation.
func WithFastSign() SignOption <span class="cov0" title="0">{
        return func(o *signOptions) </span><span class="cov0" title="0">{
                o.fastSign = true
        }</span>
}

// WithSortedKeys determines if the set of signing public keys are to be sorted
// or not before doing key aggregation.
func WithSortedKeys() SignOption <span class="cov0" title="0">{
        return func(o *signOptions) </span><span class="cov0" title="0">{
                o.sortKeys = true
        }</span>
}

// WithTweaks determines if the aggregated public key used should apply a
// series of tweaks before key aggregation.
func WithTweaks(tweaks ...KeyTweakDesc) SignOption <span class="cov0" title="0">{
        return func(o *signOptions) </span><span class="cov0" title="0">{
                o.tweaks = tweaks
        }</span>
}

// WithTaprootSignTweak allows a caller to specify a tweak that should be used
// in a bip 340 manner when signing. This differs from WithTweaks as the tweak
// will be assumed to always be x-only and the intermediate aggregate key
// before tweaking will be used to generate part of the tweak (as the taproot
// tweak also commits to the internal key).
//
// This option should be used in the taproot context to create a valid
// signature for the keypath spend for taproot, when the output key is actually
// committing to a script path, or some other data.
func WithTaprootSignTweak(scriptRoot []byte) SignOption <span class="cov0" title="0">{
        return func(o *signOptions) </span><span class="cov0" title="0">{
                o.taprootTweak = scriptRoot
        }</span>
}

// WithBip86SignTweak allows a caller to specify a tweak that should be used in
// a bip 340 manner when signing, factoring in BIP 86 as well. This differs
// from WithTaprootSignTweak as no true script root will be committed to,
// instead we just commit to the internal key.
//
// This option should be used in the taproot context to create a valid
// signature for the keypath spend for taproot, when the output key was
// generated using BIP 86.
func WithBip86SignTweak() SignOption <span class="cov0" title="0">{
        return func(o *signOptions) </span><span class="cov0" title="0">{
                o.bip86Tweak = true
        }</span>
}

// Sign generates a musig2 partial signature given the passed key set, secret
// nonce, public nonce, and private keys. This method returns an error if the
// generated nonces are either too large, or end up mapping to the point at
// infinity.
func Sign(secNonce [SecNonceSize]byte, privKey *btcec.PrivateKey,
        combinedNonce [PubNonceSize]byte, pubKeys []*btcec.PublicKey,
        msg [32]byte, signOpts ...SignOption) (*PartialSignature, error) <span class="cov0" title="0">{

        // First, parse the set of optional signing options.
        opts := defaultSignOptions()
        for _, option := range signOpts </span><span class="cov0" title="0">{
                option(opts)
        }</span>

        // Compute the hash of all the keys here as we'll need it do aggregate
        // the keys and also at the final step of signing.
        <span class="cov0" title="0">keysHash := keyHashFingerprint(pubKeys, opts.sortKeys)
        uniqueKeyIndex := secondUniqueKeyIndex(pubKeys, opts.sortKeys)

        keyAggOpts := []KeyAggOption{
                WithKeysHash(keysHash), WithUniqueKeyIndex(uniqueKeyIndex),
        }
        switch </span>{
        case opts.bip86Tweak:<span class="cov0" title="0">
                keyAggOpts = append(
                        keyAggOpts, WithBIP86KeyTweak(),
                )</span>
        case opts.taprootTweak != nil:<span class="cov0" title="0">
                keyAggOpts = append(
                        keyAggOpts, WithTaprootKeyTweak(opts.taprootTweak),
                )</span>
        case len(opts.tweaks) != 0:<span class="cov0" title="0">
                keyAggOpts = append(keyAggOpts, WithKeyTweaks(opts.tweaks...))</span>
        }

        // Next we'll construct the aggregated public key based on the set of
        // signers.
        <span class="cov0" title="0">combinedKey, parityAcc, _, err := AggregateKeys(
                pubKeys, opts.sortKeys, keyAggOpts...,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Next we'll compute the value b, that blinds our second public
        // nonce:
        //  * b = h(tag=NonceBlindTag, combinedNonce || combinedKey || m).
        <span class="cov0" title="0">var (
                nonceMsgBuf  bytes.Buffer
                nonceBlinder btcec.ModNScalar
        )
        nonceMsgBuf.Write(combinedNonce[:])
        nonceMsgBuf.Write(schnorr.SerializePubKey(combinedKey.FinalKey))
        nonceMsgBuf.Write(msg[:])
        nonceBlindHash := chainhash.TaggedHash(
                NonceBlindTag, nonceMsgBuf.Bytes(),
        )
        nonceBlinder.SetByteSlice(nonceBlindHash[:])

        // Next, we'll parse the public nonces into R1 and R2.
        r1J, err := btcec.ParseJacobian(
                combinedNonce[:btcec.PubKeyBytesLenCompressed],
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">r2J, err := btcec.ParseJacobian(
                combinedNonce[btcec.PubKeyBytesLenCompressed:],
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // With our nonce blinding value, we'll now combine both the public
        // nonces, using the blinding factor to tweak the second nonce:
        //  * R = R_1 + b*R_2
        <span class="cov0" title="0">var nonce btcec.JacobianPoint
        btcec.ScalarMultNonConst(&amp;nonceBlinder, &amp;r2J, &amp;r2J)
        btcec.AddNonConst(&amp;r1J, &amp;r2J, &amp;nonce)

        // If the combined nonce it eh point at infinity, then we'll bail out.
        if nonce == infinityPoint </span><span class="cov0" title="0">{
                G := btcec.Generator()
                G.AsJacobian(&amp;nonce)
        }</span>

        // Next we'll parse out our two secret nonces, which we'll be using in
        // the core signing process below.
        <span class="cov0" title="0">var k1, k2 btcec.ModNScalar
        k1.SetByteSlice(secNonce[:btcec.PrivKeyBytesLen])
        k2.SetByteSlice(secNonce[btcec.PrivKeyBytesLen:])

        if k1.IsZero() || k2.IsZero() </span><span class="cov0" title="0">{
                return nil, ErrSecretNonceZero
        }</span>

        <span class="cov0" title="0">nonce.ToAffine()

        nonceKey := btcec.NewPublicKey(&amp;nonce.X, &amp;nonce.Y)

        // If the nonce R has an odd y coordinate, then we'll negate both our
        // secret nonces.
        if nonce.Y.IsOdd() </span><span class="cov0" title="0">{
                k1.Negate()
                k2.Negate()
        }</span>

        <span class="cov0" title="0">privKeyScalar := privKey.Key
        if privKeyScalar.IsZero() </span><span class="cov0" title="0">{
                return nil, ErrPrivKeyZero
        }</span>

        <span class="cov0" title="0">pubKey := privKey.PubKey()
        pubKeyYIsOdd := func() bool </span><span class="cov0" title="0">{
                pubKeyBytes := pubKey.SerializeCompressed()
                return pubKeyBytes[0] == secp.PubKeyFormatCompressedOdd
        }</span>()
        <span class="cov0" title="0">combinedKeyYIsOdd := func() bool </span><span class="cov0" title="0">{
                combinedKeyBytes := combinedKey.FinalKey.SerializeCompressed()
                return combinedKeyBytes[0] == secp.PubKeyFormatCompressedOdd
        }</span>()

        // Next we'll compute our two parity factors for Q the combined public
        // key, and P, the public key we're signing with. If the keys are odd,
        // then we'll negate them.
        <span class="cov0" title="0">parityCombinedKey := new(btcec.ModNScalar).SetInt(1)
        paritySignKey := new(btcec.ModNScalar).SetInt(1)
        if combinedKeyYIsOdd </span><span class="cov0" title="0">{
                parityCombinedKey.Negate()
        }</span>
        <span class="cov0" title="0">if pubKeyYIsOdd </span><span class="cov0" title="0">{
                paritySignKey.Negate()
        }</span>

        // Before we sign below, we'll multiply by our various parity factors
        // to ensure that the signing key is properly negated (if necessary):
        //  * d = gvgaccvgpd'
        <span class="cov0" title="0">privKeyScalar.Mul(parityCombinedKey).Mul(paritySignKey).Mul(parityAcc)

        // Next we'll create the challenge hash that commits to the combined
        // nonce, combined public key and also the message:
        // * e = H(tag=ChallengeHashTag, R || Q || m) mod n
        var challengeMsg bytes.Buffer
        challengeMsg.Write(schnorr.SerializePubKey(nonceKey))
        challengeMsg.Write(schnorr.SerializePubKey(combinedKey.FinalKey))
        challengeMsg.Write(msg[:])
        challengeBytes := chainhash.TaggedHash(
                ChallengeHashTag, challengeMsg.Bytes(),
        )
        var e btcec.ModNScalar
        e.SetByteSlice(challengeBytes[:])

        // Next, we'll compute a, our aggregation coefficient for the key that
        // we're signing with.
        a := aggregationCoefficient(pubKeys, pubKey, keysHash, uniqueKeyIndex)

        // With mu constructed, we can finally generate our partial signature
        // as: s = (k1_1 + b*k_2 + e*a*d) mod n.
        s := new(btcec.ModNScalar)
        s.Add(&amp;k1).Add(k2.Mul(&amp;nonceBlinder)).Add(e.Mul(a).Mul(&amp;privKeyScalar))

        sig := NewPartialSignature(s, nonceKey)

        // If we're not in fast sign mode, then we'll also validate our partial
        // signature.
        if !opts.fastSign </span><span class="cov0" title="0">{
                pubNonce := secNonceToPubNonce(secNonce)
                sigValid := sig.Verify(
                        pubNonce, combinedNonce, pubKeys, pubKey, msg,
                        signOpts...,
                )
                if !sigValid </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("sig is invalid!")
                }</span>
        }

        <span class="cov0" title="0">return &amp;sig, nil</span>
}

// Verify implements partial signature verification given the public nonce for
// the signer, aggregate nonce, signer set and finally the message being
// signed.
func (p *PartialSignature) Verify(pubNonce [PubNonceSize]byte,
        combinedNonce [PubNonceSize]byte, keySet []*btcec.PublicKey,
        signingKey *btcec.PublicKey, msg [32]byte, signOpts ...SignOption) bool <span class="cov0" title="0">{

        pubKey := schnorr.SerializePubKey(signingKey)

        return verifyPartialSig(
                p, pubNonce, combinedNonce, keySet, pubKey, msg, signOpts...,
        ) == nil
}</span>

// verifyPartialSig attempts to verify a partial schnorr signature given the
// necessary parameters. This is the internal version of Verify that returns
// detailed errors.  signed.
func verifyPartialSig(partialSig *PartialSignature, pubNonce [PubNonceSize]byte,
        combinedNonce [PubNonceSize]byte, keySet []*btcec.PublicKey,
        pubKey []byte, msg [32]byte, signOpts ...SignOption) error <span class="cov0" title="0">{

        opts := defaultSignOptions()
        for _, option := range signOpts </span><span class="cov0" title="0">{
                option(opts)
        }</span>

        // First we'll map the internal partial signature back into something
        // we can manipulate.
        <span class="cov0" title="0">s := partialSig.S

        // Next we'll parse out the two public nonces into something we can
        // use.
        //

        // Compute the hash of all the keys here as we'll need it do aggregate
        // the keys and also at the final step of verification.
        keysHash := keyHashFingerprint(keySet, opts.sortKeys)
        uniqueKeyIndex := secondUniqueKeyIndex(keySet, opts.sortKeys)

        keyAggOpts := []KeyAggOption{
                WithKeysHash(keysHash), WithUniqueKeyIndex(uniqueKeyIndex),
        }
        switch </span>{
        case opts.bip86Tweak:<span class="cov0" title="0">
                keyAggOpts = append(
                        keyAggOpts, WithBIP86KeyTweak(),
                )</span>
        case opts.taprootTweak != nil:<span class="cov0" title="0">
                keyAggOpts = append(
                        keyAggOpts, WithTaprootKeyTweak(opts.taprootTweak),
                )</span>
        case len(opts.tweaks) != 0:<span class="cov0" title="0">
                keyAggOpts = append(keyAggOpts, WithKeyTweaks(opts.tweaks...))</span>
        }

        // Next we'll construct the aggregated public key based on the set of
        // signers.
        <span class="cov0" title="0">combinedKey, parityAcc, _, err := AggregateKeys(
                keySet, opts.sortKeys, keyAggOpts...,
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Next we'll compute the value b, that blinds our second public
        // nonce:
        //  * b = h(tag=NonceBlindTag, combinedNonce || combinedKey || m).
        <span class="cov0" title="0">var (
                nonceMsgBuf  bytes.Buffer
                nonceBlinder btcec.ModNScalar
        )
        nonceMsgBuf.Write(combinedNonce[:])
        nonceMsgBuf.Write(schnorr.SerializePubKey(combinedKey.FinalKey))
        nonceMsgBuf.Write(msg[:])
        nonceBlindHash := chainhash.TaggedHash(NonceBlindTag, nonceMsgBuf.Bytes())
        nonceBlinder.SetByteSlice(nonceBlindHash[:])

        r1J, err := btcec.ParseJacobian(
                combinedNonce[:btcec.PubKeyBytesLenCompressed],
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">r2J, err := btcec.ParseJacobian(
                combinedNonce[btcec.PubKeyBytesLenCompressed:],
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // With our nonce blinding value, we'll now combine both the public
        // nonces, using the blinding factor to tweak the second nonce:
        //  * R = R_1 + b*R_2

        <span class="cov0" title="0">var nonce btcec.JacobianPoint
        btcec.ScalarMultNonConst(&amp;nonceBlinder, &amp;r2J, &amp;r2J)
        btcec.AddNonConst(&amp;r1J, &amp;r2J, &amp;nonce)

        // Next, we'll parse out the set of public nonces this signer used to
        // generate the signature.
        pubNonce1J, err := btcec.ParseJacobian(
                pubNonce[:btcec.PubKeyBytesLenCompressed],
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">pubNonce2J, err := btcec.ParseJacobian(
                pubNonce[btcec.PubKeyBytesLenCompressed:],
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // If the nonce is the infinity point we set it to the Generator.
        <span class="cov0" title="0">if nonce == infinityPoint </span><span class="cov0" title="0">{
                btcec.GeneratorJacobian(&amp;nonce)
        }</span> else<span class="cov0" title="0"> {
                nonce.ToAffine()
        }</span>

        // We'll perform a similar aggregation and blinding operator as we did
        // above for the combined nonces: R' = R_1' + b*R_2'.
        <span class="cov0" title="0">var pubNonceJ btcec.JacobianPoint

        btcec.ScalarMultNonConst(&amp;nonceBlinder, &amp;pubNonce2J, &amp;pubNonce2J)
        btcec.AddNonConst(&amp;pubNonce1J, &amp;pubNonce2J, &amp;pubNonceJ)

        pubNonceJ.ToAffine()

        // If the combined nonce used in the challenge hash has an odd y
        // coordinate, then we'll negate our final public nonce.
        if nonce.Y.IsOdd() </span><span class="cov0" title="0">{
                pubNonceJ.Y.Negate(1)
                pubNonceJ.Y.Normalize()
        }</span>

        // Next we'll create the challenge hash that commits to the combined
        // nonce, combined public key and also the message:
        //  * e = H(tag=ChallengeHashTag, R || Q || m) mod n
        <span class="cov0" title="0">var challengeMsg bytes.Buffer
        challengeMsg.Write(schnorr.SerializePubKey(btcec.NewPublicKey(
                &amp;nonce.X, &amp;nonce.Y,
        )))
        challengeMsg.Write(schnorr.SerializePubKey(combinedKey.FinalKey))
        challengeMsg.Write(msg[:])
        challengeBytes := chainhash.TaggedHash(
                ChallengeHashTag, challengeMsg.Bytes(),
        )
        var e btcec.ModNScalar
        e.SetByteSlice(challengeBytes[:])

        signingKey, err := schnorr.ParsePubKey(pubKey)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Next, we'll compute a, our aggregation coefficient for the key that
        // we're signing with.
        <span class="cov0" title="0">a := aggregationCoefficient(keySet, signingKey, keysHash, uniqueKeyIndex)

        // If the combined key has an odd y coordinate, then we'll negate
        // parity factor for the signing key.
        paritySignKey := new(btcec.ModNScalar).SetInt(1)
        combinedKeyBytes := combinedKey.FinalKey.SerializeCompressed()
        if combinedKeyBytes[0] == secp.PubKeyFormatCompressedOdd </span><span class="cov0" title="0">{
                paritySignKey.Negate()
        }</span>

        // Next, we'll construct the final parity factor by multiplying the
        // sign key parity factor with the accumulated parity factor for all
        // the keys.
        <span class="cov0" title="0">finalParityFactor := paritySignKey.Mul(parityAcc)

        // Now we'll multiply the parity factor by our signing key, which'll
        // take care of the amount of negation needed.
        var signKeyJ btcec.JacobianPoint
        signingKey.AsJacobian(&amp;signKeyJ)
        btcec.ScalarMultNonConst(finalParityFactor, &amp;signKeyJ, &amp;signKeyJ)

        // In the final set, we'll check that: s*G == R' + e*a*P.
        var sG, rP btcec.JacobianPoint
        btcec.ScalarBaseMultNonConst(s, &amp;sG)
        btcec.ScalarMultNonConst(e.Mul(a), &amp;signKeyJ, &amp;rP)
        btcec.AddNonConst(&amp;rP, &amp;pubNonceJ, &amp;rP)

        sG.ToAffine()
        rP.ToAffine()

        if sG != rP </span><span class="cov0" title="0">{
                return ErrPartialSigInvalid
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// CombineOption is a functional option argument that allows callers to modify the
// way we combine musig2 schnorr signatures.
type CombineOption func(*combineOptions)

// combineOptions houses the set of functional options that can be used to
// modify the method used to combine the musig2 partial signatures.
type combineOptions struct {
        msg [32]byte

        combinedKey *btcec.PublicKey

        tweakAcc *btcec.ModNScalar
}

// defaultCombineOptions returns the default set of signing operations.
func defaultCombineOptions() *combineOptions <span class="cov0" title="0">{
        return &amp;combineOptions{}
}</span>

// WithTweakedCombine is a functional option that allows callers to specify
// that the signature was produced using a tweaked aggregated public key. In
// order to properly aggregate the partial signatures, the caller must specify
// enough information to reconstruct the challenge, and also the final
// accumulated tweak value.
func WithTweakedCombine(msg [32]byte, keys []*btcec.PublicKey,
        tweaks []KeyTweakDesc, sort bool) CombineOption <span class="cov0" title="0">{

        return func(o *combineOptions) </span><span class="cov0" title="0">{
                combinedKey, _, tweakAcc, _ := AggregateKeys(
                        keys, sort, WithKeyTweaks(tweaks...),
                )

                o.msg = msg
                o.combinedKey = combinedKey.FinalKey
                o.tweakAcc = tweakAcc
        }</span>
}

// WithTaprootTweakedCombine is similar to the WithTweakedCombine option, but
// assumes a BIP 341 context where the final tweaked key is to be used as the
// output key, where the internal key is the aggregated key pre-tweak.
//
// This option should be used over WithTweakedCombine when attempting to
// aggregate signatures for a top-level taproot keyspend, where the output key
// commits to a script root.
func WithTaprootTweakedCombine(msg [32]byte, keys []*btcec.PublicKey,
        scriptRoot []byte, sort bool) CombineOption <span class="cov0" title="0">{

        return func(o *combineOptions) </span><span class="cov0" title="0">{
                combinedKey, _, tweakAcc, _ := AggregateKeys(
                        keys, sort, WithTaprootKeyTweak(scriptRoot),
                )

                o.msg = msg
                o.combinedKey = combinedKey.FinalKey
                o.tweakAcc = tweakAcc
        }</span>
}

// WithBip86TweakedCombine is similar to the WithTaprootTweakedCombine option,
// but assumes a BIP 341 + BIP 86 context where the final tweaked key is to be
// used as the output key, where the internal key is the aggregated key
// pre-tweak.
//
// This option should be used over WithTaprootTweakedCombine when attempting to
// aggregate signatures for a top-level taproot keyspend, where the output key
// was generated using BIP 86.
func WithBip86TweakedCombine(msg [32]byte, keys []*btcec.PublicKey,
        sort bool) CombineOption <span class="cov0" title="0">{

        return func(o *combineOptions) </span><span class="cov0" title="0">{
                combinedKey, _, tweakAcc, _ := AggregateKeys(
                        keys, sort, WithBIP86KeyTweak(),
                )

                o.msg = msg
                o.combinedKey = combinedKey.FinalKey
                o.tweakAcc = tweakAcc
        }</span>
}

// CombineSigs combines the set of public keys given the final aggregated
// nonce, and the series of partial signatures for each nonce.
func CombineSigs(combinedNonce *btcec.PublicKey,
        partialSigs []*PartialSignature,
        combineOpts ...CombineOption) *schnorr.Signature <span class="cov0" title="0">{

        // First, parse the set of optional combine options.
        opts := defaultCombineOptions()
        for _, option := range combineOpts </span><span class="cov0" title="0">{
                option(opts)
        }</span>

        // If signer keys and tweaks are specified, then we need to carry out
        // some intermediate steps before we can combine the signature.
        <span class="cov0" title="0">var tweakProduct *btcec.ModNScalar
        if opts.combinedKey != nil &amp;&amp; opts.tweakAcc != nil </span><span class="cov0" title="0">{
                // Next, we'll construct the parity factor of the combined key,
                // negating it if the combined key has an even y coordinate.
                parityFactor := new(btcec.ModNScalar).SetInt(1)
                combinedKeyBytes := opts.combinedKey.SerializeCompressed()
                if combinedKeyBytes[0] == secp.PubKeyFormatCompressedOdd </span><span class="cov0" title="0">{
                        parityFactor.Negate()
                }</span>

                // Next we'll reconstruct e the challenge has based on the
                // nonce and combined public key.
                //  * e = H(tag=ChallengeHashTag, R || Q || m) mod n
                <span class="cov0" title="0">var challengeMsg bytes.Buffer
                challengeMsg.Write(schnorr.SerializePubKey(combinedNonce))
                challengeMsg.Write(schnorr.SerializePubKey(opts.combinedKey))
                challengeMsg.Write(opts.msg[:])
                challengeBytes := chainhash.TaggedHash(
                        ChallengeHashTag, challengeMsg.Bytes(),
                )
                var e btcec.ModNScalar
                e.SetByteSlice(challengeBytes[:])

                tweakProduct = new(btcec.ModNScalar).Set(&amp;e)
                tweakProduct.Mul(opts.tweakAcc).Mul(parityFactor)</span>
        }

        // Finally, the tweak factor also needs to be re-computed as well.
        <span class="cov0" title="0">var combinedSig btcec.ModNScalar
        for _, partialSig := range partialSigs </span><span class="cov0" title="0">{
                combinedSig.Add(partialSig.S)
        }</span>

        // If the tweak product was set above, then we'll need to add the value
        // at the very end in order to produce a valid signature under the
        // final tweaked key.
        <span class="cov0" title="0">if tweakProduct != nil </span><span class="cov0" title="0">{
                combinedSig.Add(tweakProduct)
        }</span>

        // TODO(roasbeef): less verbose way to get the x coord...
        <span class="cov0" title="0">var nonceJ btcec.JacobianPoint
        combinedNonce.AsJacobian(&amp;nonceJ)
        nonceJ.ToAffine()

        return schnorr.NewSignature(&amp;nonceJ.X, &amp;combinedSig)</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package keychain

import (
        "crypto/sha256"
        "fmt"

        "github.com/btcsuite/btcd/btcec/v2"
        "github.com/btcsuite/btcd/btcec/v2/ecdsa"
        "github.com/btcsuite/btcd/btcec/v2/schnorr"
        "github.com/btcsuite/btcd/chaincfg/chainhash"
        "github.com/btcsuite/btcd/txscript"
        "github.com/btcsuite/btcwallet/waddrmgr"
        "github.com/btcsuite/btcwallet/wallet"
        "github.com/btcsuite/btcwallet/walletdb"
)

const (
        // CoinTypeBitcoin specifies the BIP44 coin type for Bitcoin key
        // derivation.
        CoinTypeBitcoin uint32 = 0

        // CoinTypeTestnet specifies the BIP44 coin type for all testnet key
        // derivation.
        CoinTypeTestnet = 1
)

var (
        // lightningAddrSchema is the scope addr schema for all keys that we
        // derive. We'll treat them all as p2wkh addresses, as atm we must
        // specify a particular type.
        lightningAddrSchema = waddrmgr.ScopeAddrSchema{
                ExternalAddrType: waddrmgr.WitnessPubKey,
                InternalAddrType: waddrmgr.WitnessPubKey,
        }

        // waddrmgrNamespaceKey is the namespace key that the waddrmgr state is
        // stored within the top-level waleltdb buckets of btcwallet.
        waddrmgrNamespaceKey = []byte("waddrmgr")
)

// BtcWalletKeyRing is an implementation of both the KeyRing and SecretKeyRing
// interfaces backed by btcwallet's internal root waddrmgr. Internally, we'll
// be using a ScopedKeyManager to do all of our derivations, using the key
// scope and scope addr scehma defined above. Re-using the existing key scope
// construction means that all key derivation will be protected under the root
// seed of the wallet, making each derived key fully deterministic.
type BtcWalletKeyRing struct {
        // wallet is a pointer to the active instance of the btcwallet core.
        // This is required as we'll need to manually open database
        // transactions in order to derive addresses and lookup relevant keys
        wallet *wallet.Wallet

        // chainKeyScope defines the purpose and coin type to be used when generating
        // keys for this keyring.
        chainKeyScope waddrmgr.KeyScope

        // lightningScope is a pointer to the scope that we'll be using as a
        // sub key manager to derive all the keys that we require.
        lightningScope *waddrmgr.ScopedKeyManager
}

// NewBtcWalletKeyRing creates a new implementation of the
// keychain.SecretKeyRing interface backed by btcwallet.
//
// NOTE: The passed waddrmgr.Manager MUST be unlocked in order for the keychain
// to function.
func NewBtcWalletKeyRing(w *wallet.Wallet, coinType uint32) SecretKeyRing <span class="cov0" title="0">{
        // Construct the key scope that will be used within the waddrmgr to
        // create an HD chain for deriving all of our required keys. A different
        // scope is used for each specific coin type.
        chainKeyScope := waddrmgr.KeyScope{
                Purpose: BIP0043Purpose,
                Coin:    coinType,
        }

        return &amp;BtcWalletKeyRing{
                wallet:        w,
                chainKeyScope: chainKeyScope,
        }
}</span>

// keyScope attempts to return the key scope that we'll use to derive all of
// our keys. If the scope has already been fetched from the database, then a
// cached version will be returned. Otherwise, we'll fetch it from the database
// and cache it for subsequent accesses.
func (b *BtcWalletKeyRing) keyScope() (*waddrmgr.ScopedKeyManager, error) <span class="cov0" title="0">{
        // If the scope has already been populated, then we'll return it
        // directly.
        if b.lightningScope != nil </span><span class="cov0" title="0">{
                return b.lightningScope, nil
        }</span>

        // Otherwise, we'll first do a check to ensure that the root manager
        // isn't locked, as otherwise we won't be able to *use* the scope.
        <span class="cov0" title="0">if !b.wallet.Manager.WatchOnly() &amp;&amp; b.wallet.Manager.IsLocked() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot create BtcWalletKeyRing with " +
                        "locked waddrmgr.Manager")
        }</span>

        // If the manager is indeed unlocked, then we'll fetch the scope, cache
        // it, and return to the caller.
        <span class="cov0" title="0">lnScope, err := b.wallet.Manager.FetchScopedKeyManager(b.chainKeyScope)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">b.lightningScope = lnScope

        return lnScope, nil</span>
}

// createAccountIfNotExists will create the corresponding account for a key
// family if it doesn't already exist in the database.
func (b *BtcWalletKeyRing) createAccountIfNotExists(
        addrmgrNs walletdb.ReadWriteBucket, keyFam KeyFamily,
        scope *waddrmgr.ScopedKeyManager) error <span class="cov0" title="0">{

        // If this is the multi-sig key family, then we can return early as
        // this is the default account that's created.
        if keyFam == KeyFamilyMultiSig </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Otherwise, we'll check if the account already exists, if so, we can
        // once again bail early.
        <span class="cov0" title="0">_, err := scope.AccountName(addrmgrNs, uint32(keyFam))
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // If we reach this point, then the account hasn't yet been created, so
        // we'll need to create it before we can proceed.
        <span class="cov0" title="0">return scope.NewRawAccount(addrmgrNs, uint32(keyFam))</span>
}

// DeriveNextKey attempts to derive the *next* key within the key family
// (account in BIP43) specified. This method should return the next external
// child within this branch.
//
// NOTE: This is part of the keychain.KeyRing interface.
func (b *BtcWalletKeyRing) DeriveNextKey(keyFam KeyFamily) (KeyDescriptor, error) <span class="cov0" title="0">{
        var (
                pubKey *btcec.PublicKey
                keyLoc KeyLocator
        )

        db := b.wallet.Database()
        err := walletdb.Update(db, func(tx walletdb.ReadWriteTx) error </span><span class="cov0" title="0">{
                addrmgrNs := tx.ReadWriteBucket(waddrmgrNamespaceKey)

                scope, err := b.keyScope()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // If the account doesn't exist, then we may need to create it
                // for the first time in order to derive the keys that we
                // require.
                <span class="cov0" title="0">err = b.createAccountIfNotExists(addrmgrNs, keyFam, scope)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">addrs, err := scope.NextExternalAddresses(
                        addrmgrNs, uint32(keyFam), 1,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Extract the first address, ensuring that it is of the proper
                // interface type, otherwise we can't manipulate it below.
                <span class="cov0" title="0">addr, ok := addrs[0].(waddrmgr.ManagedPubKeyAddress)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("address is not a managed pubkey " +
                                "addr")
                }</span>

                <span class="cov0" title="0">pubKey = addr.PubKey()

                _, pathInfo, _ := addr.DerivationInfo()
                keyLoc = KeyLocator{
                        Family: keyFam,
                        Index:  pathInfo.Index,
                }

                return nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return KeyDescriptor{}, err
        }</span>

        <span class="cov0" title="0">return KeyDescriptor{
                PubKey:     pubKey,
                KeyLocator: keyLoc,
        }, nil</span>
}

// DeriveKey attempts to derive an arbitrary key specified by the passed
// KeyLocator. This may be used in several recovery scenarios, or when manually
// rotating something like our current default node key.
//
// NOTE: This is part of the keychain.KeyRing interface.
func (b *BtcWalletKeyRing) DeriveKey(keyLoc KeyLocator) (KeyDescriptor, error) <span class="cov0" title="0">{
        var keyDesc KeyDescriptor

        db := b.wallet.Database()
        err := walletdb.Update(db, func(tx walletdb.ReadWriteTx) error </span><span class="cov0" title="0">{
                addrmgrNs := tx.ReadWriteBucket(waddrmgrNamespaceKey)

                scope, err := b.keyScope()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // If the account doesn't exist, then we may need to create it
                // for the first time in order to derive the keys that we
                // require. We skip this if we're using a remote signer in which
                // case we _need_ to create all accounts when creating the
                // wallet, so it must exist now.
                <span class="cov0" title="0">if !b.wallet.Manager.WatchOnly() </span><span class="cov0" title="0">{
                        err = b.createAccountIfNotExists(
                                addrmgrNs, keyLoc.Family, scope,
                        )
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov0" title="0">path := waddrmgr.DerivationPath{
                        InternalAccount: uint32(keyLoc.Family),
                        Branch:          0,
                        Index:           keyLoc.Index,
                }
                addr, err := scope.DeriveFromKeyPath(addrmgrNs, path)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">keyDesc.KeyLocator = keyLoc
                keyDesc.PubKey = addr.(waddrmgr.ManagedPubKeyAddress).PubKey()

                return nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return keyDesc, err
        }</span>

        <span class="cov0" title="0">return keyDesc, nil</span>
}

// DerivePrivKey attempts to derive the private key that corresponds to the
// passed key descriptor.
//
// NOTE: This is part of the keychain.SecretKeyRing interface.
func (b *BtcWalletKeyRing) DerivePrivKey(keyDesc KeyDescriptor) (
        *btcec.PrivateKey, error) <span class="cov0" title="0">{

        var key *btcec.PrivateKey

        scope, err := b.keyScope()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // First, attempt to see if we can read the key directly from
        // btcwallet's internal cache, if we can then we can skip all the
        // operations below (fast path).
        <span class="cov0" title="0">if keyDesc.PubKey == nil </span><span class="cov0" title="0">{
                keyPath := waddrmgr.DerivationPath{
                        InternalAccount: uint32(keyDesc.Family),
                        Account:         uint32(keyDesc.Family),
                        Branch:          0,
                        Index:           keyDesc.Index,
                }
                privKey, err := scope.DeriveFromKeyPathCache(keyPath)
                if err == nil </span><span class="cov0" title="0">{
                        return privKey, nil
                }</span>
        }

        <span class="cov0" title="0">db := b.wallet.Database()
        err = walletdb.Update(db, func(tx walletdb.ReadWriteTx) error </span><span class="cov0" title="0">{
                addrmgrNs := tx.ReadWriteBucket(waddrmgrNamespaceKey)

                // If the account doesn't exist, then we may need to create it
                // for the first time in order to derive the keys that we
                // require. We skip this if we're using a remote signer in which
                // case we _need_ to create all accounts when creating the
                // wallet, so it must exist now.
                if !b.wallet.Manager.WatchOnly() </span><span class="cov0" title="0">{
                        err = b.createAccountIfNotExists(
                                addrmgrNs, keyDesc.Family, scope,
                        )
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                // If the public key isn't set or they have a non-zero index,
                // then we know that the caller instead knows the derivation
                // path for a key.
                <span class="cov0" title="0">if keyDesc.PubKey == nil || keyDesc.Index &gt; 0 </span><span class="cov0" title="0">{
                        // Now that we know the account exists, we can safely
                        // derive the full private key from the given path.
                        path := waddrmgr.DerivationPath{
                                InternalAccount: uint32(keyDesc.Family),
                                Branch:          0,
                                Index:           keyDesc.Index,
                        }
                        addr, err := scope.DeriveFromKeyPath(addrmgrNs, path)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">key, err = addr.(waddrmgr.ManagedPubKeyAddress).PrivKey()
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">return nil</span>
                }

                // If the public key isn't nil, then this indicates that we
                // need to scan for the private key, assuming that we know the
                // valid key family.
                <span class="cov0" title="0">nextPath := waddrmgr.DerivationPath{
                        InternalAccount: uint32(keyDesc.Family),
                        Branch:          0,
                        Index:           0,
                }

                // We'll now iterate through our key range in an attempt to
                // find the target public key.
                //
                // TODO(roasbeef): possibly move scanning into wallet to allow
                // to be parallelized
                for i := 0; i &lt; MaxKeyRangeScan; i++ </span><span class="cov0" title="0">{
                        // Derive the next key in the range and fetch its
                        // managed address.
                        addr, err := scope.DeriveFromKeyPath(
                                addrmgrNs, nextPath,
                        )
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">managedAddr := addr.(waddrmgr.ManagedPubKeyAddress)

                        // If this is the target public key, then we'll return
                        // it directly back to the caller.
                        if managedAddr.PubKey().IsEqual(keyDesc.PubKey) </span><span class="cov0" title="0">{
                                key, err = managedAddr.PrivKey()
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>

                                <span class="cov0" title="0">return nil</span>
                        }

                        // This wasn't the target key, so roll forward and try
                        // the next one.
                        <span class="cov0" title="0">nextPath.Index++</span>
                }

                // If we reach this point, then we we're unable to derive the
                // private key, so return an error back to the user.
                <span class="cov0" title="0">return ErrCannotDerivePrivKey</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return key, nil</span>
}

// ECDH performs a scalar multiplication (ECDH-like operation) between the
// target key descriptor and remote public key. The output returned will be
// the sha256 of the resulting shared point serialized in compressed format. If
// k is our private key, and P is the public key, we perform the following
// operation:
//
//        sx := k*P s := sha256(sx.SerializeCompressed())
//
// NOTE: This is part of the keychain.ECDHRing interface.
func (b *BtcWalletKeyRing) ECDH(keyDesc KeyDescriptor,
        pub *btcec.PublicKey) ([32]byte, error) <span class="cov0" title="0">{

        privKey, err := b.DerivePrivKey(keyDesc)
        if err != nil </span><span class="cov0" title="0">{
                return [32]byte{}, err
        }</span>

        <span class="cov0" title="0">var (
                pubJacobian btcec.JacobianPoint
                s           btcec.JacobianPoint
        )
        pub.AsJacobian(&amp;pubJacobian)

        btcec.ScalarMultNonConst(&amp;privKey.Key, &amp;pubJacobian, &amp;s)
        s.ToAffine()
        sPubKey := btcec.NewPublicKey(&amp;s.X, &amp;s.Y)
        h := sha256.Sum256(sPubKey.SerializeCompressed())

        return h, nil</span>
}

// SignMessage signs the given message, single or double SHA256 hashing it
// first, with the private key described in the key locator.
//
// NOTE: This is part of the keychain.MessageSignerRing interface.
func (b *BtcWalletKeyRing) SignMessage(keyLoc KeyLocator,
        msg []byte, doubleHash bool) (*ecdsa.Signature, error) <span class="cov0" title="0">{

        privKey, err := b.DerivePrivKey(KeyDescriptor{
                KeyLocator: keyLoc,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var digest []byte
        if doubleHash </span><span class="cov0" title="0">{
                digest = chainhash.DoubleHashB(msg)
        }</span> else<span class="cov0" title="0"> {
                digest = chainhash.HashB(msg)
        }</span>
        <span class="cov0" title="0">return ecdsa.Sign(privKey, digest), nil</span>
}

// SignMessageCompact signs the given message, single or double SHA256 hashing
// it first, with the private key described in the key locator and returns
// the signature in the compact, public key recoverable format.
//
// NOTE: This is part of the keychain.MessageSignerRing interface.
func (b *BtcWalletKeyRing) SignMessageCompact(keyLoc KeyLocator,
        msg []byte, doubleHash bool) ([]byte, error) <span class="cov0" title="0">{

        privKey, err := b.DerivePrivKey(KeyDescriptor{
                KeyLocator: keyLoc,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var digest []byte
        if doubleHash </span><span class="cov0" title="0">{
                digest = chainhash.DoubleHashB(msg)
        }</span> else<span class="cov0" title="0"> {
                digest = chainhash.HashB(msg)
        }</span>

        <span class="cov0" title="0">return ecdsa.SignCompact(privKey, digest, true), nil</span>
}

// SignMessageSchnorr uses the Schnorr signature algorithm to sign the given
// message, single or double SHA256 hashing it first, with the private key
// described in the key locator and the optional tweak applied to the private
// key.
//
// NOTE: This is part of the keychain.MessageSignerRing interface.
func (b *BtcWalletKeyRing) SignMessageSchnorr(keyLoc KeyLocator,
        msg []byte, doubleHash bool, taprootTweak []byte,
        tag []byte) (*schnorr.Signature, error) <span class="cov0" title="0">{

        privKey, err := b.DerivePrivKey(KeyDescriptor{
                KeyLocator: keyLoc,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(taprootTweak) &gt; 0 </span><span class="cov0" title="0">{
                privKey = txscript.TweakTaprootPrivKey(*privKey, taprootTweak)
        }</span>

        // If a tag was provided, we need to take the tagged hash of the input.
        <span class="cov0" title="0">var digest []byte
        switch </span>{
        case len(tag) &gt; 0:<span class="cov0" title="0">
                taggedHash := chainhash.TaggedHash(tag, msg)
                digest = taggedHash[:]</span>
        case doubleHash:<span class="cov0" title="0">
                digest = chainhash.DoubleHashB(msg)</span>
        default:<span class="cov0" title="0">
                digest = chainhash.HashB(msg)</span>
        }
        <span class="cov0" title="0">return schnorr.Sign(privKey, digest)</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package keychain

import (
        "fmt"

        "github.com/btcsuite/btcd/btcec/v2"
        "github.com/btcsuite/btcd/btcec/v2/ecdsa"
        "github.com/btcsuite/btcd/btcec/v2/schnorr"
)

const (
        // KeyDerivationVersionLegacy is the previous version of the key
        // derivation schema defined below. We use a version as this means that
        // we'll be able to accept new seed in the future and be able to discern
        // if the software is compatible with the version of the seed.
        KeyDerivationVersionLegacy = 0

        // KeyDerivationVersionTaproot is the most recent version of the key
        // derivation scheme that marks the introduction of the Taproot
        // derivation with BIP0086 support.
        KeyDerivationVersionTaproot = 1

        // CurrentKeyDerivationVersion is the current default key derivation
        // version that is used for new seeds.
        CurrentKeyDerivationVersion = KeyDerivationVersionTaproot

        // BIP0043Purpose is the "purpose" value that we'll use for the first
        // version or our key derivation scheme. All keys are expected to be
        // derived from this purpose, then the particular coin type of the
        // chain where the keys are to be used.  Slightly adhering to BIP0043
        // allows us to not deviate too far from a widely used standard, and
        // also fits into existing implementations of the BIP's template.
        //
        // NOTE: BRICK SQUUUUUAD.
        BIP0043Purpose = 1017
)

// IsKnownVersion returns true if the given version is one of the known
// derivation scheme versions as defined by this package.
func IsKnownVersion(internalVersion uint8) bool <span class="cov0" title="0">{
        return internalVersion == KeyDerivationVersionLegacy ||
                internalVersion == KeyDerivationVersionTaproot
}</span>

var (
        // MaxKeyRangeScan is the maximum number of keys that we'll attempt to
        // scan with if a caller knows the public key, but not the KeyLocator
        // and wishes to derive a private key.
        MaxKeyRangeScan = 100000

        // ErrCannotDerivePrivKey is returned when DerivePrivKey is unable to
        // derive a private key given only the public key and target key
        // family.
        ErrCannotDerivePrivKey = fmt.Errorf("unable to derive private key")
)

// KeyFamily represents a "family" of keys that will be used within various
// contracts created by lnd. These families are meant to be distinct branches
// within the HD key chain of the backing wallet. Usage of key families within
// the interface below are strict in order to promote integrability and the
// ability to restore all keys given a user master seed backup.
//
// The key derivation in this file follows the following hierarchy based on
// BIP43:
//
//   - m/1017'/coinType'/keyFamily'/0/index
type KeyFamily uint32

const (
        // KeyFamilyMultiSig are keys to be used within multi-sig scripts.
        KeyFamilyMultiSig KeyFamily = 0

        // KeyFamilyRevocationBase are keys that are used within channels to
        // create revocation basepoints that the remote party will use to
        // create revocation keys for us.
        KeyFamilyRevocationBase KeyFamily = 1

        // KeyFamilyHtlcBase are keys used within channels that will be
        // combined with per-state randomness to produce public keys that will
        // be used in HTLC scripts.
        KeyFamilyHtlcBase KeyFamily = 2

        // KeyFamilyPaymentBase are keys used within channels that will be
        // combined with per-state randomness to produce public keys that will
        // be used in scripts that pay directly to us without any delay.
        KeyFamilyPaymentBase KeyFamily = 3

        // KeyFamilyDelayBase are keys used within channels that will be
        // combined with per-state randomness to produce public keys that will
        // be used in scripts that pay to us, but require a CSV delay before we
        // can sweep the funds.
        KeyFamilyDelayBase KeyFamily = 4

        // KeyFamilyRevocationRoot is a family of keys which will be used to
        // derive the root of a revocation tree for a particular channel.
        KeyFamilyRevocationRoot KeyFamily = 5

        // KeyFamilyNodeKey is a family of keys that will be used to derive
        // keys that will be advertised on the network to represent our current
        // "identity" within the network. Peers will need our latest node key
        // in order to establish a transport session with us on the Lightning
        // p2p level (BOLT-0008).
        KeyFamilyNodeKey KeyFamily = 6

        // KeyFamilyBaseEncryption is the family of keys that will be used to
        // derive keys that we use to encrypt and decrypt any general blob data
        // like static channel backups and the TLS private key. Often used when
        // encrypting files on disk.
        KeyFamilyBaseEncryption KeyFamily = 7

        // KeyFamilyTowerSession is the family of keys that will be used to
        // derive session keys when negotiating sessions with watchtowers. The
        // session keys are limited to the lifetime of the session and are used
        // to increase privacy in the watchtower protocol.
        KeyFamilyTowerSession KeyFamily = 8

        // KeyFamilyTowerID is the family of keys used to derive the public key
        // of a watchtower. This made distinct from the node key to offer a form
        // of rudimentary whitelisting, i.e. via knowledge of the pubkey,
        // preventing others from having full access to the tower just as a
        // result of knowing the node key.
        KeyFamilyTowerID KeyFamily = 9
)

// VersionZeroKeyFamilies is a slice of all the known key families for first
// version of the key derivation schema defined in this package.
var VersionZeroKeyFamilies = []KeyFamily{
        KeyFamilyMultiSig,
        KeyFamilyRevocationBase,
        KeyFamilyHtlcBase,
        KeyFamilyPaymentBase,
        KeyFamilyDelayBase,
        KeyFamilyRevocationRoot,
        KeyFamilyNodeKey,
        KeyFamilyBaseEncryption,
        KeyFamilyTowerSession,
        KeyFamilyTowerID,
}

// KeyLocator is a two-tuple that can be used to derive *any* key that has ever
// been used under the key derivation mechanisms described in this file.
// Version 0 of our key derivation schema uses the following BIP43-like
// derivation:
//
//   - m/1017'/coinType'/keyFamily'/0/index
//
// Our purpose is 1017 (chosen arbitrary for now), and the coin type will vary
// based on which coin/chain the channels are being created on. The key family
// are actually just individual "accounts" in the nomenclature of BIP43. By
// default we assume a branch of 0 (external). Finally, the key index (which
// will vary per channel and use case) is the final element which allows us to
// deterministically derive keys.
type KeyLocator struct {
        // TODO(roasbeef): add the key scope as well??

        // Family is the family of key being identified.
        Family KeyFamily

        // Index is the precise index of the key being identified.
        Index uint32
}

// IsEmpty returns true if a KeyLocator is "empty". This may be the case where
// we learn of a key from a remote party for a contract, but don't know the
// precise details of its derivation (as we don't know the private key!).
func (k KeyLocator) IsEmpty() bool <span class="cov0" title="0">{
        return k.Family == 0 &amp;&amp; k.Index == 0
}</span>

// KeyDescriptor wraps a KeyLocator and also optionally includes a public key.
// Either the KeyLocator must be non-empty, or the public key pointer be
// non-nil. This will be used by the KeyRing interface to lookup arbitrary
// private keys, and also within the SignDescriptor struct to locate precisely
// which keys should be used for signing.
type KeyDescriptor struct {
        // KeyLocator is the internal KeyLocator of the descriptor.
        KeyLocator

        // PubKey is an optional public key that fully describes a target key.
        // If this is nil, the KeyLocator MUST NOT be empty.
        PubKey *btcec.PublicKey
}

// KeyRing is the primary interface that will be used to perform public
// derivation of various keys used within the peer-to-peer network, and also
// within any created contracts. All derivation required by the KeyRing is
// based off of public derivation, so a system with only an extended public key
// (for the particular purpose+family) can derive this set of keys.
type KeyRing interface {
        // DeriveNextKey attempts to derive the *next* key within the key
        // family (account in BIP43) specified. This method should return the
        // next external child within this branch.
        DeriveNextKey(keyFam KeyFamily) (KeyDescriptor, error)

        // DeriveKey attempts to derive an arbitrary key specified by the
        // passed KeyLocator. This may be used in several recovery scenarios,
        // or when manually rotating something like our current default node
        // key.
        DeriveKey(keyLoc KeyLocator) (KeyDescriptor, error)
}

// SecretKeyRing is a ring similar to the regular KeyRing interface, but it is
// also able to derive *private keys*. As this is a super-set of the regular
// KeyRing, we also expect the SecretKeyRing to implement the fully KeyRing
// interface. The methods in this struct may be used to extract the node key in
// order to accept inbound network connections, or to do manual signing for
// recovery purposes.
type SecretKeyRing interface {
        KeyRing

        ECDHRing

        MessageSignerRing

        // DerivePrivKey attempts to derive the private key that corresponds to
        // the passed key descriptor.  If the public key is set, then this
        // method will perform an in-order scan over the key set, with a max of
        // MaxKeyRangeScan keys. In order for this to work, the caller MUST set
        // the KeyFamily within the partially populated KeyLocator.
        DerivePrivKey(keyDesc KeyDescriptor) (*btcec.PrivateKey, error)
}

// MessageSignerRing is an interface that abstracts away basic low-level ECDSA
// signing on keys within a key ring.
type MessageSignerRing interface {
        // SignMessage signs the given message, single or double SHA256 hashing
        // it first, with the private key described in the key locator.
        SignMessage(keyLoc KeyLocator, msg []byte,
                doubleHash bool) (*ecdsa.Signature, error)

        // SignMessageCompact signs the given message, single or double SHA256
        // hashing it first, with the private key described in the key locator
        // and returns the signature in the compact, public key recoverable
        // format.
        SignMessageCompact(keyLoc KeyLocator, msg []byte,
                doubleHash bool) ([]byte, error)

        // SignMessageSchnorr signs the given message, single or double SHA256
        // hashing it first, with the private key described in the key locator
        // and the optional Taproot tweak applied to the private key.
        SignMessageSchnorr(keyLoc KeyLocator, msg []byte,
                doubleHash bool, taprootTweak []byte,
                tag []byte) (*schnorr.Signature, error)
}

// SingleKeyMessageSigner is an abstraction interface that hides the
// implementation of the low-level ECDSA signing operations by wrapping a
// single, specific private key.
type SingleKeyMessageSigner interface {
        // PubKey returns the public key of the wrapped private key.
        PubKey() *btcec.PublicKey

        // KeyLocator returns the locator that describes the wrapped private
        // key.
        KeyLocator() KeyLocator

        // SignMessage signs the given message, single or double SHA256 hashing
        // it first, with the wrapped private key.
        SignMessage(message []byte, doubleHash bool) (*ecdsa.Signature, error)

        // SignMessageCompact signs the given message, single or double SHA256
        // hashing it first, with the wrapped private key and returns the
        // signature in the compact, public key recoverable format.
        SignMessageCompact(message []byte, doubleHash bool) ([]byte, error)
}

// ECDHRing is an interface that abstracts away basic low-level ECDH shared key
// generation on keys within a key ring.
type ECDHRing interface {
        // ECDH performs a scalar multiplication (ECDH-like operation) between
        // the target key descriptor and remote public key. The output
        // returned will be the sha256 of the resulting shared point serialized
        // in compressed format. If k is our private key, and P is the public
        // key, we perform the following operation:
        //
        //  sx := k*P
        //  s := sha256(sx.SerializeCompressed())
        ECDH(keyDesc KeyDescriptor, pubKey *btcec.PublicKey) ([32]byte, error)
}

// SingleKeyECDH is an abstraction interface that hides the implementation of an
// ECDH operation by wrapping a single, specific private key.
type SingleKeyECDH interface {
        // PubKey returns the public key of the wrapped private key.
        PubKey() *btcec.PublicKey

        // ECDH performs a scalar multiplication (ECDH-like operation) between
        // the wrapped private key and remote public key. The output returned
        // will be the sha256 of the resulting shared point serialized in
        // compressed format.
        ECDH(pubKey *btcec.PublicKey) ([32]byte, error)
}

// TODO(roasbeef): extend to actually support scalar mult of key?
//  * would allow to push in initial handshake auth into interface as well
</pre>
		
		<pre class="file" id="file31" style="display: none">package keychain

import (
        "crypto/sha256"

        "github.com/btcsuite/btcd/btcec/v2"
)

// NewPubKeyECDH wraps the given key of the key ring so it adheres to the
// SingleKeyECDH interface.
func NewPubKeyECDH(keyDesc KeyDescriptor, ecdh ECDHRing) *PubKeyECDH <span class="cov0" title="0">{
        return &amp;PubKeyECDH{
                keyDesc: keyDesc,
                ecdh:    ecdh,
        }
}</span>

// PubKeyECDH is an implementation of the SingleKeyECDH interface. It wraps an
// ECDH key ring so it can perform ECDH shared key generation against a single
// abstracted away private key.
type PubKeyECDH struct {
        keyDesc KeyDescriptor
        ecdh    ECDHRing
}

// PubKey returns the public key of the private key that is abstracted away by
// the interface.
//
// NOTE: This is part of the SingleKeyECDH interface.
func (p *PubKeyECDH) PubKey() *btcec.PublicKey <span class="cov0" title="0">{
        return p.keyDesc.PubKey
}</span>

// ECDH performs a scalar multiplication (ECDH-like operation) between the
// abstracted private key and a remote public key. The output returned will be
// the sha256 of the resulting shared point serialized in compressed format. If
// k is our private key, and P is the public key, we perform the following
// operation:
//
//        sx := k*P
//        s := sha256(sx.SerializeCompressed())
//
// NOTE: This is part of the SingleKeyECDH interface.
func (p *PubKeyECDH) ECDH(pubKey *btcec.PublicKey) ([32]byte, error) <span class="cov0" title="0">{
        return p.ecdh.ECDH(p.keyDesc, pubKey)
}</span>

// PrivKeyECDH is an implementation of the SingleKeyECDH in which we do have the
// full private key. This can be used to wrap a temporary key to conform to the
// SingleKeyECDH interface.
type PrivKeyECDH struct {
        // PrivKey is the private key that is used for the ECDH operation.
        PrivKey *btcec.PrivateKey
}

// PubKey returns the public key of the private key that is abstracted away by
// the interface.
//
// NOTE: This is part of the SingleKeyECDH interface.
func (p *PrivKeyECDH) PubKey() *btcec.PublicKey <span class="cov0" title="0">{
        return p.PrivKey.PubKey()
}</span>

// ECDH performs a scalar multiplication (ECDH-like operation) between the
// abstracted private key and a remote public key. The output returned will be
// the sha256 of the resulting shared point serialized in compressed format. If
// k is our private key, and P is the public key, we perform the following
// operation:
//
//        sx := k*P
//        s := sha256(sx.SerializeCompressed())
//
// NOTE: This is part of the SingleKeyECDH interface.
func (p *PrivKeyECDH) ECDH(pub *btcec.PublicKey) ([32]byte, error) <span class="cov0" title="0">{
        var (
                pubJacobian btcec.JacobianPoint
                s           btcec.JacobianPoint
        )
        pub.AsJacobian(&amp;pubJacobian)

        btcec.ScalarMultNonConst(&amp;p.PrivKey.Key, &amp;pubJacobian, &amp;s)
        s.ToAffine()
        sPubKey := btcec.NewPublicKey(&amp;s.X, &amp;s.Y)
        return sha256.Sum256(sPubKey.SerializeCompressed()), nil
}</span>

var _ SingleKeyECDH = (*PubKeyECDH)(nil)
var _ SingleKeyECDH = (*PrivKeyECDH)(nil)
</pre>
		
		<pre class="file" id="file32" style="display: none">package keychain

import (
        "github.com/btcsuite/btcd/btcec/v2"
        "github.com/btcsuite/btcd/btcec/v2/ecdsa"
        "github.com/btcsuite/btcd/chaincfg/chainhash"
)

func NewPubKeyMessageSigner(pubKey *btcec.PublicKey, keyLoc KeyLocator,
        signer MessageSignerRing) *PubKeyMessageSigner <span class="cov0" title="0">{

        return &amp;PubKeyMessageSigner{
                pubKey:       pubKey,
                keyLoc:       keyLoc,
                digestSigner: signer,
        }
}</span>

type PubKeyMessageSigner struct {
        pubKey       *btcec.PublicKey
        keyLoc       KeyLocator
        digestSigner MessageSignerRing
}

func (p *PubKeyMessageSigner) PubKey() *btcec.PublicKey <span class="cov0" title="0">{
        return p.pubKey
}</span>

func (p *PubKeyMessageSigner) KeyLocator() KeyLocator <span class="cov0" title="0">{
        return p.keyLoc
}</span>

func (p *PubKeyMessageSigner) SignMessage(message []byte,
        doubleHash bool) (*ecdsa.Signature, error) <span class="cov0" title="0">{

        return p.digestSigner.SignMessage(p.keyLoc, message, doubleHash)
}</span>

func (p *PubKeyMessageSigner) SignMessageCompact(msg []byte,
        doubleHash bool) ([]byte, error) <span class="cov0" title="0">{

        return p.digestSigner.SignMessageCompact(p.keyLoc, msg, doubleHash)
}</span>

func NewPrivKeyMessageSigner(privKey *btcec.PrivateKey,
        keyLoc KeyLocator) *PrivKeyMessageSigner <span class="cov0" title="0">{

        return &amp;PrivKeyMessageSigner{
                privKey: privKey,
                keyLoc:  keyLoc,
        }
}</span>

type PrivKeyMessageSigner struct {
        keyLoc  KeyLocator
        privKey *btcec.PrivateKey
}

func (p *PrivKeyMessageSigner) PubKey() *btcec.PublicKey <span class="cov0" title="0">{
        return p.privKey.PubKey()
}</span>

func (p *PrivKeyMessageSigner) KeyLocator() KeyLocator <span class="cov0" title="0">{
        return p.keyLoc
}</span>

func (p *PrivKeyMessageSigner) SignMessage(msg []byte,
        doubleHash bool) (*ecdsa.Signature, error) <span class="cov0" title="0">{

        var digest []byte
        if doubleHash </span><span class="cov0" title="0">{
                digest = chainhash.DoubleHashB(msg)
        }</span> else<span class="cov0" title="0"> {
                digest = chainhash.HashB(msg)
        }</span>
        <span class="cov0" title="0">return ecdsa.Sign(p.privKey, digest), nil</span>
}

func (p *PrivKeyMessageSigner) SignMessageCompact(msg []byte,
        doubleHash bool) ([]byte, error) <span class="cov0" title="0">{

        var digest []byte
        if doubleHash </span><span class="cov0" title="0">{
                digest = chainhash.DoubleHashB(msg)
        }</span> else<span class="cov0" title="0"> {
                digest = chainhash.HashB(msg)
        }</span>

        <span class="cov0" title="0">return ecdsa.SignCompact(p.privKey, digest, true), nil</span>
}

var _ SingleKeyMessageSigner = (*PubKeyMessageSigner)(nil)
var _ SingleKeyMessageSigner = (*PrivKeyMessageSigner)(nil)
</pre>
		
		<pre class="file" id="file33" style="display: none">package lntypes

import "fmt"

// ChannelParty is a type used to have an unambiguous description of which node
// is being referred to. This eliminates the need to describe as "local" or
// "remote" using bool.
type ChannelParty uint8

const (
        // Local is a ChannelParty constructor that is used to refer to the
        // node that is running.
        Local ChannelParty = iota

        // Remote is a ChannelParty constructor that is used to refer to the
        // node on the other end of the peer connection.
        Remote
)

// String provides a string representation of ChannelParty (useful for logging).
func (p ChannelParty) String() string <span class="cov0" title="0">{
        switch p </span>{
        case Local:<span class="cov0" title="0">
                return "Local"</span>
        case Remote:<span class="cov0" title="0">
                return "Remote"</span>
        default:<span class="cov0" title="0">
                panic(fmt.Sprintf("invalid ChannelParty value: %d", p))</span>
        }
}

// CounterParty inverts the role of the ChannelParty.
func (p ChannelParty) CounterParty() ChannelParty <span class="cov0" title="0">{
        switch p </span>{
        case Local:<span class="cov0" title="0">
                return Remote</span>
        case Remote:<span class="cov0" title="0">
                return Local</span>
        default:<span class="cov0" title="0">
                panic(fmt.Sprintf("invalid ChannelParty value: %v", p))</span>
        }
}

// IsLocal returns true if the ChannelParty is Local.
func (p ChannelParty) IsLocal() bool <span class="cov0" title="0">{
        return p == Local
}</span>

// IsRemote returns true if the ChannelParty is Remote.
func (p ChannelParty) IsRemote() bool <span class="cov0" title="0">{
        return p == Remote
}</span>

// Dual represents a structure when we are tracking the same parameter for both
// the Local and Remote parties.
type Dual[A any] struct {
        // Local is the value tracked for the Local ChannelParty.
        Local A

        // Remote is the value tracked for the Remote ChannelParty.
        Remote A
}

// GetForParty gives Dual an access method that takes a ChannelParty as an
// argument. It is included for ergonomics in cases where the ChannelParty is
// in a variable and which party determines how we want to access the Dual.
func (d *Dual[A]) GetForParty(p ChannelParty) A <span class="cov0" title="0">{
        switch p </span>{
        case Local:<span class="cov0" title="0">
                return d.Local</span>
        case Remote:<span class="cov0" title="0">
                return d.Remote</span>
        default:<span class="cov0" title="0">
                panic(fmt.Sprintf(
                        "switch default triggered in ForParty: %v", p,
                ))</span>
        }
}

// SetForParty sets the value in the Dual for the given ChannelParty. This
// returns a copy of the original value.
func (d *Dual[A]) SetForParty(p ChannelParty, value A) <span class="cov0" title="0">{
        switch p </span>{
        case Local:<span class="cov0" title="0">
                d.Local = value</span>
        case Remote:<span class="cov0" title="0">
                d.Remote = value</span>
        default:<span class="cov0" title="0">
                panic(fmt.Sprintf(
                        "switch default triggered in ForParty: %v", p,
                ))</span>
        }
}

// ModifyForParty applies the function argument to the given ChannelParty field
// and returns a new copy of the Dual.
func (d *Dual[A]) ModifyForParty(p ChannelParty, f func(A) A) A <span class="cov0" title="0">{
        switch p </span>{
        case Local:<span class="cov0" title="0">
                d.Local = f(d.Local)
                return d.Local</span>
        case Remote:<span class="cov0" title="0">
                d.Remote = f(d.Remote)
                return d.Remote</span>
        default:<span class="cov0" title="0">
                panic(fmt.Sprintf(
                        "switch default triggered in ForParty: %v", p,
                ))</span>
        }
}

// MapDual applies the function argument to both the Local and Remote fields of
// the Dual[A] and returns a Dual[B] with that function applied.
func MapDual[A, B any](d Dual[A], f func(A) B) Dual[B] <span class="cov0" title="0">{
        return Dual[B]{
                Local:  f(d.Local),
                Remote: f(d.Remote),
        }
}</span>

var BothParties []ChannelParty = []ChannelParty{Local, Remote}
</pre>
		
		<pre class="file" id="file34" style="display: none">package lntypes

import (
        "encoding/hex"
        "fmt"
)

// HashSize of array used to store hashes.
const HashSize = 32

// ZeroHash is a predefined hash containing all zeroes.
var ZeroHash Hash

// Hash is used in several of the lightning messages and common structures. It
// typically represents a payment hash.
type Hash [HashSize]byte

// String returns the Hash as a hexadecimal string.
func (hash Hash) String() string <span class="cov0" title="0">{
        return hex.EncodeToString(hash[:])
}</span>

// MakeHash returns a new Hash from a byte slice.  An error is returned if
// the number of bytes passed in is not HashSize.
func MakeHash(newHash []byte) (Hash, error) <span class="cov0" title="0">{
        nhlen := len(newHash)
        if nhlen != HashSize </span><span class="cov0" title="0">{
                return Hash{}, fmt.Errorf("invalid hash length of %v, want %v",
                        nhlen, HashSize)
        }</span>

        <span class="cov0" title="0">var hash Hash
        copy(hash[:], newHash)

        return hash, nil</span>
}

// MakeHashFromStr creates a Hash from a hex hash string.
func MakeHashFromStr(newHash string) (Hash, error) <span class="cov0" title="0">{
        // Return error if hash string is of incorrect length.
        if len(newHash) != HashSize*2 </span><span class="cov0" title="0">{
                return Hash{}, fmt.Errorf("invalid hash string length of %v, "+
                        "want %v", len(newHash), HashSize*2)
        }</span>

        <span class="cov0" title="0">hash, err := hex.DecodeString(newHash)
        if err != nil </span><span class="cov0" title="0">{
                return Hash{}, err
        }</span>

        <span class="cov0" title="0">return MakeHash(hash)</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package lntypes

import (
        "crypto/sha256"
        "encoding/hex"
        "fmt"
)

// PreimageSize of array used to store preimagees.
const PreimageSize = 32

// Preimage is used in several of the lightning messages and common structures.
// It represents a payment preimage.
type Preimage [PreimageSize]byte

// String returns the Preimage as a hexadecimal string.
func (p Preimage) String() string <span class="cov0" title="0">{
        return hex.EncodeToString(p[:])
}</span>

// MakePreimage returns a new Preimage from a bytes slice. An error is returned
// if the number of bytes passed in is not PreimageSize.
func MakePreimage(newPreimage []byte) (Preimage, error) <span class="cov0" title="0">{
        nhlen := len(newPreimage)
        if nhlen != PreimageSize </span><span class="cov0" title="0">{
                return Preimage{}, fmt.Errorf("invalid preimage length of %v, "+
                        "want %v", nhlen, PreimageSize)
        }</span>

        <span class="cov0" title="0">var preimage Preimage
        copy(preimage[:], newPreimage)

        return preimage, nil</span>
}

// MakePreimageFromStr creates a Preimage from a hex preimage string.
func MakePreimageFromStr(newPreimage string) (Preimage, error) <span class="cov0" title="0">{
        // Return error if preimage string is of incorrect length.
        if len(newPreimage) != PreimageSize*2 </span><span class="cov0" title="0">{
                return Preimage{}, fmt.Errorf("invalid preimage string length "+
                        "of %v, want %v", len(newPreimage), PreimageSize*2)
        }</span>

        <span class="cov0" title="0">preimage, err := hex.DecodeString(newPreimage)
        if err != nil </span><span class="cov0" title="0">{
                return Preimage{}, err
        }</span>

        <span class="cov0" title="0">return MakePreimage(preimage)</span>
}

// Hash returns the sha256 hash of the preimage.
func (p *Preimage) Hash() Hash <span class="cov0" title="0">{
        return Hash(sha256.Sum256(p[:]))
}</span>

// Matches returns whether this preimage is the preimage of the given hash.
func (p *Preimage) Matches(h Hash) bool <span class="cov0" title="0">{
        return h == p.Hash()
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">package lntypes

import (
        "fmt"
        "math"
)

// WeightUnit defines a unit to express the transaction size. One weight unit
// is 1/4_000_000 of the max block size. The tx weight is calculated using
// `Base tx size * 3 + Total tx size`.
//   - Base tx size is size of the transaction serialized without the witness
//     data.
//   - Total tx size is the transaction size in bytes serialized according
//     #BIP144.
type WeightUnit uint64

// ToVB converts a value expressed in weight units to virtual bytes.
func (wu WeightUnit) ToVB() VByte <span class="cov0" title="0">{
        // According to BIP141: Virtual transaction size is defined as
        // Transaction weight / 4 (rounded up to the next integer).
        return VByte(math.Ceil(float64(wu) / 4))
}</span>

// String returns the string representation of the weight unit.
func (wu WeightUnit) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("%d wu", wu)
}</span>

// VByte defines a unit to express the transaction size. One virtual byte is
// 1/4th of a weight unit. The tx virtual bytes is calculated using `TxWeight /
// 4`.
type VByte uint64

// ToWU converts a value expressed in virtual bytes to weight units.
func (vb VByte) ToWU() WeightUnit <span class="cov0" title="0">{
        return WeightUnit(vb * 4)
}</span>

// String returns the string representation of the virtual byte.
func (vb VByte) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("%d vb", vb)
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">package lnutils

import (
        "fmt"
        "time"
)

// RecvOrTimeout attempts to recv over chan c, returning the value. If the
// timeout passes before the recv succeeds, an error is returned.
func RecvOrTimeout[T any](c &lt;-chan T, timeout time.Duration) (*T, error) <span class="cov0" title="0">{
        select </span>{
        case m := &lt;-c:<span class="cov0" title="0">
                return &amp;m, nil</span>

        case &lt;-time.After(timeout):<span class="cov0" title="0">
                return nil, fmt.Errorf("timeout hit")</span>
        }
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package lnutils

import "errors"

// ErrorAs behaves the same as `errors.As` except there's no need to declare
// the target error as a variable first.
// Instead of writing:
//
//        var targetErr *TargetErr
//        errors.As(err, &amp;targetErr)
//
// We can write:
//
//        lnutils.ErrorAs[*TargetErr](err)
//
// To save us from declaring the target error variable.
func ErrorAs[Target error](err error) bool <span class="cov0" title="0">{
        var targetErr Target

        return errors.As(err, &amp;targetErr)
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">package lnutils

import (
        "errors"
        "fmt"
        "os"
)

// CreateDir creates a directory if it doesn't exist and also handles
// symlink-related errors with user-friendly messages. It creates all necessary
// parent directories with the specified permissions.
func CreateDir(dir string, perm os.FileMode) error <span class="cov0" title="0">{
        err := os.MkdirAll(dir, perm)
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Show a nicer error message if it's because a symlink
        // is linked to a directory that does not exist
        // (probably because it's not mounted).
        <span class="cov0" title="0">var pathErr *os.PathError
        if errors.As(err, &amp;pathErr) &amp;&amp; os.IsExist(err) </span><span class="cov0" title="0">{
                link, lerr := os.Readlink(pathErr.Path)
                if lerr == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("is symlink %s -&gt; %s "+
                                "mounted?", pathErr.Path, link)
                }</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("failed to create directory '%s': %w", dir, err)</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package lnutils

import (
        "log/slog"
        "strings"

        "github.com/btcsuite/btcd/btcec/v2"
        "github.com/btcsuite/btclog/v2"
        "github.com/davecgh/go-spew/spew"
)

// LogClosure is used to provide a closure over expensive logging operations so
// don't have to be performed when the logging level doesn't warrant it.
type LogClosure func() string

// String invokes the underlying function and returns the result.
func (c LogClosure) String() string <span class="cov0" title="0">{
        return c()
}</span>

// NewLogClosure returns a new closure over a function that returns a string
// which itself provides a Stringer interface so that it can be used with the
// logging system.
func NewLogClosure(c func() string) LogClosure <span class="cov0" title="0">{
        return LogClosure(c)
}</span>

// SpewLogClosure takes an interface and returns the string of it created from
// `spew.Sdump` in a LogClosure.
func SpewLogClosure(a any) LogClosure <span class="cov0" title="0">{
        return func() string </span><span class="cov0" title="0">{
                return spew.Sdump(a)
        }</span>
}

// NewSeparatorClosure returns a new closure that logs a separator line.
func NewSeparatorClosure() LogClosure <span class="cov0" title="0">{
        return func() string </span><span class="cov0" title="0">{
                return strings.Repeat("=", 80)
        }</span>
}

// LogPubKey returns a slog attribute for logging a public key in hex format.
func LogPubKey(key string, pubKey *btcec.PublicKey) slog.Attr <span class="cov0" title="0">{
        // Handle nil pubkey gracefully, although callers should ideally prevent
        // this.
        if pubKey == nil </span><span class="cov0" title="0">{
                return btclog.Fmt(key, "&lt;nil&gt;")
        }</span>

        <span class="cov0" title="0">return btclog.Hex6(key, pubKey.SerializeCompressed())</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package lnutils

// Ptr returns the pointer of the given value. This is useful in instances
// where a function returns the value, but a pointer is wanted. Without this,
// then an intermediate variable is needed.
func Ptr[T any](v T) *T <span class="cov0" title="0">{
        return &amp;v
}</span>

// ByteArray is a type constraint for type that reduces down to a fixed sized
// array.
type ByteArray interface {
        ~[32]byte
}

// ByteSlice takes a byte array, and returns a slice. This is useful when a
// function returns an array, but a slice is wanted. Without this, then an
// intermediate variable is needed.
func ByteSlice[T ByteArray](v T) []byte <span class="cov0" title="0">{
        return v[:]
}</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">package lnutils

// Map takes an input slice, and applies the function f to each element,
// yielding a new slice.
func Map[T1, T2 any](s []T1, f func(T1) T2) []T2 <span class="cov0" title="0">{
        r := make([]T2, len(s))

        for i, v := range s </span><span class="cov0" title="0">{
                r[i] = f(v)
        }</span>

        <span class="cov0" title="0">return r</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package lnutils

import "sync"

// SyncMap wraps a sync.Map with type parameters such that it's easier to
// access the items stored in the map since no type assertion is needed. It
// also requires explicit type definition when declaring and initiating the
// variables, which helps us understanding what's stored in a given map.
type SyncMap[K comparable, V any] struct {
        sync.Map
}

// Store puts an item in the map.
func (m *SyncMap[K, V]) Store(key K, value V) <span class="cov0" title="0">{
        m.Map.Store(key, value)
}</span>

// Load queries an item from the map using the specified key. If the item
// cannot be found, an empty value and false will be returned. If the stored
// item fails the type assertion, a nil value and false will be returned.
func (m *SyncMap[K, V]) Load(key K) (V, bool) <span class="cov0" title="0">{
        result, ok := m.Map.Load(key)
        if !ok </span><span class="cov0" title="0">{
                return *new(V), false // nolint: gocritic
        }</span>

        <span class="cov0" title="0">item, ok := result.(V)
        return item, ok</span>
}

// Delete removes an item from the map specified by the key.
func (m *SyncMap[K, V]) Delete(key K) <span class="cov0" title="0">{
        m.Map.Delete(key)
}</span>

// LoadAndDelete queries an item and deletes it from the map using the
// specified key.
func (m *SyncMap[K, V]) LoadAndDelete(key K) (V, bool) <span class="cov0" title="0">{
        result, loaded := m.Map.LoadAndDelete(key)
        if !loaded </span><span class="cov0" title="0">{
                return *new(V), loaded // nolint: gocritic
        }</span>

        <span class="cov0" title="0">item, ok := result.(V)
        return item, ok</span>
}

// Range iterates the map and applies the `visitor` function. If the `visitor`
// returns false, the iteration will be stopped.
func (m *SyncMap[K, V]) Range(visitor func(K, V) bool) <span class="cov0" title="0">{
        m.Map.Range(func(k any, v any) bool </span><span class="cov0" title="0">{
                return visitor(k.(K), v.(V))
        }</span>)
}

// ForEach iterates the map and applies the `visitor` function. Unlike the
// `Range` method, the `visitor` function will be applied to all the items
// unless there's an error.
func (m *SyncMap[K, V]) ForEach(visitor func(K, V) error) <span class="cov0" title="0">{
        // rangeVisitor wraps the `visitor` function and returns false if
        // there's an error returned from the `visitor` function.
        rangeVisitor := func(k K, v V) bool </span><span class="cov0" title="0">{
                if err := visitor(k, v); err != nil </span><span class="cov0" title="0">{
                        // Break the iteration if there's an error.
                        return false
                }</span>

                <span class="cov0" title="0">return true</span>
        }

        <span class="cov0" title="0">m.Range(rangeVisitor)</span>
}

// Len returns the number of items in the map.
func (m *SyncMap[K, V]) Len() int <span class="cov0" title="0">{
        var count int
        m.Range(func(_ K, _ V) bool </span><span class="cov0" title="0">{
                count++

                return true
        }</span>)

        <span class="cov0" title="0">return count</span>
}

// LoadOrStore queries an item from the map using the specified key. If the
// item cannot be found, the `value` will be stored in the map and returned.
// If the stored item fails the type assertion, a nil value and false will be
// returned.
func (m *SyncMap[K, V]) LoadOrStore(key K, value V) (V, bool) <span class="cov0" title="0">{
        result, loaded := m.Map.LoadOrStore(key, value)
        item, ok := result.(V)
        if !ok </span><span class="cov0" title="0">{
                return *new(V), false
        }</span>

        <span class="cov0" title="0">return item, loaded</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package chainfee

import (
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "math"
        prand "math/rand"
        "net"
        "net/http"
        "sync"
        "sync/atomic"
        "time"

        "github.com/btcsuite/btcd/btcutil"
        "github.com/btcsuite/btcd/rpcclient"
        "github.com/lightningnetwork/lnd/lnutils"
)

const (
        // MaxBlockTarget is the highest number of blocks confirmations that
        // a WebAPIEstimator will cache fees for. This number is chosen
        // because it's the highest number of confs bitcoind will return a fee
        // estimate for.
        MaxBlockTarget uint32 = 1008

        // minBlockTarget is the lowest number of blocks confirmations that
        // a WebAPIEstimator will cache fees for. Requesting an estimate for
        // less than this will result in an error.
        minBlockTarget uint32 = 1

        // WebAPIConnectionTimeout specifies the timeout value for connecting
        // to the api source.
        WebAPIConnectionTimeout = 5 * time.Second

        // WebAPIResponseTimeout specifies the timeout value for receiving a
        // fee response from the api source.
        WebAPIResponseTimeout = 10 * time.Second

        // economicalFeeMode is a mode that bitcoind uses to serve
        // non-conservative fee estimates. These fee estimates are less
        // resistant to shocks.
        economicalFeeMode = "ECONOMICAL"

        // filterCapConfTarget is the conf target that will be used to cap our
        // minimum feerate if we used the median of our peers' feefilter
        // values.
        filterCapConfTarget = uint32(1)
)

var (
        // errNoFeeRateFound is used when a given conf target cannot be found
        // from the fee estimator.
        errNoFeeRateFound = errors.New("no fee estimation for block target")

        // errEmptyCache is used when the fee rate cache is empty.
        errEmptyCache = errors.New("fee rate cache is empty")
)

// Estimator provides the ability to estimate on-chain transaction fees for
// various combinations of transaction sizes and desired confirmation time
// (measured by number of blocks).
type Estimator interface {
        // EstimateFeePerKW takes in a target for the number of blocks until an
        // initial confirmation and returns the estimated fee expressed in
        // sat/kw.
        EstimateFeePerKW(numBlocks uint32) (SatPerKWeight, error)

        // Start signals the Estimator to start any processes or goroutines
        // it needs to perform its duty.
        Start() error

        // Stop stops any spawned goroutines and cleans up the resources used
        // by the fee estimator.
        Stop() error

        // RelayFeePerKW returns the minimum fee rate required for transactions
        // to be relayed. This is also the basis for calculation of the dust
        // limit.
        RelayFeePerKW() SatPerKWeight
}

// StaticEstimator will return a static value for all fee calculation requests.
// It is designed to be replaced by a proper fee calculation implementation.
// The fees are not accessible directly, because changing them would not be
// thread safe.
type StaticEstimator struct {
        // feePerKW is the static fee rate in satoshis-per-vbyte that will be
        // returned by this fee estimator.
        feePerKW SatPerKWeight

        // relayFee is the minimum fee rate required for transactions to be
        // relayed.
        relayFee SatPerKWeight
}

// NewStaticEstimator returns a new static fee estimator instance.
func NewStaticEstimator(feePerKW, relayFee SatPerKWeight) *StaticEstimator <span class="cov0" title="0">{
        return &amp;StaticEstimator{
                feePerKW: feePerKW,
                relayFee: relayFee,
        }
}</span>

// EstimateFeePerKW will return a static value for fee calculations.
//
// NOTE: This method is part of the Estimator interface.
func (e StaticEstimator) EstimateFeePerKW(numBlocks uint32) (SatPerKWeight, error) <span class="cov0" title="0">{
        return e.feePerKW, nil
}</span>

// RelayFeePerKW returns the minimum fee rate required for transactions to be
// relayed.
//
// NOTE: This method is part of the Estimator interface.
func (e StaticEstimator) RelayFeePerKW() SatPerKWeight <span class="cov0" title="0">{
        return e.relayFee
}</span>

// Start signals the Estimator to start any processes or goroutines
// it needs to perform its duty.
//
// NOTE: This method is part of the Estimator interface.
func (e StaticEstimator) Start() error <span class="cov0" title="0">{
        return nil
}</span>

// Stop stops any spawned goroutines and cleans up the resources used
// by the fee estimator.
//
// NOTE: This method is part of the Estimator interface.
func (e StaticEstimator) Stop() error <span class="cov0" title="0">{
        return nil
}</span>

// A compile-time assertion to ensure that StaticFeeEstimator implements the
// Estimator interface.
var _ Estimator = (*StaticEstimator)(nil)

// BtcdEstimator is an implementation of the Estimator interface backed
// by the RPC interface of an active btcd node. This implementation will proxy
// any fee estimation requests to btcd's RPC interface.
type BtcdEstimator struct {
        // fallbackFeePerKW is the fall back fee rate in sat/kw that is returned
        // if the fee estimator does not yet have enough data to actually
        // produce fee estimates.
        fallbackFeePerKW SatPerKWeight

        // minFeeManager is used to query the current minimum fee, in sat/kw,
        // that we should enforce. This will be used to determine fee rate for
        // a transaction when the estimated fee rate is too low to allow the
        // transaction to propagate through the network.
        minFeeManager *minFeeManager

        btcdConn *rpcclient.Client

        // filterManager uses our peer's feefilter values to determine a
        // suitable feerate to use that will allow successful transaction
        // propagation.
        filterManager *filterManager
}

// NewBtcdEstimator creates a new BtcdEstimator given a fully populated
// rpc config that is able to successfully connect and authenticate with the
// btcd node, and also a fall back fee rate. The fallback fee rate is used in
// the occasion that the estimator has insufficient data, or returns zero for a
// fee estimate.
func NewBtcdEstimator(rpcConfig rpcclient.ConnConfig,
        fallBackFeeRate SatPerKWeight) (*BtcdEstimator, error) <span class="cov0" title="0">{

        rpcConfig.DisableConnectOnNew = true
        rpcConfig.DisableAutoReconnect = false
        chainConn, err := rpcclient.New(&amp;rpcConfig, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">fetchCb := func() ([]SatPerKWeight, error) </span><span class="cov0" title="0">{
                return fetchBtcdFilters(chainConn)
        }</span>

        <span class="cov0" title="0">return &amp;BtcdEstimator{
                fallbackFeePerKW: fallBackFeeRate,
                btcdConn:         chainConn,
                filterManager:    newFilterManager(fetchCb),
        }, nil</span>
}

// Start signals the Estimator to start any processes or goroutines
// it needs to perform its duty.
//
// NOTE: This method is part of the Estimator interface.
func (b *BtcdEstimator) Start() error <span class="cov0" title="0">{
        if err := b.btcdConn.Connect(20); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Once the connection to the backend node has been established, we
        // can initialise the minimum relay fee manager which queries the
        // chain backend for the minimum relay fee on construction.
        <span class="cov0" title="0">minRelayFeeManager, err := newMinFeeManager(
                defaultUpdateInterval, b.fetchMinRelayFee,
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">b.minFeeManager = minRelayFeeManager

        b.filterManager.Start()

        return nil</span>
}

// fetchMinRelayFee fetches and returns the minimum relay fee in sat/kb from
// the btcd backend.
func (b *BtcdEstimator) fetchMinRelayFee() (SatPerKWeight, error) <span class="cov0" title="0">{
        info, err := b.btcdConn.GetInfo()
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">relayFee, err := btcutil.NewAmount(info.RelayFee)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        // The fee rate is expressed in sat/kb, so we'll manually convert it to
        // our desired sat/kw rate.
        <span class="cov0" title="0">return SatPerKVByte(relayFee).FeePerKWeight(), nil</span>
}

// Stop stops any spawned goroutines and cleans up the resources used
// by the fee estimator.
//
// NOTE: This method is part of the Estimator interface.
func (b *BtcdEstimator) Stop() error <span class="cov0" title="0">{
        b.filterManager.Stop()

        b.btcdConn.Shutdown()
        b.btcdConn.WaitForShutdown()

        return nil
}</span>

// EstimateFeePerKW takes in a target for the number of blocks until an initial
// confirmation and returns the estimated fee expressed in sat/kw.
//
// NOTE: This method is part of the Estimator interface.
func (b *BtcdEstimator) EstimateFeePerKW(numBlocks uint32) (SatPerKWeight, error) <span class="cov0" title="0">{
        feeEstimate, err := b.fetchEstimate(numBlocks)
        switch </span>{
        // If the estimator doesn't have enough data, or returns an error, then
        // to return a proper value, then we'll return the default fall back
        // fee rate.
        case err != nil:<span class="cov0" title="0">
                log.Errorf("unable to query estimator: %v", err)
                fallthrough</span>

        case feeEstimate == 0:<span class="cov0" title="0">
                return b.fallbackFeePerKW, nil</span>
        }

        <span class="cov0" title="0">return feeEstimate, nil</span>
}

// RelayFeePerKW returns the minimum fee rate required for transactions to be
// relayed.
//
// NOTE: This method is part of the Estimator interface.
func (b *BtcdEstimator) RelayFeePerKW() SatPerKWeight <span class="cov0" title="0">{
        // Get a suitable minimum feerate to use. This may optionally use the
        // median of our peers' feefilter values.
        feeCapClosure := func() (SatPerKWeight, error) </span><span class="cov0" title="0">{
                return b.fetchEstimateInner(filterCapConfTarget)
        }</span>

        <span class="cov0" title="0">return chooseMinFee(
                b.minFeeManager.fetchMinFee, b.filterManager.FetchMedianFilter,
                feeCapClosure,
        )</span>
}

// fetchEstimate returns a fee estimate for a transaction to be confirmed in
// confTarget blocks. The estimate is returned in sat/kw.
func (b *BtcdEstimator) fetchEstimate(confTarget uint32) (SatPerKWeight, error) <span class="cov0" title="0">{
        satPerKw, err := b.fetchEstimateInner(confTarget)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        // Finally, we'll enforce our fee floor by choosing the higher of the
        // minimum relay fee and the feerate returned by the filterManager.
        <span class="cov0" title="0">absoluteMinFee := b.RelayFeePerKW()

        if satPerKw &lt; absoluteMinFee </span><span class="cov0" title="0">{
                log.Debugf("Estimated fee rate of %v sat/kw is too low, "+
                        "using fee floor of %v sat/kw instead", satPerKw,
                        absoluteMinFee)

                satPerKw = absoluteMinFee
        }</span>

        <span class="cov0" title="0">log.Debugf("Returning %v sat/kw for conf target of %v",
                int64(satPerKw), confTarget)

        return satPerKw, nil</span>
}

func (b *BtcdEstimator) fetchEstimateInner(confTarget uint32) (SatPerKWeight,
        error) <span class="cov0" title="0">{

        // First, we'll fetch the estimate for our confirmation target.
        btcPerKB, err := b.btcdConn.EstimateFee(int64(confTarget))
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        // Next, we'll convert the returned value to satoshis, as it's
        // currently returned in BTC.
        <span class="cov0" title="0">satPerKB, err := btcutil.NewAmount(btcPerKB)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        // Since we use fee rates in sat/kw internally, we'll convert the
        // estimated fee rate from its sat/kb representation to sat/kw.
        <span class="cov0" title="0">return SatPerKVByte(satPerKB).FeePerKWeight(), nil</span>
}

// A compile-time assertion to ensure that BtcdEstimator implements the
// Estimator interface.
var _ Estimator = (*BtcdEstimator)(nil)

// BitcoindEstimator is an implementation of the Estimator interface backed by
// the RPC interface of an active bitcoind node. This implementation will proxy
// any fee estimation requests to bitcoind's RPC interface.
type BitcoindEstimator struct {
        // fallbackFeePerKW is the fallback fee rate in sat/kw that is returned
        // if the fee estimator does not yet have enough data to actually
        // produce fee estimates.
        fallbackFeePerKW SatPerKWeight

        // minFeeManager is used to keep track of the minimum fee, in sat/kw,
        // that we should enforce. This will be used as the default fee rate
        // for a transaction when the estimated fee rate is too low to allow
        // the transaction to propagate through the network.
        minFeeManager *minFeeManager

        // feeMode is the estimate_mode to use when calling "estimatesmartfee".
        // It can be either "ECONOMICAL" or "CONSERVATIVE", and it's default
        // to "CONSERVATIVE".
        feeMode string

        // TODO(ziggie): introduce an interface for the client to enhance
        // testability of the estimator.
        bitcoindConn *rpcclient.Client

        // filterManager uses our peer's feefilter values to determine a
        // suitable feerate to use that will allow successful transaction
        // propagation.
        filterManager *filterManager
}

// NewBitcoindEstimator creates a new BitcoindEstimator given a fully populated
// rpc config that is able to successfully connect and authenticate with the
// bitcoind node, and also a fall back fee rate. The fallback fee rate is used
// in the occasion that the estimator has insufficient data, or returns zero
// for a fee estimate.
func NewBitcoindEstimator(rpcConfig rpcclient.ConnConfig, feeMode string,
        fallBackFeeRate SatPerKWeight) (*BitcoindEstimator, error) <span class="cov0" title="0">{

        rpcConfig.DisableConnectOnNew = true
        rpcConfig.DisableAutoReconnect = false
        rpcConfig.DisableTLS = true
        rpcConfig.HTTPPostMode = true
        chainConn, err := rpcclient.New(&amp;rpcConfig, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">fetchCb := func() ([]SatPerKWeight, error) </span><span class="cov0" title="0">{
                return fetchBitcoindFilters(chainConn)
        }</span>

        <span class="cov0" title="0">return &amp;BitcoindEstimator{
                fallbackFeePerKW: fallBackFeeRate,
                bitcoindConn:     chainConn,
                feeMode:          feeMode,
                filterManager:    newFilterManager(fetchCb),
        }, nil</span>
}

// Start signals the Estimator to start any processes or goroutines
// it needs to perform its duty.
//
// NOTE: This method is part of the Estimator interface.
func (b *BitcoindEstimator) Start() error <span class="cov0" title="0">{
        // Once the connection to the backend node has been established, we'll
        // initialise the minimum relay fee manager which will query
        // the backend node for its minimum mempool fee.
        relayFeeManager, err := newMinFeeManager(
                defaultUpdateInterval,
                b.fetchMinMempoolFee,
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">b.minFeeManager = relayFeeManager

        b.filterManager.Start()

        return nil</span>
}

// fetchMinMempoolFee is used to fetch the minimum fee that the backend node
// requires for a tx to enter its mempool. The returned fee will be the
// maximum of the minimum relay fee and the minimum mempool fee.
func (b *BitcoindEstimator) fetchMinMempoolFee() (SatPerKWeight, error) <span class="cov0" title="0">{
        resp, err := b.bitcoindConn.RawRequest("getmempoolinfo", nil)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        // Parse the response to retrieve the min mempool fee in sat/KB.
        // mempoolminfee is the maximum of minrelaytxfee and
        // minimum mempool fee
        <span class="cov0" title="0">info := struct {
                MempoolMinFee float64 `json:"mempoolminfee"`
        }{}
        if err := json.Unmarshal(resp, &amp;info); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">minMempoolFee, err := btcutil.NewAmount(info.MempoolMinFee)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        // The fee rate is expressed in sat/kb, so we'll manually convert it to
        // our desired sat/kw rate.
        <span class="cov0" title="0">return SatPerKVByte(minMempoolFee).FeePerKWeight(), nil</span>
}

// Stop stops any spawned goroutines and cleans up the resources used
// by the fee estimator.
//
// NOTE: This method is part of the Estimator interface.
func (b *BitcoindEstimator) Stop() error <span class="cov0" title="0">{
        b.filterManager.Stop()
        return nil
}</span>

// EstimateFeePerKW takes in a target for the number of blocks until an initial
// confirmation and returns the estimated fee expressed in sat/kw.
//
// NOTE: This method is part of the Estimator interface.
func (b *BitcoindEstimator) EstimateFeePerKW(
        numBlocks uint32) (SatPerKWeight, error) <span class="cov0" title="0">{

        if numBlocks &gt; MaxBlockTarget </span><span class="cov0" title="0">{
                log.Debugf("conf target %d exceeds the max value, "+
                        "use %d instead.", numBlocks, MaxBlockTarget,
                )
                numBlocks = MaxBlockTarget
        }</span>

        <span class="cov0" title="0">feeEstimate, err := b.fetchEstimate(numBlocks, b.feeMode)
        switch </span>{
        // If the estimator doesn't have enough data, or returns an error, then
        // to return a proper value, then we'll return the default fall back
        // fee rate.
        case err != nil:<span class="cov0" title="0">
                log.Errorf("unable to query estimator: %v", err)
                fallthrough</span>

        case feeEstimate == 0:<span class="cov0" title="0">
                return b.fallbackFeePerKW, nil</span>
        }

        <span class="cov0" title="0">return feeEstimate, nil</span>
}

// RelayFeePerKW returns the minimum fee rate required for transactions to be
// relayed.
//
// NOTE: This method is part of the Estimator interface.
func (b *BitcoindEstimator) RelayFeePerKW() SatPerKWeight <span class="cov0" title="0">{
        // Get a suitable minimum feerate to use. This may optionally use the
        // median of our peers' feefilter values.
        feeCapClosure := func() (SatPerKWeight, error) </span><span class="cov0" title="0">{
                return b.fetchEstimateInner(
                        filterCapConfTarget, economicalFeeMode,
                )
        }</span>

        <span class="cov0" title="0">return chooseMinFee(
                b.minFeeManager.fetchMinFee, b.filterManager.FetchMedianFilter,
                feeCapClosure,
        )</span>
}

// fetchEstimate returns a fee estimate for a transaction to be confirmed in
// confTarget blocks. The estimate is returned in sat/kw.
func (b *BitcoindEstimator) fetchEstimate(confTarget uint32, feeMode string) (
        SatPerKWeight, error) <span class="cov0" title="0">{

        satPerKw, err := b.fetchEstimateInner(confTarget, feeMode)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        // Finally, we'll enforce our fee floor by choosing the higher of the
        // minimum relay fee and the feerate returned by the filterManager.
        <span class="cov0" title="0">absoluteMinFee := b.RelayFeePerKW()

        if satPerKw &lt; absoluteMinFee </span><span class="cov0" title="0">{
                log.Debugf("Estimated fee rate of %v sat/kw is too low, "+
                        "using fee floor of %v sat/kw instead", satPerKw,
                        absoluteMinFee)

                satPerKw = absoluteMinFee
        }</span>

        <span class="cov0" title="0">log.Debugf("Returning %v sat/kw for conf target of %v",
                int64(satPerKw), confTarget)

        return satPerKw, nil</span>
}

func (b *BitcoindEstimator) fetchEstimateInner(confTarget uint32,
        feeMode string) (SatPerKWeight, error) <span class="cov0" title="0">{

        // First, we'll send an "estimatesmartfee" command as a raw request,
        // since it isn't supported by btcd but is available in bitcoind.
        target, err := json.Marshal(uint64(confTarget))
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        // The mode must be either ECONOMICAL or CONSERVATIVE.
        <span class="cov0" title="0">mode, err := json.Marshal(feeMode)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">resp, err := b.bitcoindConn.RawRequest(
                "estimatesmartfee", []json.RawMessage{target, mode},
        )
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        // Next, we'll parse the response to get the BTC per KB.
        <span class="cov0" title="0">feeEstimate := struct {
                FeeRate float64 `json:"feerate"`
        }{}
        err = json.Unmarshal(resp, &amp;feeEstimate)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        // Next, we'll convert the returned value to satoshis, as it's currently
        // returned in BTC.
        <span class="cov0" title="0">satPerKB, err := btcutil.NewAmount(feeEstimate.FeeRate)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        // Bitcoind will not report any fee estimation if it has not enough
        // data available hence the fee will remain zero. We return an error
        // here to make sure that we do not use the min relay fee instead.
        <span class="cov0" title="0">if satPerKB == 0 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("fee estimation data not available yet")
        }</span>

        // Since we use fee rates in sat/kw internally, we'll convert the
        // estimated fee rate from its sat/kb representation to sat/kw.
        <span class="cov0" title="0">return SatPerKVByte(satPerKB).FeePerKWeight(), nil</span>
}

// chooseMinFee takes the minimum relay fee and the median of our peers'
// feefilter values and takes the higher of the two. It then compares the value
// against a maximum fee and caps it if the value is higher than the maximum
// fee. This function is only called if we have data for our peers' feefilter.
// The returned value will be used as the fee floor for calls to
// RelayFeePerKW.
func chooseMinFee(minRelayFeeFunc func() SatPerKWeight,
        medianFilterFunc func() (SatPerKWeight, error),
        feeCapFunc func() (SatPerKWeight, error)) SatPerKWeight <span class="cov0" title="0">{

        minRelayFee := minRelayFeeFunc()

        medianFilter, err := medianFilterFunc()
        if err != nil </span><span class="cov0" title="0">{
                // If we don't have feefilter data, we fallback to using our
                // minimum relay fee.
                return minRelayFee
        }</span>

        <span class="cov0" title="0">feeCap, err := feeCapFunc()
        if err != nil </span><span class="cov0" title="0">{
                // If we encountered an error, don't use the medianFilter and
                // instead fallback to using our minimum relay fee.
                return minRelayFee
        }</span>

        // If the median feefilter is higher than our minimum relay fee, use it
        // instead.
        <span class="cov0" title="0">if medianFilter &gt; minRelayFee </span><span class="cov0" title="0">{
                // Only apply the cap if the median filter was used. This is
                // to prevent an adversary from taking up the majority of our
                // outbound peer slots and forcing us to use a high median
                // filter value.
                if medianFilter &gt; feeCap </span><span class="cov0" title="0">{
                        return feeCap
                }</span>

                <span class="cov0" title="0">return medianFilter</span>
        }

        <span class="cov0" title="0">return minRelayFee</span>
}

// A compile-time assertion to ensure that BitcoindEstimator implements the
// Estimator interface.
var _ Estimator = (*BitcoindEstimator)(nil)

// WebAPIFeeSource is an interface allows the WebAPIEstimator to query an
// arbitrary HTTP-based fee estimator. Each new set/network will gain an
// implementation of this interface in order to allow the WebAPIEstimator to
// be fully generic in its logic.
type WebAPIFeeSource interface {
        // GetFeeInfo will query the web API, parse the response into a
        // WebAPIResponse which contains a map of confirmation targets to
        // sat/kw fees and min relay feerate.
        GetFeeInfo() (WebAPIResponse, error)
}

// SparseConfFeeSource is an implementation of the WebAPIFeeSource that utilizes
// a user-specified fee estimation API for Bitcoin. It expects the response
// to be in the JSON format: `fee_by_block_target: { ... }` where the value maps
// block targets to fee estimates (in sat per kilovbyte).
type SparseConfFeeSource struct {
        // URL is the fee estimation API specified by the user.
        URL string
}

// WebAPIResponse is the response returned by the fee estimation API.
type WebAPIResponse struct {
        // FeeByBlockTarget is a map of confirmation targets to sat/kvb fees.
        FeeByBlockTarget map[uint32]uint32 `json:"fee_by_block_target"`

        // MinRelayFeerate is the minimum relay fee in sat/kvb.
        MinRelayFeerate SatPerKVByte `json:"min_relay_feerate"`
}

// parseResponse attempts to parse the body of the response generated by the
// above query URL. Typically this will be JSON, but the specifics are left to
// the WebAPIFeeSource implementation.
func (s SparseConfFeeSource) parseResponse(r io.Reader) (
        WebAPIResponse, error) <span class="cov0" title="0">{

        resp := WebAPIResponse{
                FeeByBlockTarget: make(map[uint32]uint32),
                MinRelayFeerate:  0,
        }
        jsonReader := json.NewDecoder(r)
        if err := jsonReader.Decode(&amp;resp); err != nil </span><span class="cov0" title="0">{
                return WebAPIResponse{}, err
        }</span>

        <span class="cov0" title="0">if resp.MinRelayFeerate == 0 </span><span class="cov0" title="0">{
                log.Errorf("No min relay fee rate available, using default %v",
                        FeePerKwFloor)
                resp.MinRelayFeerate = FeePerKwFloor.FeePerKVByte()
        }</span>

        <span class="cov0" title="0">return resp, nil</span>
}

// GetFeeInfo will query the web API, parse the response and return a map of
// confirmation targets to sat/kw fees and min relay feerate in a parsed
// response.
func (s SparseConfFeeSource) GetFeeInfo() (WebAPIResponse, error) <span class="cov0" title="0">{
        // Rather than use the default http.Client, we'll make a custom one
        // which will allow us to control how long we'll wait to read the
        // response from the service. This way, if the service is down or
        // overloaded, we can exit early and use our default fee.
        netTransport := &amp;http.Transport{
                Dial: (&amp;net.Dialer{
                        Timeout: WebAPIConnectionTimeout,
                }).Dial,
                TLSHandshakeTimeout: WebAPIConnectionTimeout,
        }
        netClient := &amp;http.Client{
                Timeout:   WebAPIResponseTimeout,
                Transport: netTransport,
        }

        // With the client created, we'll query the API source to fetch the URL
        // that we should use to query for the fee estimation.
        targetURL := s.URL
        resp, err := netClient.Get(targetURL)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("unable to query web api for fee response: %v",
                        err)
                return WebAPIResponse{}, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        // Once we've obtained the response, we'll instruct the WebAPIFeeSource
        // to parse out the body to obtain our final result.
        parsedResp, err := s.parseResponse(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("unable to parse fee api response: %v", err)

                return WebAPIResponse{}, err
        }</span>

        <span class="cov0" title="0">return parsedResp, nil</span>
}

// A compile-time assertion to ensure that SparseConfFeeSource implements the
// WebAPIFeeSource interface.
var _ WebAPIFeeSource = (*SparseConfFeeSource)(nil)

// WebAPIEstimator is an implementation of the Estimator interface that
// queries an HTTP-based fee estimation from an existing web API.
type WebAPIEstimator struct {
        started atomic.Bool
        stopped atomic.Bool

        // apiSource is the backing web API source we'll use for our queries.
        apiSource WebAPIFeeSource

        // updateFeeTicker is the ticker responsible for updating the Estimator's
        // fee estimates every time it fires.
        updateFeeTicker *time.Ticker

        // feeByBlockTarget is our cache for fees pulled from the API. When a
        // fee estimate request comes in, we pull the estimate from this array
        // rather than re-querying the API, to prevent an inadvertent DoS attack.
        feesMtx          sync.Mutex
        feeByBlockTarget map[uint32]uint32
        minRelayFeerate  SatPerKVByte

        // noCache determines whether the web estimator should cache fee
        // estimates.
        noCache bool

        // minFeeUpdateTimeout represents the minimum interval in which the
        // web estimator will request fresh fees from its API.
        minFeeUpdateTimeout time.Duration

        // minFeeUpdateTimeout represents the maximum interval in which the
        // web estimator will request fresh fees from its API.
        maxFeeUpdateTimeout time.Duration

        quit chan struct{}
        wg   sync.WaitGroup
}

// NewWebAPIEstimator creates a new WebAPIEstimator from a given URL and a
// fallback default fee. The fees are updated whenever a new block is mined.
func NewWebAPIEstimator(api WebAPIFeeSource, noCache bool,
        minFeeUpdateTimeout time.Duration,
        maxFeeUpdateTimeout time.Duration) (*WebAPIEstimator, error) <span class="cov0" title="0">{

        if minFeeUpdateTimeout == 0 || maxFeeUpdateTimeout == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("minFeeUpdateTimeout and " +
                        "maxFeeUpdateTimeout must be greater than 0")
        }</span>

        <span class="cov0" title="0">if minFeeUpdateTimeout &gt;= maxFeeUpdateTimeout </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("minFeeUpdateTimeout target of %v "+
                        "cannot be greater than maxFeeUpdateTimeout of %v",
                        minFeeUpdateTimeout, maxFeeUpdateTimeout)
        }</span>

        <span class="cov0" title="0">return &amp;WebAPIEstimator{
                apiSource:           api,
                feeByBlockTarget:    make(map[uint32]uint32),
                noCache:             noCache,
                quit:                make(chan struct{}),
                minFeeUpdateTimeout: minFeeUpdateTimeout,
                maxFeeUpdateTimeout: maxFeeUpdateTimeout,
        }, nil</span>
}

// EstimateFeePerKW takes in a target for the number of blocks until an initial
// confirmation and returns the estimated fee expressed in sat/kw.
//
// NOTE: This method is part of the Estimator interface.
func (w *WebAPIEstimator) EstimateFeePerKW(numBlocks uint32) (
        SatPerKWeight, error) <span class="cov0" title="0">{

        // If the estimator hasn't been started yet, we'll return an error as
        // we can't provide a fee estimate.
        if !w.started.Load() </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("estimator not started")
        }</span>

        <span class="cov0" title="0">if numBlocks &gt; MaxBlockTarget </span><span class="cov0" title="0">{
                numBlocks = MaxBlockTarget
        }</span> else<span class="cov0" title="0"> if numBlocks &lt; minBlockTarget </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("conf target of %v is too low, minimum "+
                        "accepted is %v", numBlocks, minBlockTarget)
        }</span>

        // Get fee estimates now if we don't refresh periodically.
        <span class="cov0" title="0">if w.noCache </span><span class="cov0" title="0">{
                w.updateFeeEstimates()
        }</span>

        <span class="cov0" title="0">feePerKb, err := w.getCachedFee(numBlocks)

        // If the estimator returns an error, a zero value fee rate will be
        // returned. We will log the error and return the fall back fee rate
        // instead.
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("Unable to query estimator: %v", err)
        }</span>

        // If the result is too low, then we'll clamp it to our current fee
        // floor.
        <span class="cov0" title="0">satPerKw := SatPerKVByte(feePerKb).FeePerKWeight()
        if satPerKw &lt; FeePerKwFloor </span><span class="cov0" title="0">{
                satPerKw = FeePerKwFloor
        }</span>

        <span class="cov0" title="0">log.Debugf("Web API returning %v sat/kw for conf target of %v",
                int64(satPerKw), numBlocks)

        return satPerKw, nil</span>
}

// Start signals the Estimator to start any processes or goroutines it needs
// to perform its duty.
//
// NOTE: This method is part of the Estimator interface.
func (w *WebAPIEstimator) Start() error <span class="cov0" title="0">{
        log.Infof("Starting Web API fee estimator...")

        // Return an error if it's already been started.
        if w.started.Load() </span><span class="cov0" title="0">{
                return fmt.Errorf("web API fee estimator already started")
        }</span>
        <span class="cov0" title="0">defer w.started.Store(true)

        // During startup we'll query the API to initialize the fee map.
        w.updateFeeEstimates()

        // No update loop is needed when we don't cache.
        if w.noCache </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">feeUpdateTimeout := w.randomFeeUpdateTimeout()

        log.Infof("Web API fee estimator using update timeout of %v",
                feeUpdateTimeout)

        w.updateFeeTicker = time.NewTicker(feeUpdateTimeout)

        w.wg.Add(1)
        go w.feeUpdateManager()

        return nil</span>
}

// Stop stops any spawned goroutines and cleans up the resources used by the
// fee estimator.
//
// NOTE: This method is part of the Estimator interface.
func (w *WebAPIEstimator) Stop() error <span class="cov0" title="0">{
        log.Infof("Stopping web API fee estimator")

        if w.stopped.Swap(true) </span><span class="cov0" title="0">{
                return fmt.Errorf("web API fee estimator already stopped")
        }</span>

        // Update loop is not running when we don't cache.
        <span class="cov0" title="0">if w.noCache </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if w.updateFeeTicker != nil </span><span class="cov0" title="0">{
                w.updateFeeTicker.Stop()
        }</span>

        <span class="cov0" title="0">close(w.quit)
        w.wg.Wait()

        return nil</span>
}

// RelayFeePerKW returns the minimum fee rate required for transactions to be
// relayed.
//
// NOTE: This method is part of the Estimator interface.
func (w *WebAPIEstimator) RelayFeePerKW() SatPerKWeight <span class="cov0" title="0">{
        if !w.started.Load() </span><span class="cov0" title="0">{
                log.Error("WebAPIEstimator not started")
        }</span>

        // Get fee estimates now if we don't refresh periodically.
        <span class="cov0" title="0">if w.noCache </span><span class="cov0" title="0">{
                w.updateFeeEstimates()
        }</span>

        <span class="cov0" title="0">log.Infof("Web API returning %v for min relay feerate",
                w.minRelayFeerate)

        return w.minRelayFeerate.FeePerKWeight()</span>
}

// randomFeeUpdateTimeout returns a random timeout between minFeeUpdateTimeout
// and maxFeeUpdateTimeout that will be used to determine how often the Estimator
// should retrieve fresh fees from its API.
func (w *WebAPIEstimator) randomFeeUpdateTimeout() time.Duration <span class="cov0" title="0">{
        lower := int64(w.minFeeUpdateTimeout)
        upper := int64(w.maxFeeUpdateTimeout)
        return time.Duration(
                prand.Int63n(upper-lower) + lower, //nolint:gosec
        ).Round(time.Second)
}</span>

// getCachedFee takes a conf target and returns the cached fee rate. When the
// fee rate cannot be found, it will search the cache by decrementing the conf
// target until a fee rate is found. If still not found, it will return the fee
// rate of the minimum conf target cached, in other words, the most expensive
// fee rate it knows of.
func (w *WebAPIEstimator) getCachedFee(numBlocks uint32) (uint32, error) <span class="cov0" title="0">{
        w.feesMtx.Lock()
        defer w.feesMtx.Unlock()

        // If the cache is empty, return an error.
        if len(w.feeByBlockTarget) == 0 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("web API error: %w", errEmptyCache)
        }</span>

        // Search the conf target from the cache. We expect a query to the web
        // API has been made and the result has been cached at this point.
        <span class="cov0" title="0">fee, ok := w.feeByBlockTarget[numBlocks]

        // If the conf target can be found, exit early.
        if ok </span><span class="cov0" title="0">{
                return fee, nil
        }</span>

        // The conf target cannot be found. We will first search the cache
        // using a lower conf target. This is a conservative approach as the
        // fee rate returned will be larger than what's requested.
        <span class="cov0" title="0">for target := numBlocks; target &gt;= minBlockTarget; target-- </span><span class="cov0" title="0">{
                fee, ok := w.feeByBlockTarget[target]
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">log.Warnf("Web API does not have a fee rate for target=%d, "+
                        "using the fee rate for target=%d instead",
                        numBlocks, target)

                // Return the fee rate found, which will be more expensive than
                // requested. We will not cache the fee rate here in the hope
                // that the web API will later populate this value.
                return fee, nil</span>
        }

        // There are no lower conf targets cached, which is likely when the
        // requested conf target is 1. We will search the cache using a higher
        // conf target, which gives a fee rate that's cheaper than requested.
        //
        // NOTE: we can only get here iff the requested conf target is smaller
        // than the minimum conf target cached, so we return the minimum conf
        // target from the cache.
        <span class="cov0" title="0">minTargetCached := uint32(math.MaxUint32)
        for target := range w.feeByBlockTarget </span><span class="cov0" title="0">{
                if target &lt; minTargetCached </span><span class="cov0" title="0">{
                        minTargetCached = target
                }</span>
        }

        <span class="cov0" title="0">fee, ok = w.feeByBlockTarget[minTargetCached]
        if !ok </span><span class="cov0" title="0">{
                // We should never get here, just a vanity check.
                return 0, fmt.Errorf("web API error: %w, conf target: %d",
                        errNoFeeRateFound, numBlocks)
        }</span>

        // Log an error instead of a warning as a cheaper fee rate may delay
        // the confirmation for some important transactions.
        <span class="cov0" title="0">log.Errorf("Web API does not have a fee rate for target=%d, "+
                "using the fee rate for target=%d instead",
                numBlocks, minTargetCached)

        return fee, nil</span>
}

// updateFeeEstimates re-queries the API for fresh fees and caches them.
func (w *WebAPIEstimator) updateFeeEstimates() <span class="cov0" title="0">{
        // Once we've obtained the response, we'll instruct the WebAPIFeeSource
        // to parse out the body to obtain our final result.
        resp, err := w.apiSource.GetFeeInfo()
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("unable to get fee response: %v", err)
                return
        }</span>

        <span class="cov0" title="0">log.Debugf("Received response from source: %s", lnutils.NewLogClosure(
                func() string </span><span class="cov0" title="0">{
                        resp, _ := json.Marshal(resp)
                        return string(resp)
                }</span>))

        <span class="cov0" title="0">w.feesMtx.Lock()
        w.feeByBlockTarget = resp.FeeByBlockTarget
        w.minRelayFeerate = resp.MinRelayFeerate
        w.feesMtx.Unlock()</span>
}

// feeUpdateManager updates the fee estimates whenever a new block comes in.
func (w *WebAPIEstimator) feeUpdateManager() <span class="cov0" title="0">{
        defer w.wg.Done()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-w.updateFeeTicker.C:<span class="cov0" title="0">
                        w.updateFeeEstimates()</span>
                case &lt;-w.quit:<span class="cov0" title="0">
                        return</span>
                }
        }
}

// A compile-time assertion to ensure that WebAPIEstimator implements the
// Estimator interface.
var _ Estimator = (*WebAPIEstimator)(nil)
</pre>
		
		<pre class="file" id="file45" style="display: none">package chainfee

import (
        "encoding/json"
        "fmt"
        "sort"
        "sync"
        "time"

        "github.com/btcsuite/btcd/btcutil"
        "github.com/btcsuite/btcd/rpcclient"
        "github.com/lightningnetwork/lnd/fn/v2"
)

const (
        // fetchFilterInterval is the interval between successive fetches of
        // our peers' feefilters.
        fetchFilterInterval = time.Minute * 5

        // minNumFilters is the minimum number of feefilters we need during a
        // polling interval. If we have fewer than this, we won't consider the
        // data.
        minNumFilters = 6
)

var (
        // errNoData is an error that's returned if fetchMedianFilter is
        // called and there is no data available.
        errNoData = fmt.Errorf("no data available")
)

// filterManager is responsible for determining an acceptable minimum fee to
// use based on our peers' feefilter values.
type filterManager struct {
        // median stores the median of our outbound peer's feefilter values.
        median    fn.Option[SatPerKWeight]
        medianMtx sync.RWMutex

        fetchFunc func() ([]SatPerKWeight, error)

        wg   sync.WaitGroup
        quit chan struct{}
}

// newFilterManager constructs a filterManager with a callback that fetches the
// set of peers' feefilters.
func newFilterManager(cb func() ([]SatPerKWeight, error)) *filterManager <span class="cov0" title="0">{
        f := &amp;filterManager{
                quit: make(chan struct{}),
        }

        f.fetchFunc = cb

        return f
}</span>

// Start starts the filterManager.
func (f *filterManager) Start() <span class="cov0" title="0">{
        f.wg.Add(1)
        go f.fetchPeerFilters()
}</span>

// Stop stops the filterManager.
func (f *filterManager) Stop() <span class="cov0" title="0">{
        close(f.quit)
        f.wg.Wait()
}</span>

// fetchPeerFilters fetches our peers' feefilter values and calculates the
// median.
func (f *filterManager) fetchPeerFilters() <span class="cov0" title="0">{
        defer f.wg.Done()

        filterTicker := time.NewTicker(fetchFilterInterval)
        defer filterTicker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-filterTicker.C:<span class="cov0" title="0">
                        filters, err := f.fetchFunc()
                        if err != nil </span><span class="cov0" title="0">{
                                log.Errorf("Encountered err while fetching "+
                                        "fee filters: %v", err)
                                return
                        }</span>

                        <span class="cov0" title="0">f.updateMedian(filters)</span>

                case &lt;-f.quit:<span class="cov0" title="0">
                        return</span>
                }
        }
}

// fetchMedianFilter fetches the median feefilter value.
func (f *filterManager) FetchMedianFilter() (SatPerKWeight, error) <span class="cov0" title="0">{
        f.medianMtx.RLock()
        defer f.medianMtx.RUnlock()

        // If there is no median, return errNoData so the caller knows to
        // ignore the output and continue.
        return f.median.UnwrapOrErr(errNoData)
}</span>

type bitcoindPeerInfoResp struct {
        Inbound      bool    `json:"inbound"`
        MinFeeFilter float64 `json:"minfeefilter"`
}

func fetchBitcoindFilters(client *rpcclient.Client) ([]SatPerKWeight, error) <span class="cov0" title="0">{
        resp, err := client.RawRequest("getpeerinfo", nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var peerResps []bitcoindPeerInfoResp
        err = json.Unmarshal(resp, &amp;peerResps)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // We filter for outbound peers since it is harder for an attacker to
        // be our outbound peer and therefore harder for them to manipulate us
        // into broadcasting high-fee or low-fee transactions.
        <span class="cov0" title="0">var outboundPeerFilters []SatPerKWeight
        for _, peerResp := range peerResps </span><span class="cov0" title="0">{
                if peerResp.Inbound </span><span class="cov0" title="0">{
                        continue</span>
                }

                // The value that bitcoind returns for the "minfeefilter" field
                // is in fractions of a bitcoin that represents the satoshis
                // per KvB. We need to convert this fraction to whole satoshis
                // by multiplying with COIN. Then we need to convert the
                // sats/KvB to sats/KW.
                //
                // Convert the sats/KvB from fractions of a bitcoin to whole
                // satoshis.
                <span class="cov0" title="0">filterKVByte := SatPerKVByte(
                        peerResp.MinFeeFilter * btcutil.SatoshiPerBitcoin,
                )

                if !isWithinBounds(filterKVByte) </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Convert KvB to KW and add it to outboundPeerFilters.
                <span class="cov0" title="0">outboundPeerFilters = append(
                        outboundPeerFilters, filterKVByte.FeePerKWeight(),
                )</span>
        }

        // Check that we have enough data to use. We don't return an error as
        // that would stop the querying goroutine.
        <span class="cov0" title="0">if len(outboundPeerFilters) &lt; minNumFilters </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">return outboundPeerFilters, nil</span>
}

func fetchBtcdFilters(client *rpcclient.Client) ([]SatPerKWeight, error) <span class="cov0" title="0">{
        resp, err := client.GetPeerInfo()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var outboundPeerFilters []SatPerKWeight
        for _, peerResp := range resp </span><span class="cov0" title="0">{
                // We filter for outbound peers since it is harder for an
                // attacker to be our outbound peer and therefore harder for
                // them to manipulate us into broadcasting high-fee or low-fee
                // transactions.
                if peerResp.Inbound </span><span class="cov0" title="0">{
                        continue</span>
                }

                // The feefilter is already in units of sat/KvB.
                <span class="cov0" title="0">filter := SatPerKVByte(peerResp.FeeFilter)

                if !isWithinBounds(filter) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">outboundPeerFilters = append(
                        outboundPeerFilters, filter.FeePerKWeight(),
                )</span>
        }

        // Check that we have enough data to use. We don't return an error as
        // that would stop the querying goroutine.
        <span class="cov0" title="0">if len(outboundPeerFilters) &lt; minNumFilters </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">return outboundPeerFilters, nil</span>
}

// updateMedian takes a slice of feefilter values, computes the median, and
// updates our stored median value.
func (f *filterManager) updateMedian(feeFilters []SatPerKWeight) <span class="cov0" title="0">{
        // If there are no elements, don't update.
        numElements := len(feeFilters)
        if numElements == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">f.medianMtx.Lock()
        defer f.medianMtx.Unlock()

        // Log the new median.
        median := med(feeFilters)
        f.median = fn.Some(median)
        log.Debugf("filterManager updated moving median to: %v",
                median.FeePerKVByte())</span>
}

// isWithinBounds returns false if the filter is unusable and true if it is.
func isWithinBounds(filter SatPerKVByte) bool <span class="cov0" title="0">{
        // Ignore values of 0 and MaxSatoshi. A value of 0 likely means that
        // the peer hasn't sent over a feefilter and a value of MaxSatoshi
        // means the peer is using bitcoind and is in IBD.
        switch filter </span>{
        case 0:<span class="cov0" title="0">
                return false</span>

        case btcutil.MaxSatoshi:<span class="cov0" title="0">
                return false</span>
        }

        <span class="cov0" title="0">return true</span>
}

// med calculates the median of a slice.
// NOTE: Passing in an empty slice will panic!
func med(f []SatPerKWeight) SatPerKWeight <span class="cov0" title="0">{
        // Copy the original slice so that sorting doesn't modify the original.
        fCopy := make([]SatPerKWeight, len(f))
        copy(fCopy, f)

        sort.Slice(fCopy, func(i, j int) bool </span><span class="cov0" title="0">{
                return fCopy[i] &lt; fCopy[j]
        }</span>)

        <span class="cov0" title="0">var median SatPerKWeight

        numElements := len(fCopy)
        switch numElements % 2 </span>{
        case 0:<span class="cov0" title="0">
                // There's an even number of elements, so we need to average.
                middle := numElements / 2
                upper := fCopy[middle]
                lower := fCopy[middle-1]
                median = (upper + lower) / 2</span>

        case 1:<span class="cov0" title="0">
                median = fCopy[numElements/2]</span>
        }

        <span class="cov0" title="0">return median</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package chainfee

import (
        "github.com/btcsuite/btclog/v2"
        "github.com/lightningnetwork/lnd/build"
)

// log is a logger that is initialized with no output filters.  This means the
// package will not perform any logging by default until the caller requests
// it.
var log btclog.Logger

// The default amount of logging is none.
func init() <span class="cov8" title="1">{
        UseLogger(build.NewSubLogger("CFEE", nil))
}</span>

// DisableLog disables all library log output.  Logging output is disabled by
// default until UseLogger is called.
func DisableLog() <span class="cov0" title="0">{
        UseLogger(btclog.Disabled)
}</span>

// UseLogger uses a specified Logger to output package logging info.  This
// should be used in preference to SetLogWriter if the caller is also using
// btclog.
func UseLogger(logger btclog.Logger) <span class="cov8" title="1">{
        log = logger
}</span>
</pre>
		
		<pre class="file" id="file47" style="display: none">package chainfee

import (
        "sync"
        "time"
)

const defaultUpdateInterval = 10 * time.Minute

// minFeeManager is used to store and update the minimum fee that is required
// by a transaction to be accepted to the mempool. The minFeeManager ensures
// that the backend used to fetch the fee is not queried too regularly.
type minFeeManager struct {
        mu                sync.Mutex
        minFeePerKW       SatPerKWeight
        lastUpdatedTime   time.Time
        minUpdateInterval time.Duration
        fetchFeeFunc      fetchFee
}

// fetchFee represents a function that can be used to fetch a fee.
type fetchFee func() (SatPerKWeight, error)

// newMinFeeManager creates a new minFeeManager and uses the
// given fetchMinFee function to set the minFeePerKW of the minFeeManager.
// This function requires the fetchMinFee function to succeed.
func newMinFeeManager(minUpdateInterval time.Duration,
        fetchMinFee fetchFee) (*minFeeManager, error) <span class="cov0" title="0">{

        minFee, err := fetchMinFee()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Ensure that the minimum fee we use is always clamped by our fee
        // floor.
        <span class="cov0" title="0">if minFee &lt; FeePerKwFloor </span><span class="cov0" title="0">{
                minFee = FeePerKwFloor
        }</span>

        <span class="cov0" title="0">return &amp;minFeeManager{
                minFeePerKW:       minFee,
                lastUpdatedTime:   time.Now(),
                minUpdateInterval: minUpdateInterval,
                fetchFeeFunc:      fetchMinFee,
        }, nil</span>
}

// fetchMinFee returns the stored minFeePerKW if it has been updated recently
// or if the call to the chain backend fails. Otherwise, it sets the stored
// minFeePerKW to the fee returned from the backend and floors it based on
// our fee floor.
func (m *minFeeManager) fetchMinFee() SatPerKWeight <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if time.Since(m.lastUpdatedTime) &lt; m.minUpdateInterval </span><span class="cov0" title="0">{
                return m.minFeePerKW
        }</span>

        <span class="cov0" title="0">newMinFee, err := m.fetchFeeFunc()
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("Unable to fetch updated min fee from chain "+
                        "backend. Using last known min fee instead: %v", err)

                return m.minFeePerKW
        }</span>

        // By default, we'll use the backend node's minimum fee as the
        // minimum fee rate we'll propose for transactions. However, if this
        // happens to be lower than our fee floor, we'll enforce that instead.
        <span class="cov0" title="0">m.minFeePerKW = newMinFee
        if m.minFeePerKW &lt; FeePerKwFloor </span><span class="cov0" title="0">{
                m.minFeePerKW = FeePerKwFloor
        }</span>
        <span class="cov0" title="0">m.lastUpdatedTime = time.Now()

        log.Debugf("Using minimum fee rate of %v sat/kw",
                int64(m.minFeePerKW))

        return m.minFeePerKW</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package chainfee

import (
        "github.com/stretchr/testify/mock"
)

type mockFeeSource struct {
        mock.Mock
}

// A compile-time assertion to ensure that mockFeeSource implements the
// WebAPIFeeSource interface.
var _ WebAPIFeeSource = (*mockFeeSource)(nil)

func (m *mockFeeSource) GetFeeInfo() (WebAPIResponse, error) <span class="cov0" title="0">{
        args := m.Called()

        return args.Get(0).(WebAPIResponse), args.Error(1)
}</span>

// MockEstimator implements the `Estimator` interface and is used by
// other packages for mock testing.
type MockEstimator struct {
        mock.Mock
}

// Compile time assertion that MockEstimator implements Estimator.
var _ Estimator = (*MockEstimator)(nil)

// EstimateFeePerKW takes in a target for the number of blocks until an initial
// confirmation and returns the estimated fee expressed in sat/kw.
func (m *MockEstimator) EstimateFeePerKW(
        numBlocks uint32) (SatPerKWeight, error) <span class="cov0" title="0">{

        args := m.Called(numBlocks)

        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return 0, args.Error(1)
        }</span>

        <span class="cov0" title="0">return args.Get(0).(SatPerKWeight), args.Error(1)</span>
}

// Start signals the Estimator to start any processes or goroutines it needs to
// perform its duty.
func (m *MockEstimator) Start() error <span class="cov0" title="0">{
        args := m.Called()

        return args.Error(0)
}</span>

// Stop stops any spawned goroutines and cleans up the resources used by the
// fee estimator.
func (m *MockEstimator) Stop() error <span class="cov0" title="0">{
        args := m.Called()

        return args.Error(0)
}</span>

// RelayFeePerKW returns the minimum fee rate required for transactions to be
// relayed. This is also the basis for calculation of the dust limit.
func (m *MockEstimator) RelayFeePerKW() SatPerKWeight <span class="cov0" title="0">{
        args := m.Called()

        return args.Get(0).(SatPerKWeight)
}</span>
</pre>
		
		<pre class="file" id="file49" style="display: none">package chainfee

import (
        "fmt"

        "github.com/btcsuite/btcd/blockchain"
        "github.com/btcsuite/btcd/btcutil"
        "github.com/lightningnetwork/lnd/lntypes"
)

const (
        // FeePerKwFloor is the lowest fee rate in sat/kw that we should use for
        // estimating transaction fees before signing.
        FeePerKwFloor SatPerKWeight = 253

        // AbsoluteFeePerKwFloor is the lowest fee rate in sat/kw of a
        // transaction that we should ever _create_. This is the equivalent
        // of 1 sat/byte in sat/kw.
        AbsoluteFeePerKwFloor SatPerKWeight = 250
)

// SatPerVByte represents a fee rate in sat/vbyte.
type SatPerVByte btcutil.Amount

// FeePerKWeight converts the current fee rate from sat/vb to sat/kw.
func (s SatPerVByte) FeePerKWeight() SatPerKWeight <span class="cov0" title="0">{
        return SatPerKWeight(s * 1000 / blockchain.WitnessScaleFactor)
}</span>

// FeePerKVByte converts the current fee rate from sat/vb to sat/kvb.
func (s SatPerVByte) FeePerKVByte() SatPerKVByte <span class="cov0" title="0">{
        return SatPerKVByte(s * 1000)
}</span>

// String returns a human-readable string of the fee rate.
func (s SatPerVByte) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("%v sat/vb", int64(s))
}</span>

// SatPerKVByte represents a fee rate in sat/kb.
type SatPerKVByte btcutil.Amount

// FeeForVSize calculates the fee resulting from this fee rate and the given
// vsize in vbytes.
func (s SatPerKVByte) FeeForVSize(vbytes lntypes.VByte) btcutil.Amount <span class="cov0" title="0">{
        return btcutil.Amount(s) * btcutil.Amount(vbytes) / 1000
}</span>

// FeePerKWeight converts the current fee rate from sat/kb to sat/kw.
func (s SatPerKVByte) FeePerKWeight() SatPerKWeight <span class="cov0" title="0">{
        return SatPerKWeight(s / blockchain.WitnessScaleFactor)
}</span>

// String returns a human-readable string of the fee rate.
func (s SatPerKVByte) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("%v sat/kvb", int64(s))
}</span>

// SatPerKWeight represents a fee rate in sat/kw.
type SatPerKWeight btcutil.Amount

// NewSatPerKWeight creates a new fee rate in sat/kw.
func NewSatPerKWeight(fee btcutil.Amount, wu lntypes.WeightUnit) SatPerKWeight <span class="cov0" title="0">{
        return SatPerKWeight(fee.MulF64(1000 / float64(wu)))
}</span>

// FeeForWeight calculates the fee resulting from this fee rate and the given
// weight in weight units (wu).
func (s SatPerKWeight) FeeForWeight(wu lntypes.WeightUnit) btcutil.Amount <span class="cov0" title="0">{
        // The resulting fee is rounded down, as specified in BOLT#03.
        return btcutil.Amount(s) * btcutil.Amount(wu) / 1000
}</span>

// FeeForVByte calculates the fee resulting from this fee rate and the given
// size in vbytes (vb).
func (s SatPerKWeight) FeeForVByte(vb lntypes.VByte) btcutil.Amount <span class="cov0" title="0">{
        return s.FeePerKVByte().FeeForVSize(vb)
}</span>

// FeePerKVByte converts the current fee rate from sat/kw to sat/kb.
func (s SatPerKWeight) FeePerKVByte() SatPerKVByte <span class="cov0" title="0">{
        return SatPerKVByte(s * blockchain.WitnessScaleFactor)
}</span>

// FeePerVByte converts the current fee rate from sat/kw to sat/vb.
func (s SatPerKWeight) FeePerVByte() SatPerVByte <span class="cov0" title="0">{
        return SatPerVByte(s * blockchain.WitnessScaleFactor / 1000)
}</span>

// String returns a human-readable string of the fee rate.
func (s SatPerKWeight) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("%v sat/kw", int64(s))
}</span>
</pre>
		
		<pre class="file" id="file50" style="display: none">package lnwire

import (
        "bytes"
        "io"

        "github.com/btcsuite/btcd/btcec/v2"
        "github.com/btcsuite/btcd/btcutil"
        "github.com/lightningnetwork/lnd/tlv"
)

// AcceptChannel is the message Bob sends to Alice after she initiates the
// single funder channel workflow via an AcceptChannel message. Once Alice
// receives Bob's response, then she has all the items necessary to construct
// the funding transaction, and both commitment transactions.
type AcceptChannel struct {
        // PendingChannelID serves to uniquely identify the future channel
        // created by the initiated single funder workflow.
        PendingChannelID [32]byte

        // DustLimit is the specific dust limit the sender of this message
        // would like enforced on their version of the commitment transaction.
        // Any output below this value will be "trimmed" from the commitment
        // transaction, with the amount of the HTLC going to dust.
        DustLimit btcutil.Amount

        // MaxValueInFlight represents the maximum amount of coins that can be
        // pending within the channel at any given time. If the amount of funds
        // in limbo exceeds this amount, then the channel will be failed.
        MaxValueInFlight MilliSatoshi

        // ChannelReserve is the amount of BTC that the receiving party MUST
        // maintain a balance above at all times. This is a safety mechanism to
        // ensure that both sides always have skin in the game during the
        // channel's lifetime.
        ChannelReserve btcutil.Amount

        // HtlcMinimum is the smallest HTLC that the sender of this message
        // will accept.
        HtlcMinimum MilliSatoshi

        // MinAcceptDepth is the minimum depth that the initiator of the
        // channel should wait before considering the channel open.
        MinAcceptDepth uint32

        // CsvDelay is the number of blocks to use for the relative time lock
        // in the pay-to-self output of both commitment transactions.
        CsvDelay uint16

        // MaxAcceptedHTLCs is the total number of incoming HTLC's that the
        // sender of this channel will accept.
        //
        // TODO(roasbeef): acks the initiator's, same with max in flight?
        MaxAcceptedHTLCs uint16

        // FundingKey is the key that should be used on behalf of the sender
        // within the 2-of-2 multi-sig output that it contained within the
        // funding transaction.
        FundingKey *btcec.PublicKey

        // RevocationPoint is the base revocation point for the sending party.
        // Any commitment transaction belonging to the receiver of this message
        // should use this key and their per-commitment point to derive the
        // revocation key for the commitment transaction.
        RevocationPoint *btcec.PublicKey

        // PaymentPoint is the base payment point for the sending party. This
        // key should be combined with the per commitment point for a
        // particular commitment state in order to create the key that should
        // be used in any output that pays directly to the sending party, and
        // also within the HTLC covenant transactions.
        PaymentPoint *btcec.PublicKey

        // DelayedPaymentPoint is the delay point for the sending party. This
        // key should be combined with the per commitment point to derive the
        // keys that are used in outputs of the sender's commitment transaction
        // where they claim funds.
        DelayedPaymentPoint *btcec.PublicKey

        // HtlcPoint is the base point used to derive the set of keys for this
        // party that will be used within the HTLC public key scripts.  This
        // value is combined with the receiver's revocation base point in order
        // to derive the keys that are used within HTLC scripts.
        HtlcPoint *btcec.PublicKey

        // FirstCommitmentPoint is the first commitment point for the sending
        // party. This value should be combined with the receiver's revocation
        // base point in order to derive the revocation keys that are placed
        // within the commitment transaction of the sender.
        FirstCommitmentPoint *btcec.PublicKey

        // UpfrontShutdownScript is the script to which the channel funds should
        // be paid when mutually closing the channel. This field is optional, and
        // and has a length prefix, so a zero will be written if it is not set
        // and its length followed by the script will be written if it is set.
        UpfrontShutdownScript DeliveryAddress

        // ChannelType is the explicit channel type the initiator wishes to
        // open.
        ChannelType *ChannelType

        // LeaseExpiry represents the absolute expiration height of a channel
        // lease. This is a custom TLV record that will only apply when a leased
        // channel is being opened using the script enforced lease commitment
        // type.
        LeaseExpiry *LeaseExpiry

        // LocalNonce is an optional field that transmits the
        // local/verification nonce for a party. This nonce will be used to
        // verify the very first commitment transaction signature.
        // This will only be populated if the simple taproot channels type was
        // negotiated.
        LocalNonce OptMusig2NonceTLV

        // ExtraData is the set of data that was appended to this message to
        // fill out the full maximum transport message size. These fields can
        // be used to specify optional data such as custom TLV fields.
        //
        // NOTE: Since the upfront shutdown script MUST be present (though can
        // be zero-length) if any TLV data is available, the script will be
        // extracted and removed from this blob when decoding. ExtraData will
        // contain all TLV records _except_ the DeliveryAddress record in that
        // case.
        ExtraData ExtraOpaqueData
}

// A compile time check to ensure AcceptChannel implements the lnwire.Message
// interface.
var _ Message = (*AcceptChannel)(nil)

// A compile time check to ensure AcceptChannel implements the
// lnwire.SizeableMessage interface.
var _ SizeableMessage = (*AcceptChannel)(nil)

// Encode serializes the target AcceptChannel into the passed io.Writer
// implementation. Serialization will observe the rules defined by the passed
// protocol version.
//
// This is part of the lnwire.Message interface.
func (a *AcceptChannel) Encode(w *bytes.Buffer, pver uint32) error <span class="cov0" title="0">{
        recordProducers := []tlv.RecordProducer{&amp;a.UpfrontShutdownScript}
        if a.ChannelType != nil </span><span class="cov0" title="0">{
                recordProducers = append(recordProducers, a.ChannelType)
        }</span>
        <span class="cov0" title="0">if a.LeaseExpiry != nil </span><span class="cov0" title="0">{
                recordProducers = append(recordProducers, a.LeaseExpiry)
        }</span>
        <span class="cov0" title="0">a.LocalNonce.WhenSome(func(localNonce Musig2NonceTLV) </span><span class="cov0" title="0">{
                recordProducers = append(recordProducers, &amp;localNonce)
        }</span>)
        <span class="cov0" title="0">err := EncodeMessageExtraData(&amp;a.ExtraData, recordProducers...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteBytes(w, a.PendingChannelID[:]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteSatoshi(w, a.DustLimit); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteMilliSatoshi(w, a.MaxValueInFlight); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteSatoshi(w, a.ChannelReserve); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteMilliSatoshi(w, a.HtlcMinimum); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteUint32(w, a.MinAcceptDepth); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteUint16(w, a.CsvDelay); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteUint16(w, a.MaxAcceptedHTLCs); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WritePublicKey(w, a.FundingKey); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WritePublicKey(w, a.RevocationPoint); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WritePublicKey(w, a.PaymentPoint); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WritePublicKey(w, a.DelayedPaymentPoint); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WritePublicKey(w, a.HtlcPoint); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WritePublicKey(w, a.FirstCommitmentPoint); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return WriteBytes(w, a.ExtraData)</span>
}

// Decode deserializes the serialized AcceptChannel stored in the passed
// io.Reader into the target AcceptChannel using the deserialization rules
// defined by the passed protocol version.
//
// This is part of the lnwire.Message interface.
func (a *AcceptChannel) Decode(r io.Reader, pver uint32) error <span class="cov0" title="0">{
        // Read all the mandatory fields in the accept message.
        err := ReadElements(r,
                a.PendingChannelID[:],
                &amp;a.DustLimit,
                &amp;a.MaxValueInFlight,
                &amp;a.ChannelReserve,
                &amp;a.HtlcMinimum,
                &amp;a.MinAcceptDepth,
                &amp;a.CsvDelay,
                &amp;a.MaxAcceptedHTLCs,
                &amp;a.FundingKey,
                &amp;a.RevocationPoint,
                &amp;a.PaymentPoint,
                &amp;a.DelayedPaymentPoint,
                &amp;a.HtlcPoint,
                &amp;a.FirstCommitmentPoint,
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // For backwards compatibility, the optional extra data blob for
        // AcceptChannel must contain an entry for the upfront shutdown script.
        // We'll read it out and attempt to parse it.
        <span class="cov0" title="0">var tlvRecords ExtraOpaqueData
        if err := ReadElements(r, &amp;tlvRecords); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Next we'll parse out the set of known records, keeping the raw tlv
        // bytes untouched to ensure we don't drop any bytes erroneously.
        <span class="cov0" title="0">var (
                chanType    ChannelType
                leaseExpiry LeaseExpiry
                localNonce  = a.LocalNonce.Zero()
        )
        typeMap, err := tlvRecords.ExtractRecords(
                &amp;a.UpfrontShutdownScript, &amp;chanType, &amp;leaseExpiry,
                &amp;localNonce,
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Set the corresponding TLV types if they were included in the stream.
        <span class="cov0" title="0">if val, ok := typeMap[ChannelTypeRecordType]; ok &amp;&amp; val == nil </span><span class="cov0" title="0">{
                a.ChannelType = &amp;chanType
        }</span>
        <span class="cov0" title="0">if val, ok := typeMap[LeaseExpiryRecordType]; ok &amp;&amp; val == nil </span><span class="cov0" title="0">{
                a.LeaseExpiry = &amp;leaseExpiry
        }</span>
        <span class="cov0" title="0">if val, ok := typeMap[a.LocalNonce.TlvType()]; ok &amp;&amp; val == nil </span><span class="cov0" title="0">{
                a.LocalNonce = tlv.SomeRecordT(localNonce)
        }</span>

        <span class="cov0" title="0">a.ExtraData = tlvRecords

        return nil</span>
}

// MsgType returns the MessageType code which uniquely identifies this message
// as an AcceptChannel on the wire.
//
// This is part of the lnwire.Message interface.
func (a *AcceptChannel) MsgType() MessageType <span class="cov0" title="0">{
        return MsgAcceptChannel
}</span>

// SerializedSize returns the serialized size of the message in bytes.
//
// This is part of the lnwire.SizeableMessage interface.
func (a *AcceptChannel) SerializedSize() (uint32, error) <span class="cov0" title="0">{
        return MessageSerializedSize(a)
}</span>
</pre>
		
		<pre class="file" id="file51" style="display: none">package lnwire

import (
        "bytes"
        "io"
)

// AnnounceSignatures1 is a direct message between two endpoints of a
// channel and serves as an opt-in mechanism to allow the announcement of
// the channel to the rest of the network. It contains the necessary
// signatures by the sender to construct the channel announcement message.
type AnnounceSignatures1 struct {
        // ChannelID is the unique description of the funding transaction.
        // Channel id is better for users and debugging and short channel id is
        // used for quick test on existence of the particular utxo inside the
        // block chain, because it contains information about block.
        ChannelID ChannelID

        // ShortChannelID is the unique description of the funding
        // transaction. It is constructed with the most significant 3 bytes
        // as the block height, the next 3 bytes indicating the transaction
        // index within the block, and the least significant two bytes
        // indicating the output index which pays to the channel.
        ShortChannelID ShortChannelID

        // NodeSignature is the signature which contains the signed announce
        // channel message, by this signature we proof that we possess of the
        // node pub key and creating the reference node_key -&gt; bitcoin_key.
        NodeSignature Sig

        // BitcoinSignature is the signature which contains the signed node
        // public key, by this signature we proof that we possess of the
        // bitcoin key and and creating the reverse reference bitcoin_key -&gt;
        // node_key.
        BitcoinSignature Sig

        // ExtraOpaqueData is the set of data that was appended to this
        // message, some of which we may not actually know how to iterate or
        // parse. By holding onto this data, we ensure that we're able to
        // properly validate the set of signatures that cover these new fields,
        // and ensure we're able to make upgrades to the network in a forwards
        // compatible manner.
        ExtraOpaqueData ExtraOpaqueData
}

// A compile time check to ensure AnnounceSignatures1 implements the
// lnwire.Message interface.
var _ Message = (*AnnounceSignatures1)(nil)

// A compile time check to ensure AnnounceSignatures1 implements the
// lnwire.SizeableMessage interface.
var _ SizeableMessage = (*AnnounceSignatures1)(nil)

// A compile time check to ensure AnnounceSignatures1 implements the
// lnwire.AnnounceSignatures interface.
var _ AnnounceSignatures = (*AnnounceSignatures1)(nil)

// Decode deserializes a serialized AnnounceSignatures1 stored in the passed
// io.Reader observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (a *AnnounceSignatures1) Decode(r io.Reader, _ uint32) error <span class="cov0" title="0">{
        return ReadElements(r,
                &amp;a.ChannelID,
                &amp;a.ShortChannelID,
                &amp;a.NodeSignature,
                &amp;a.BitcoinSignature,
                &amp;a.ExtraOpaqueData,
        )
}</span>

// Encode serializes the target AnnounceSignatures1 into the passed io.Writer
// observing the protocol version specified.
//
// This is part of the lnwire.Message interface.
func (a *AnnounceSignatures1) Encode(w *bytes.Buffer, _ uint32) error <span class="cov0" title="0">{
        if err := WriteChannelID(w, a.ChannelID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteShortChannelID(w, a.ShortChannelID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteSig(w, a.NodeSignature); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteSig(w, a.BitcoinSignature); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return WriteBytes(w, a.ExtraOpaqueData)</span>
}

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (a *AnnounceSignatures1) MsgType() MessageType <span class="cov0" title="0">{
        return MsgAnnounceSignatures
}</span>

// SerializedSize returns the serialized size of the message in bytes.
//
// This is part of the lnwire.SizeableMessage interface.
func (a *AnnounceSignatures1) SerializedSize() (uint32, error) <span class="cov0" title="0">{
        return MessageSerializedSize(a)
}</span>

// SCID returns the ShortChannelID of the channel.
//
// This is part of the lnwire.AnnounceSignatures interface.
func (a *AnnounceSignatures1) SCID() ShortChannelID <span class="cov0" title="0">{
        return a.ShortChannelID
}</span>

// ChanID returns the ChannelID identifying the channel.
//
// This is part of the lnwire.AnnounceSignatures interface.
func (a *AnnounceSignatures1) ChanID() ChannelID <span class="cov0" title="0">{
        return a.ChannelID
}</span>
</pre>
		
		<pre class="file" id="file52" style="display: none">package lnwire

import (
        "bytes"
        "io"
)

// AnnounceSignatures2 is a direct message between two endpoints of a
// channel and serves as an opt-in mechanism to allow the announcement of
// a taproot channel to the rest of the network. It contains the necessary
// signatures by the sender to construct the channel_announcement_2 message.
type AnnounceSignatures2 struct {
        // ChannelID is the unique description of the funding transaction.
        // Channel id is better for users and debugging and short channel id is
        // used for quick test on existence of the particular utxo inside the
        // blockchain, because it contains information about block.
        ChannelID ChannelID

        // ShortChannelID is the unique description of the funding transaction.
        // It is constructed with the most significant 3 bytes as the block
        // height, the next 3 bytes indicating the transaction index within the
        // block, and the least significant two bytes indicating the output
        // index which pays to the channel.
        ShortChannelID ShortChannelID

        // PartialSignature is the combination of the partial Schnorr signature
        // created for the node's bitcoin key with the partial signature created
        // for the node's node ID key.
        PartialSignature PartialSig

        // ExtraOpaqueData is the set of data that was appended to this
        // message, some of which we may not actually know how to iterate or
        // parse. By holding onto this data, we ensure that we're able to
        // properly validate the set of signatures that cover these new fields,
        // and ensure we're able to make upgrades to the network in a forwards
        // compatible manner.
        ExtraOpaqueData ExtraOpaqueData
}

// A compile time check to ensure AnnounceSignatures2 implements the
// lnwire.Message interface.
var _ Message = (*AnnounceSignatures2)(nil)

// A compile time check to ensure AnnounceSignatures2 implements the
// lnwire.SizeableMessage interface.
var _ SizeableMessage = (*AnnounceSignatures2)(nil)

// Decode deserializes a serialized AnnounceSignatures2 stored in the passed
// io.Reader observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (a *AnnounceSignatures2) Decode(r io.Reader, _ uint32) error <span class="cov0" title="0">{
        return ReadElements(r,
                &amp;a.ChannelID,
                &amp;a.ShortChannelID,
                &amp;a.PartialSignature,
                &amp;a.ExtraOpaqueData,
        )
}</span>

// Encode serializes the target AnnounceSignatures2 into the passed io.Writer
// observing the protocol version specified.
//
// This is part of the lnwire.Message interface.
func (a *AnnounceSignatures2) Encode(w *bytes.Buffer, _ uint32) error <span class="cov0" title="0">{
        if err := WriteChannelID(w, a.ChannelID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteShortChannelID(w, a.ShortChannelID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteElement(w, a.PartialSignature); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return WriteBytes(w, a.ExtraOpaqueData)</span>
}

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (a *AnnounceSignatures2) MsgType() MessageType <span class="cov0" title="0">{
        return MsgAnnounceSignatures2
}</span>

// SerializedSize returns the serialized size of the message in bytes.
//
// This is part of the lnwire.SizeableMessage interface.
func (a *AnnounceSignatures2) SerializedSize() (uint32, error) <span class="cov0" title="0">{
        return MessageSerializedSize(a)
}</span>

// SCID returns the ShortChannelID of the channel.
//
// NOTE: this is part of the AnnounceSignatures interface.
func (a *AnnounceSignatures2) SCID() ShortChannelID <span class="cov0" title="0">{
        return a.ShortChannelID
}</span>

// ChanID returns the ChannelID identifying the channel.
//
// NOTE: this is part of the AnnounceSignatures interface.
func (a *AnnounceSignatures2) ChanID() ChannelID <span class="cov0" title="0">{
        return a.ChannelID
}</span>
</pre>
		
		<pre class="file" id="file53" style="display: none">package lnwire

import (
        "bytes"
        "io"

        "github.com/btcsuite/btcd/chaincfg/chainhash"
)

// ChannelAnnouncement1 message is used to announce the existence of a channel
// between two peers in the overlay, which is propagated by the discovery
// service over broadcast handler.
type ChannelAnnouncement1 struct {
        // This signatures are used by nodes in order to create cross
        // references between node's channel and node. Requiring both nodes
        // to sign indicates they are both willing to route other payments via
        // this node.
        NodeSig1 Sig
        NodeSig2 Sig

        // This signatures are used by nodes in order to create cross
        // references between node's channel and node. Requiring the bitcoin
        // signatures proves they control the channel.
        BitcoinSig1 Sig
        BitcoinSig2 Sig

        // Features is the feature vector that encodes the features supported
        // by the target node. This field can be used to signal the type of the
        // channel, or modifications to the fields that would normally follow
        // this vector.
        Features *RawFeatureVector

        // ChainHash denotes the target chain that this channel was opened
        // within. This value should be the genesis hash of the target chain.
        ChainHash chainhash.Hash

        // ShortChannelID is the unique description of the funding transaction,
        // or where exactly it's located within the target blockchain.
        ShortChannelID ShortChannelID

        // The public keys of the two nodes who are operating the channel, such
        // that is NodeID1 the numerically-lesser than NodeID2 (ascending
        // numerical order).
        NodeID1 [33]byte
        NodeID2 [33]byte

        // Public keys which corresponds to the keys which was declared in
        // multisig funding transaction output.
        BitcoinKey1 [33]byte
        BitcoinKey2 [33]byte

        // ExtraOpaqueData is the set of data that was appended to this
        // message, some of which we may not actually know how to iterate or
        // parse. By holding onto this data, we ensure that we're able to
        // properly validate the set of signatures that cover these new fields,
        // and ensure we're able to make upgrades to the network in a forwards
        // compatible manner.
        ExtraOpaqueData ExtraOpaqueData
}

// A compile time check to ensure ChannelAnnouncement implements the
// lnwire.Message interface.
var _ Message = (*ChannelAnnouncement1)(nil)

// A compile time check to ensure ChannelAnnouncement1 implements the
// lnwire.SizeableMessage interface.
var _ SizeableMessage = (*ChannelAnnouncement1)(nil)

// Decode deserializes a serialized ChannelAnnouncement stored in the passed
// io.Reader observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (a *ChannelAnnouncement1) Decode(r io.Reader, pver uint32) error <span class="cov0" title="0">{
        return ReadElements(r,
                &amp;a.NodeSig1,
                &amp;a.NodeSig2,
                &amp;a.BitcoinSig1,
                &amp;a.BitcoinSig2,
                &amp;a.Features,
                a.ChainHash[:],
                &amp;a.ShortChannelID,
                &amp;a.NodeID1,
                &amp;a.NodeID2,
                &amp;a.BitcoinKey1,
                &amp;a.BitcoinKey2,
                &amp;a.ExtraOpaqueData,
        )
}</span>

// Encode serializes the target ChannelAnnouncement into the passed io.Writer
// observing the protocol version specified.
//
// This is part of the lnwire.Message interface.
func (a *ChannelAnnouncement1) Encode(w *bytes.Buffer, pver uint32) error <span class="cov0" title="0">{
        if err := WriteSig(w, a.NodeSig1); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteSig(w, a.NodeSig2); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteSig(w, a.BitcoinSig1); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteSig(w, a.BitcoinSig2); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteRawFeatureVector(w, a.Features); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteBytes(w, a.ChainHash[:]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteShortChannelID(w, a.ShortChannelID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteBytes(w, a.NodeID1[:]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteBytes(w, a.NodeID2[:]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteBytes(w, a.BitcoinKey1[:]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteBytes(w, a.BitcoinKey2[:]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return WriteBytes(w, a.ExtraOpaqueData)</span>
}

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (a *ChannelAnnouncement1) MsgType() MessageType <span class="cov0" title="0">{
        return MsgChannelAnnouncement
}</span>

// SerializedSize returns the serialized size of the message in bytes.
//
// This is part of the lnwire.SizeableMessage interface.
func (a *ChannelAnnouncement1) SerializedSize() (uint32, error) <span class="cov0" title="0">{
        return MessageSerializedSize(a)
}</span>

// DataToSign is used to retrieve part of the announcement message which should
// be signed.
func (a *ChannelAnnouncement1) DataToSign() ([]byte, error) <span class="cov0" title="0">{
        // We should not include the signatures itself.
        b := make([]byte, 0, MaxMsgBody)
        buf := bytes.NewBuffer(b)

        if err := WriteRawFeatureVector(buf, a.Features); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := WriteBytes(buf, a.ChainHash[:]); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := WriteShortChannelID(buf, a.ShortChannelID); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := WriteBytes(buf, a.NodeID1[:]); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := WriteBytes(buf, a.NodeID2[:]); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := WriteBytes(buf, a.BitcoinKey1[:]); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := WriteBytes(buf, a.BitcoinKey2[:]); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := WriteBytes(buf, a.ExtraOpaqueData); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return buf.Bytes(), nil</span>
}

// Node1KeyBytes returns the bytes representing the public key of node 1 in the
// channel.
//
// NOTE: This is part of the ChannelAnnouncement interface.
func (a *ChannelAnnouncement1) Node1KeyBytes() [33]byte <span class="cov0" title="0">{
        return a.NodeID1
}</span>

// Node2KeyBytes returns the bytes representing the public key of node 2 in the
// channel.
//
// NOTE: This is part of the ChannelAnnouncement interface.
func (a *ChannelAnnouncement1) Node2KeyBytes() [33]byte <span class="cov0" title="0">{
        return a.NodeID2
}</span>

// GetChainHash returns the hash of the chain which this channel's funding
// transaction is confirmed in.
//
// NOTE: This is part of the ChannelAnnouncement interface.
func (a *ChannelAnnouncement1) GetChainHash() chainhash.Hash <span class="cov0" title="0">{
        return a.ChainHash
}</span>

// SCID returns the short channel ID of the channel.
//
// NOTE: This is part of the ChannelAnnouncement interface.
func (a *ChannelAnnouncement1) SCID() ShortChannelID <span class="cov0" title="0">{
        return a.ShortChannelID
}</span>

// A compile-time check to ensure that ChannelAnnouncement1 implements the
// ChannelAnnouncement interface.
var _ ChannelAnnouncement = (*ChannelAnnouncement1)(nil)
</pre>
		
		<pre class="file" id="file54" style="display: none">package lnwire

import (
        "bytes"
        "io"

        "github.com/btcsuite/btcd/chaincfg"
        "github.com/btcsuite/btcd/chaincfg/chainhash"
        "github.com/lightningnetwork/lnd/tlv"
)

// ChannelAnnouncement2 message is used to announce the existence of a taproot
// channel between two peers in the network.
type ChannelAnnouncement2 struct {
        // Signature is a Schnorr signature over the TLV stream of the message.
        Signature Sig

        // ChainHash denotes the target chain that this channel was opened
        // within. This value should be the genesis hash of the target chain.
        ChainHash tlv.RecordT[tlv.TlvType0, chainhash.Hash]

        // Features is the feature vector that encodes the features supported
        // by the target node. This field can be used to signal the type of the
        // channel, or modifications to the fields that would normally follow
        // this vector.
        Features tlv.RecordT[tlv.TlvType2, RawFeatureVector]

        // ShortChannelID is the unique description of the funding transaction,
        // or where exactly it's located within the target blockchain.
        ShortChannelID tlv.RecordT[tlv.TlvType4, ShortChannelID]

        // Capacity is the number of satoshis of the capacity of this channel.
        // It must be less than or equal to the value of the on-chain funding
        // output.
        Capacity tlv.RecordT[tlv.TlvType6, uint64]

        // NodeID1 is the numerically-lesser public key ID of one of the channel
        // operators.
        NodeID1 tlv.RecordT[tlv.TlvType8, [33]byte]

        // NodeID2 is the numerically-greater public key ID of one of the
        // channel operators.
        NodeID2 tlv.RecordT[tlv.TlvType10, [33]byte]

        // BitcoinKey1 is the public key of the key used by Node1 in the
        // construction of the on-chain funding transaction. This is an optional
        // field and only needs to be set if the 4-of-4 MuSig construction was
        // used in the creation of the message signature.
        BitcoinKey1 tlv.OptionalRecordT[tlv.TlvType12, [33]byte]

        // BitcoinKey2 is the public key of the key used by Node2 in the
        // construction of the on-chain funding transaction. This is an optional
        // field and only needs to be set if the 4-of-4 MuSig construction was
        // used in the creation of the message signature.
        BitcoinKey2 tlv.OptionalRecordT[tlv.TlvType14, [33]byte]

        // MerkleRootHash is the hash used to create the optional tweak in the
        // funding output. If this is not set but the bitcoin keys are, then
        // the funding output is a pure 2-of-2 MuSig aggregate public key.
        MerkleRootHash tlv.OptionalRecordT[tlv.TlvType16, [32]byte]

        // ExtraOpaqueData is the set of data that was appended to this
        // message, some of which we may not actually know how to iterate or
        // parse. By holding onto this data, we ensure that we're able to
        // properly validate the set of signatures that cover these new fields,
        // and ensure we're able to make upgrades to the network in a forwards
        // compatible manner.
        ExtraOpaqueData ExtraOpaqueData
}

// Decode deserializes a serialized AnnounceSignatures1 stored in the passed
// io.Reader observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (c *ChannelAnnouncement2) Decode(r io.Reader, _ uint32) error <span class="cov0" title="0">{
        err := ReadElement(r, &amp;c.Signature)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">c.Signature.ForceSchnorr()

        return c.DecodeTLVRecords(r)</span>
}

// DecodeTLVRecords decodes only the TLV section of the message.
func (c *ChannelAnnouncement2) DecodeTLVRecords(r io.Reader) error <span class="cov0" title="0">{
        // First extract into extra opaque data.
        var tlvRecords ExtraOpaqueData
        if err := ReadElements(r, &amp;tlvRecords); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var (
                chainHash      = tlv.ZeroRecordT[tlv.TlvType0, [32]byte]()
                btcKey1        = tlv.ZeroRecordT[tlv.TlvType12, [33]byte]()
                btcKey2        = tlv.ZeroRecordT[tlv.TlvType14, [33]byte]()
                merkleRootHash = tlv.ZeroRecordT[tlv.TlvType16, [32]byte]()
        )
        typeMap, err := tlvRecords.ExtractRecords(
                &amp;chainHash, &amp;c.Features, &amp;c.ShortChannelID, &amp;c.Capacity,
                &amp;c.NodeID1, &amp;c.NodeID2, &amp;btcKey1, &amp;btcKey2, &amp;merkleRootHash,
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // By default, the chain-hash is the bitcoin mainnet genesis block hash.
        <span class="cov0" title="0">c.ChainHash.Val = *chaincfg.MainNetParams.GenesisHash
        if _, ok := typeMap[c.ChainHash.TlvType()]; ok </span><span class="cov0" title="0">{
                c.ChainHash.Val = chainHash.Val
        }</span>

        <span class="cov0" title="0">if _, ok := typeMap[c.BitcoinKey1.TlvType()]; ok </span><span class="cov0" title="0">{
                c.BitcoinKey1 = tlv.SomeRecordT(btcKey1)
        }</span>

        <span class="cov0" title="0">if _, ok := typeMap[c.BitcoinKey2.TlvType()]; ok </span><span class="cov0" title="0">{
                c.BitcoinKey2 = tlv.SomeRecordT(btcKey2)
        }</span>

        <span class="cov0" title="0">if _, ok := typeMap[c.MerkleRootHash.TlvType()]; ok </span><span class="cov0" title="0">{
                c.MerkleRootHash = tlv.SomeRecordT(merkleRootHash)
        }</span>

        <span class="cov0" title="0">if len(tlvRecords) != 0 </span><span class="cov0" title="0">{
                c.ExtraOpaqueData = tlvRecords
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Encode serializes the target AnnounceSignatures1 into the passed io.Writer
// observing the protocol version specified.
//
// This is part of the lnwire.Message interface.
func (c *ChannelAnnouncement2) Encode(w *bytes.Buffer, _ uint32) error <span class="cov0" title="0">{
        _, err := w.Write(c.Signature.RawBytes())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">_, err = c.DataToSign()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return WriteBytes(w, c.ExtraOpaqueData)</span>
}

// DataToSign encodes the data to be signed into the ExtraOpaqueData member and
// returns it.
func (c *ChannelAnnouncement2) DataToSign() ([]byte, error) <span class="cov0" title="0">{
        // The chain-hash record is only included if it is _not_ equal to the
        // bitcoin mainnet genisis block hash.
        var recordProducers []tlv.RecordProducer
        if !c.ChainHash.Val.IsEqual(chaincfg.MainNetParams.GenesisHash) </span><span class="cov0" title="0">{
                hash := tlv.ZeroRecordT[tlv.TlvType0, [32]byte]()
                hash.Val = c.ChainHash.Val

                recordProducers = append(recordProducers, &amp;hash)
        }</span>

        <span class="cov0" title="0">recordProducers = append(recordProducers,
                &amp;c.Features, &amp;c.ShortChannelID, &amp;c.Capacity, &amp;c.NodeID1,
                &amp;c.NodeID2,
        )

        c.BitcoinKey1.WhenSome(func(key tlv.RecordT[tlv.TlvType12, [33]byte]) </span><span class="cov0" title="0">{
                recordProducers = append(recordProducers, &amp;key)
        }</span>)

        <span class="cov0" title="0">c.BitcoinKey2.WhenSome(func(key tlv.RecordT[tlv.TlvType14, [33]byte]) </span><span class="cov0" title="0">{
                recordProducers = append(recordProducers, &amp;key)
        }</span>)

        <span class="cov0" title="0">c.MerkleRootHash.WhenSome(
                func(hash tlv.RecordT[tlv.TlvType16, [32]byte]) </span><span class="cov0" title="0">{
                        recordProducers = append(recordProducers, &amp;hash)
                }</span>,
        )

        <span class="cov0" title="0">err := EncodeMessageExtraData(&amp;c.ExtraOpaqueData, recordProducers...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return c.ExtraOpaqueData, nil</span>
}

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (c *ChannelAnnouncement2) MsgType() MessageType <span class="cov0" title="0">{
        return MsgChannelAnnouncement2
}</span>

// SerializedSize returns the serialized size of the message in bytes.
//
// This is part of the lnwire.SizeableMessage interface.
func (c *ChannelAnnouncement2) SerializedSize() (uint32, error) <span class="cov0" title="0">{
        return MessageSerializedSize(c)
}</span>

// A compile time check to ensure ChannelAnnouncement2 implements the
// lnwire.Message interface.
var _ Message = (*ChannelAnnouncement2)(nil)

// A compile time check to ensure ChannelAnnouncement2 implements the
// lnwire.SizeableMessage interface.
var _ SizeableMessage = (*ChannelAnnouncement2)(nil)

// Node1KeyBytes returns the bytes representing the public key of node 1 in the
// channel.
//
// NOTE: This is part of the ChannelAnnouncement interface.
func (c *ChannelAnnouncement2) Node1KeyBytes() [33]byte <span class="cov0" title="0">{
        return c.NodeID1.Val
}</span>

// Node2KeyBytes returns the bytes representing the public key of node 2 in the
// channel.
//
// NOTE: This is part of the ChannelAnnouncement interface.
func (c *ChannelAnnouncement2) Node2KeyBytes() [33]byte <span class="cov0" title="0">{
        return c.NodeID2.Val
}</span>

// GetChainHash returns the hash of the chain which this channel's funding
// transaction is confirmed in.
//
// NOTE: This is part of the ChannelAnnouncement interface.
func (c *ChannelAnnouncement2) GetChainHash() chainhash.Hash <span class="cov0" title="0">{
        return c.ChainHash.Val
}</span>

// SCID returns the short channel ID of the channel.
//
// NOTE: This is part of the ChannelAnnouncement interface.
func (c *ChannelAnnouncement2) SCID() ShortChannelID <span class="cov0" title="0">{
        return c.ShortChannelID.Val
}</span>

// A compile-time check to ensure that ChannelAnnouncement2 implements the
// ChannelAnnouncement interface.
var _ ChannelAnnouncement = (*ChannelAnnouncement2)(nil)
</pre>
		
		<pre class="file" id="file55" style="display: none">package lnwire

import (
        "encoding/binary"
        "encoding/hex"
        "math"

        "github.com/btcsuite/btcd/chaincfg/chainhash"
        "github.com/btcsuite/btcd/wire"
)

const (
        // MaxFundingTxOutputs is the maximum number of allowed outputs on a
        // funding transaction within the protocol. This is due to the fact
        // that we use 2-bytes to encode the index within the funding output
        // during the funding workflow. Funding transaction with more outputs
        // than this are considered invalid within the protocol.
        MaxFundingTxOutputs = math.MaxUint16
)

// ChannelID is a series of 32-bytes that uniquely identifies all channels
// within the network. The ChannelID is computed using the outpoint of the
// funding transaction (the txid, and output index). Given a funding output the
// ChannelID can be calculated by XOR'ing the big-endian serialization of the
// txid and the big-endian serialization of the output index, truncated to
// 2 bytes.
type ChannelID [32]byte

// ConnectionWideID is an all-zero ChannelID, which is used to represent a
// message intended for all channels to specific peer.
var ConnectionWideID = ChannelID{}

// String returns the string representation of the ChannelID. This is just the
// hex string encoding of the ChannelID itself.
func (c ChannelID) String() string <span class="cov0" title="0">{
        return hex.EncodeToString(c[:])
}</span>

// NewChanIDFromOutPoint converts a target OutPoint into a ChannelID that is
// usable within the network. In order to convert the OutPoint into a ChannelID,
// we XOR the lower 2-bytes of the txid within the OutPoint with the big-endian
// serialization of the Index of the OutPoint, truncated to 2-bytes.
func NewChanIDFromOutPoint(op wire.OutPoint) ChannelID <span class="cov0" title="0">{
        // First we'll copy the txid of the outpoint into our channel ID slice.
        var cid ChannelID
        copy(cid[:], op.Hash[:])

        // With the txid copied over, we'll now XOR the lower 2-bytes of the
        // partial channelID with big-endian serialization of output index.
        xorTxid(&amp;cid, uint16(op.Index))

        return cid
}</span>

// xorTxid performs the transformation needed to transform an OutPoint into a
// ChannelID. To do this, we expect the cid parameter to contain the txid
// unaltered and the outputIndex to be the output index
func xorTxid(cid *ChannelID, outputIndex uint16) <span class="cov0" title="0">{
        var buf [2]byte
        binary.BigEndian.PutUint16(buf[:], outputIndex)

        cid[30] ^= buf[0]
        cid[31] ^= buf[1]
}</span>

// GenPossibleOutPoints generates all the possible outputs given a channel ID.
// In order to generate these possible outpoints, we perform a brute-force
// search through the candidate output index space, performing a reverse
// mapping from channelID back to OutPoint.
func (c *ChannelID) GenPossibleOutPoints() [MaxFundingTxOutputs]wire.OutPoint <span class="cov0" title="0">{
        var possiblePoints [MaxFundingTxOutputs]wire.OutPoint
        for i := uint16(0); i &lt; MaxFundingTxOutputs; i++ </span><span class="cov0" title="0">{
                cidCopy := *c
                xorTxid(&amp;cidCopy, i)

                possiblePoints[i] = wire.OutPoint{
                        Hash:  chainhash.Hash(cidCopy),
                        Index: uint32(i),
                }
        }</span>

        <span class="cov0" title="0">return possiblePoints</span>
}

// IsChanPoint returns true if the OutPoint passed corresponds to the target
// ChannelID.
func (c ChannelID) IsChanPoint(op *wire.OutPoint) bool <span class="cov0" title="0">{
        candidateCid := NewChanIDFromOutPoint(*op)

        return candidateCid == c
}</span>
</pre>
		
		<pre class="file" id="file56" style="display: none">package lnwire

import (
        "bytes"
        "io"

        "github.com/btcsuite/btcd/btcec/v2"
        "github.com/lightningnetwork/lnd/tlv"
)

// ChannelReady is the message that both parties to a new channel creation
// send once they have observed the funding transaction being confirmed on the
// blockchain. ChannelReady contains the signatures necessary for the channel
// participants to advertise the existence of the channel to the rest of the
// network.
type ChannelReady struct {
        // ChanID is the outpoint of the channel's funding transaction. This
        // can be used to query for the channel in the database.
        ChanID ChannelID

        // NextPerCommitmentPoint is the secret that can be used to revoke the
        // next commitment transaction for the channel.
        NextPerCommitmentPoint *btcec.PublicKey

        // AliasScid is an alias ShortChannelID used to refer to the underlying
        // channel. It can be used instead of the confirmed on-chain
        // ShortChannelID for forwarding.
        AliasScid *ShortChannelID

        // NextLocalNonce is an optional field that stores a local musig2 nonce.
        // This will only be populated if the simple taproot channels type was
        // negotiated. This is the local nonce that will be used by the sender
        // to accept a new commitment state transition.
        NextLocalNonce OptMusig2NonceTLV

        // AnnouncementNodeNonce is an optional field that stores a public
        // nonce that will be used along with the node's ID key during signing
        // of the ChannelAnnouncement2 message.
        AnnouncementNodeNonce tlv.OptionalRecordT[tlv.TlvType0, Musig2Nonce]

        // AnnouncementBitcoinNonce is an optional field that stores a public
        // nonce that will be used along with the node's bitcoin key during
        // signing of the ChannelAnnouncement2 message.
        AnnouncementBitcoinNonce tlv.OptionalRecordT[tlv.TlvType2, Musig2Nonce]

        // ExtraData is the set of data that was appended to this message to
        // fill out the full maximum transport message size. These fields can
        // be used to specify optional data such as custom TLV fields.
        ExtraData ExtraOpaqueData
}

// NewChannelReady creates a new ChannelReady message, populating it with the
// necessary IDs and revocation secret.
func NewChannelReady(cid ChannelID, npcp *btcec.PublicKey) *ChannelReady <span class="cov0" title="0">{
        return &amp;ChannelReady{
                ChanID:                 cid,
                NextPerCommitmentPoint: npcp,
                ExtraData:              nil,
        }
}</span>

// A compile time check to ensure ChannelReady implements the lnwire.Message
// interface.
var _ Message = (*ChannelReady)(nil)

// A compile time check to ensure ChannelReady implements the
// lnwire.SizeableMessage interface.
var _ SizeableMessage = (*ChannelReady)(nil)

// Decode deserializes the serialized ChannelReady message stored in the
// passed io.Reader into the target ChannelReady using the deserialization
// rules defined by the passed protocol version.
//
// This is part of the lnwire.Message interface.
func (c *ChannelReady) Decode(r io.Reader, _ uint32) error <span class="cov0" title="0">{
        // Read all the mandatory fields in the message.
        err := ReadElements(r,
                &amp;c.ChanID,
                &amp;c.NextPerCommitmentPoint,
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var tlvRecords ExtraOpaqueData
        if err := ReadElements(r, &amp;tlvRecords); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Next we'll parse out the set of known records. For now, this is just
        // the AliasScidRecordType.
        <span class="cov0" title="0">var (
                aliasScid  ShortChannelID
                localNonce = c.NextLocalNonce.Zero()
                nodeNonce  = tlv.ZeroRecordT[tlv.TlvType0, Musig2Nonce]()
                btcNonce   = tlv.ZeroRecordT[tlv.TlvType2, Musig2Nonce]()
        )
        typeMap, err := tlvRecords.ExtractRecords(
                &amp;btcNonce, &amp;aliasScid, &amp;nodeNonce, &amp;localNonce,
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // We'll only set AliasScid if the corresponding TLV type was included
        // in the stream.
        <span class="cov0" title="0">if val, ok := typeMap[AliasScidRecordType]; ok &amp;&amp; val == nil </span><span class="cov0" title="0">{
                c.AliasScid = &amp;aliasScid
        }</span>
        <span class="cov0" title="0">if val, ok := typeMap[c.NextLocalNonce.TlvType()]; ok &amp;&amp; val == nil </span><span class="cov0" title="0">{
                c.NextLocalNonce = tlv.SomeRecordT(localNonce)
        }</span>
        <span class="cov0" title="0">val, ok := typeMap[c.AnnouncementBitcoinNonce.TlvType()]
        if ok &amp;&amp; val == nil </span><span class="cov0" title="0">{
                c.AnnouncementBitcoinNonce = tlv.SomeRecordT(btcNonce)
        }</span>
        <span class="cov0" title="0">val, ok = typeMap[c.AnnouncementNodeNonce.TlvType()]
        if ok &amp;&amp; val == nil </span><span class="cov0" title="0">{
                c.AnnouncementNodeNonce = tlv.SomeRecordT(nodeNonce)
        }</span>

        <span class="cov0" title="0">if len(tlvRecords) != 0 </span><span class="cov0" title="0">{
                c.ExtraData = tlvRecords
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Encode serializes the target ChannelReady message into the passed io.Writer
// implementation. Serialization will observe the rules defined by the passed
// protocol version.
//
// This is part of the lnwire.Message interface.
func (c *ChannelReady) Encode(w *bytes.Buffer, _ uint32) error <span class="cov0" title="0">{
        if err := WriteChannelID(w, c.ChanID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WritePublicKey(w, c.NextPerCommitmentPoint); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // We'll only encode the AliasScid in a TLV segment if it exists.
        <span class="cov0" title="0">recordProducers := make([]tlv.RecordProducer, 0, 4)
        if c.AliasScid != nil </span><span class="cov0" title="0">{
                recordProducers = append(recordProducers, c.AliasScid)
        }</span>
        <span class="cov0" title="0">c.NextLocalNonce.WhenSome(func(localNonce Musig2NonceTLV) </span><span class="cov0" title="0">{
                recordProducers = append(recordProducers, &amp;localNonce)
        }</span>)
        <span class="cov0" title="0">c.AnnouncementBitcoinNonce.WhenSome(
                func(nonce tlv.RecordT[tlv.TlvType2, Musig2Nonce]) </span><span class="cov0" title="0">{
                        recordProducers = append(recordProducers, &amp;nonce)
                }</span>,
        )
        <span class="cov0" title="0">c.AnnouncementNodeNonce.WhenSome(
                func(nonce tlv.RecordT[tlv.TlvType0, Musig2Nonce]) </span><span class="cov0" title="0">{
                        recordProducers = append(recordProducers, &amp;nonce)
                }</span>,
        )

        <span class="cov0" title="0">err := EncodeMessageExtraData(&amp;c.ExtraData, recordProducers...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return WriteBytes(w, c.ExtraData)</span>
}

// MsgType returns the uint32 code which uniquely identifies this message as a
// ChannelReady message on the wire.
//
// This is part of the lnwire.Message interface.
func (c *ChannelReady) MsgType() MessageType <span class="cov0" title="0">{
        return MsgChannelReady
}</span>

// SerializedSize returns the serialized size of the message in bytes.
//
// This is part of the lnwire.SizeableMessage interface.
func (c *ChannelReady) SerializedSize() (uint32, error) <span class="cov0" title="0">{
        return MessageSerializedSize(c)
}</span>
</pre>
		
		<pre class="file" id="file57" style="display: none">package lnwire

import (
        "bytes"
        "io"

        "github.com/btcsuite/btcd/btcec/v2"
        "github.com/lightningnetwork/lnd/fn/v2"
        "github.com/lightningnetwork/lnd/tlv"
)

const (
        CRDynHeight tlv.Type = 20
)

// DynHeight is a newtype wrapper to get the proper RecordProducer instance
// to smoothly integrate with the ChannelReestablish Message instance.
type DynHeight uint64

// Record implements the RecordProducer interface, allowing a full tlv.Record
// object to be constructed from a DynHeight.
func (d *DynHeight) Record() tlv.Record <span class="cov0" title="0">{
        return tlv.MakePrimitiveRecord(CRDynHeight, (*uint64)(d))
}</span>

// ChannelReestablish is a message sent between peers that have an existing
// open channel upon connection reestablishment. This message allows both sides
// to report their local state, and their current knowledge of the state of the
// remote commitment chain. If a deviation is detected and can be recovered
// from, then the necessary messages will be retransmitted. If the level of
// desynchronization is irreconcilable, then the channel will be force closed.
type ChannelReestablish struct {
        // ChanID is the channel ID of the channel state we're attempting to
        // synchronize with the remote party.
        ChanID ChannelID

        // NextLocalCommitHeight is the next local commitment height of the
        // sending party. If the height of the sender's commitment chain from
        // the receiver's Pov is one less that this number, then the sender
        // should re-send the *exact* same proposed commitment.
        //
        // In other words, the receiver should re-send their last sent
        // commitment iff:
        //
        //  * NextLocalCommitHeight == remoteCommitChain.Height
        //
        // This covers the case of a lost commitment which was sent by the
        // sender of this message, but never received by the receiver of this
        // message.
        NextLocalCommitHeight uint64

        // RemoteCommitTailHeight is the height of the receiving party's
        // unrevoked commitment from the PoV of the sender of this message. If
        // the height of the receiver's commitment is *one more* than this
        // value, then their prior RevokeAndAck message should be
        // retransmitted.
        //
        // In other words, the receiver should re-send their last sent
        // RevokeAndAck message iff:
        //
        //  * localCommitChain.tail().Height == RemoteCommitTailHeight + 1
        //
        // This covers the case of a lost revocation, wherein the receiver of
        // the message sent a revocation for a prior state, but the sender of
        // the message never fully processed it.
        RemoteCommitTailHeight uint64

        // LastRemoteCommitSecret is the last commitment secret that the
        // receiving node has sent to the sending party. This will be the
        // secret of the last revoked commitment transaction. Including this
        // provides proof that the sending node at least knows of this state,
        // as they couldn't have produced it if it wasn't sent, as the value
        // can be authenticated by querying the shachain or the receiving
        // party.
        LastRemoteCommitSecret [32]byte

        // LocalUnrevokedCommitPoint is the commitment point used in the
        // current un-revoked commitment transaction of the sending party.
        LocalUnrevokedCommitPoint *btcec.PublicKey

        // LocalNonce is an optional field that stores a local musig2 nonce.
        // This will only be populated if the simple taproot channels type was
        // negotiated.
        //
        LocalNonce OptMusig2NonceTLV

        // DynHeight is an optional field that stores the dynamic commitment
        // negotiation height that is incremented upon successful completion of
        // a dynamic commitment negotiation
        DynHeight fn.Option[DynHeight]

        // ExtraData is the set of data that was appended to this message to
        // fill out the full maximum transport message size. These fields can
        // be used to specify optional data such as custom TLV fields.
        ExtraData ExtraOpaqueData
}

// A compile time check to ensure ChannelReestablish implements the
// lnwire.Message interface.
var _ Message = (*ChannelReestablish)(nil)

// A compile time check to ensure ChannelReestablish implements the
// lnwire.SizeableMessage interface.
var _ SizeableMessage = (*ChannelReestablish)(nil)

// Encode serializes the target ChannelReestablish into the passed io.Writer
// observing the protocol version specified.
//
// This is part of the lnwire.Message interface.
func (a *ChannelReestablish) Encode(w *bytes.Buffer, pver uint32) error <span class="cov0" title="0">{
        if err := WriteChannelID(w, a.ChanID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteUint64(w, a.NextLocalCommitHeight); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteUint64(w, a.RemoteCommitTailHeight); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // If the commit point wasn't sent, then we won't write out any of the
        // remaining fields as they're optional.
        <span class="cov0" title="0">if a.LocalUnrevokedCommitPoint == nil </span><span class="cov0" title="0">{
                // However, we'll still write out the extra data if it's
                // present.
                //
                // NOTE: This is here primarily for the quickcheck tests, in
                // practice, we'll always populate this field.
                return WriteBytes(w, a.ExtraData)
        }</span>

        // Otherwise, we'll write out the remaining elements.
        <span class="cov0" title="0">if err := WriteBytes(w, a.LastRemoteCommitSecret[:]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WritePublicKey(w, a.LocalUnrevokedCommitPoint); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">recordProducers := make([]tlv.RecordProducer, 0, 1)
        a.LocalNonce.WhenSome(func(localNonce Musig2NonceTLV) </span><span class="cov0" title="0">{
                recordProducers = append(recordProducers, &amp;localNonce)
        }</span>)
        <span class="cov0" title="0">a.DynHeight.WhenSome(func(h DynHeight) </span><span class="cov0" title="0">{
                recordProducers = append(recordProducers, &amp;h)
        }</span>)

        <span class="cov0" title="0">err := EncodeMessageExtraData(&amp;a.ExtraData, recordProducers...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return WriteBytes(w, a.ExtraData)</span>
}

// Decode deserializes a serialized ChannelReestablish stored in the passed
// io.Reader observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (a *ChannelReestablish) Decode(r io.Reader, pver uint32) error <span class="cov0" title="0">{
        err := ReadElements(r,
                &amp;a.ChanID,
                &amp;a.NextLocalCommitHeight,
                &amp;a.RemoteCommitTailHeight,
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // This message has currently defined optional fields. As a result,
        // we'll only proceed if there's still bytes remaining within the
        // reader.
        //
        // We'll manually parse out the optional fields in order to be able to
        // still utilize the io.Reader interface.

        // We'll first attempt to read the optional commit secret, if we're at
        // the EOF, then this means the field wasn't included so we can exit
        // early.
        <span class="cov0" title="0">var buf [32]byte
        _, err = io.ReadFull(r, buf[:32])
        if err == io.EOF </span><span class="cov0" title="0">{
                // If there aren't any more bytes, then we'll emplace an empty
                // extra data to make our quickcheck tests happy.
                a.ExtraData = make([]byte, 0)
                return nil
        }</span> else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // If the field is present, then we'll copy it over and proceed.
        <span class="cov0" title="0">copy(a.LastRemoteCommitSecret[:], buf[:])

        // We'll conclude by parsing out the commitment point. We don't check
        // the error in this case, as it has included the commit secret, then
        // they MUST also include the commit point.
        if err = ReadElement(r, &amp;a.LocalUnrevokedCommitPoint); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var tlvRecords ExtraOpaqueData
        if err := ReadElements(r, &amp;tlvRecords); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var (
                dynHeight  DynHeight
                localNonce = a.LocalNonce.Zero()
        )
        typeMap, err := tlvRecords.ExtractRecords(
                &amp;localNonce, &amp;dynHeight,
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if val, ok := typeMap[a.LocalNonce.TlvType()]; ok &amp;&amp; val == nil </span><span class="cov0" title="0">{
                a.LocalNonce = tlv.SomeRecordT(localNonce)
        }</span>
        <span class="cov0" title="0">if val, ok := typeMap[CRDynHeight]; ok &amp;&amp; val == nil </span><span class="cov0" title="0">{
                a.DynHeight = fn.Some(dynHeight)
        }</span>

        <span class="cov0" title="0">if len(tlvRecords) != 0 </span><span class="cov0" title="0">{
                a.ExtraData = tlvRecords
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (a *ChannelReestablish) MsgType() MessageType <span class="cov0" title="0">{
        return MsgChannelReestablish
}</span>

// SerializedSize returns the serialized size of the message in bytes.
//
// This is part of the lnwire.SizeableMessage interface.
func (a *ChannelReestablish) SerializedSize() (uint32, error) <span class="cov0" title="0">{
        return MessageSerializedSize(a)
}</span>
</pre>
		
		<pre class="file" id="file58" style="display: none">package lnwire

import (
        "io"

        "github.com/lightningnetwork/lnd/tlv"
)

const (
        // ChannelTypeRecordType is the type of the experimental record used
        // to denote which channel type is being negotiated.
        ChannelTypeRecordType tlv.Type = 1
)

// ChannelType represents a specific channel type as a set of feature bits that
// comprise it.
type ChannelType RawFeatureVector

// featureBitLen returns the length in bytes of the encoded feature bits.
func (c ChannelType) featureBitLen() uint64 <span class="cov0" title="0">{
        fv := RawFeatureVector(c)
        return fv.sizeFunc()
}</span>

// Record returns a TLV record that can be used to encode/decode the channel
// type from a given TLV stream.
func (c *ChannelType) Record() tlv.Record <span class="cov0" title="0">{
        return tlv.MakeDynamicRecord(
                ChannelTypeRecordType, c, c.featureBitLen, channelTypeEncoder,
                channelTypeDecoder,
        )
}</span>

// channelTypeEncoder is a custom TLV encoder for the ChannelType record.
func channelTypeEncoder(w io.Writer, val interface{}, buf *[8]byte) error <span class="cov0" title="0">{
        if v, ok := val.(*ChannelType); ok </span><span class="cov0" title="0">{
                fv := RawFeatureVector(*v)
                return rawFeatureEncoder(w, &amp;fv, buf)
        }</span>

        <span class="cov0" title="0">return tlv.NewTypeForEncodingErr(val, "*lnwire.ChannelType")</span>
}

// channelTypeDecoder is a custom TLV decoder for the ChannelType record.
func channelTypeDecoder(r io.Reader, val interface{}, buf *[8]byte,
        l uint64) error <span class="cov0" title="0">{

        if v, ok := val.(*ChannelType); ok </span><span class="cov0" title="0">{
                fv := NewRawFeatureVector()

                if err := rawFeatureDecoder(r, fv, buf, l); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">*v = ChannelType(*fv)
                return nil</span>
        }

        <span class="cov0" title="0">return tlv.NewTypeForEncodingErr(val, "*lnwire.ChannelType")</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">package lnwire

import (
        "bytes"
        "fmt"
        "io"

        "github.com/btcsuite/btcd/chaincfg/chainhash"
)

// ChanUpdateMsgFlags is a bitfield that signals whether optional fields are
// present in the ChannelUpdate.
type ChanUpdateMsgFlags uint8

const (
        // ChanUpdateRequiredMaxHtlc is a bit that indicates whether the
        // required htlc_maximum_msat field is present in this ChannelUpdate.
        ChanUpdateRequiredMaxHtlc ChanUpdateMsgFlags = 1 &lt;&lt; iota
)

// String returns the bitfield flags as a string.
func (c ChanUpdateMsgFlags) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("%08b", c)
}</span>

// HasMaxHtlc returns true if the htlc_maximum_msat option bit is set in the
// message flags.
func (c ChanUpdateMsgFlags) HasMaxHtlc() bool <span class="cov0" title="0">{
        return c&amp;ChanUpdateRequiredMaxHtlc != 0
}</span>

// ChanUpdateChanFlags is a bitfield that signals various options concerning a
// particular channel edge. Each bit is to be examined in order to determine
// how the ChannelUpdate message is to be interpreted.
type ChanUpdateChanFlags uint8

const (
        // ChanUpdateDirection indicates the direction of a channel update. If
        // this bit is set to 0 if Node1 (the node with the "smaller" Node ID)
        // is updating the channel, and to 1 otherwise.
        ChanUpdateDirection ChanUpdateChanFlags = 1 &lt;&lt; iota

        // ChanUpdateDisabled is a bit that indicates if the channel edge
        // selected by the ChanUpdateDirection bit is to be treated as being
        // disabled.
        ChanUpdateDisabled
)

// IsDisabled determines whether the channel flags has the disabled bit set.
func (c ChanUpdateChanFlags) IsDisabled() bool <span class="cov0" title="0">{
        return c&amp;ChanUpdateDisabled == ChanUpdateDisabled
}</span>

// String returns the bitfield flags as a string.
func (c ChanUpdateChanFlags) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("%08b", c)
}</span>

// ChannelUpdate1 message is used after channel has been initially announced.
// Each side independently announces its fees and minimum expiry for HTLCs and
// other parameters. Also this message is used to redeclare initially set
// channel parameters.
type ChannelUpdate1 struct {
        // Signature is used to validate the announced data and prove the
        // ownership of node id.
        Signature Sig

        // ChainHash denotes the target chain that this channel was opened
        // within. This value should be the genesis hash of the target chain.
        // Along with the short channel ID, this uniquely identifies the
        // channel globally in a blockchain.
        ChainHash chainhash.Hash

        // ShortChannelID is the unique description of the funding transaction.
        ShortChannelID ShortChannelID

        // Timestamp allows ordering in the case of multiple announcements. We
        // should ignore the message if timestamp is not greater than
        // the last-received.
        Timestamp uint32

        // MessageFlags is a bitfield that describes whether optional fields
        // are present in this update. Currently, the least-significant bit
        // must be set to 1 if the optional field MaxHtlc is present.
        MessageFlags ChanUpdateMsgFlags

        // ChannelFlags is a bitfield that describes additional meta-data
        // concerning how the update is to be interpreted. Currently, the
        // least-significant bit must be set to 0 if the creating node
        // corresponds to the first node in the previously sent channel
        // announcement and 1 otherwise. If the second bit is set, then the
        // channel is set to be disabled.
        ChannelFlags ChanUpdateChanFlags

        // TimeLockDelta is the minimum number of blocks this node requires to
        // be added to the expiry of HTLCs. This is a security parameter
        // determined by the node operator. This value represents the required
        // gap between the time locks of the incoming and outgoing HTLC's set
        // to this node.
        TimeLockDelta uint16

        // HtlcMinimumMsat is the minimum HTLC value which will be accepted.
        HtlcMinimumMsat MilliSatoshi

        // BaseFee is the base fee that must be used for incoming HTLC's to
        // this particular channel. This value will be tacked onto the required
        // for a payment independent of the size of the payment.
        BaseFee uint32

        // FeeRate is the fee rate that will be charged per millionth of a
        // satoshi.
        FeeRate uint32

        // HtlcMaximumMsat is the maximum HTLC value which will be accepted.
        HtlcMaximumMsat MilliSatoshi

        // ExtraData is the set of data that was appended to this message to
        // fill out the full maximum transport message size. These fields can
        // be used to specify optional data such as custom TLV fields.
        ExtraOpaqueData ExtraOpaqueData
}

// A compile time check to ensure ChannelUpdate implements the lnwire.Message
// interface.
var _ Message = (*ChannelUpdate1)(nil)

// A compile time check to ensure ChannelUpdate1 implements the
// lnwire.SizeableMessage interface.
var _ SizeableMessage = (*ChannelUpdate1)(nil)

// Decode deserializes a serialized ChannelUpdate stored in the passed
// io.Reader observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (a *ChannelUpdate1) Decode(r io.Reader, pver uint32) error <span class="cov0" title="0">{
        err := ReadElements(r,
                &amp;a.Signature,
                a.ChainHash[:],
                &amp;a.ShortChannelID,
                &amp;a.Timestamp,
                &amp;a.MessageFlags,
                &amp;a.ChannelFlags,
                &amp;a.TimeLockDelta,
                &amp;a.HtlcMinimumMsat,
                &amp;a.BaseFee,
                &amp;a.FeeRate,
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Now check whether the max HTLC field is present and read it if so.
        <span class="cov0" title="0">if a.MessageFlags.HasMaxHtlc() </span><span class="cov0" title="0">{
                if err := ReadElements(r, &amp;a.HtlcMaximumMsat); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return a.ExtraOpaqueData.Decode(r)</span>
}

// Encode serializes the target ChannelUpdate into the passed io.Writer
// observing the protocol version specified.
//
// This is part of the lnwire.Message interface.
func (a *ChannelUpdate1) Encode(w *bytes.Buffer, pver uint32) error <span class="cov0" title="0">{
        if err := WriteSig(w, a.Signature); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteBytes(w, a.ChainHash[:]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteShortChannelID(w, a.ShortChannelID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteUint32(w, a.Timestamp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteChanUpdateMsgFlags(w, a.MessageFlags); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteChanUpdateChanFlags(w, a.ChannelFlags); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteUint16(w, a.TimeLockDelta); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteMilliSatoshi(w, a.HtlcMinimumMsat); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteUint32(w, a.BaseFee); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteUint32(w, a.FeeRate); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Now append optional fields if they are set. Currently, the only
        // optional field is max HTLC.
        <span class="cov0" title="0">if a.MessageFlags.HasMaxHtlc() </span><span class="cov0" title="0">{
                err := WriteMilliSatoshi(w, a.HtlcMaximumMsat)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Finally, append any extra opaque data.
        <span class="cov0" title="0">return WriteBytes(w, a.ExtraOpaqueData)</span>
}

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (a *ChannelUpdate1) MsgType() MessageType <span class="cov0" title="0">{
        return MsgChannelUpdate
}</span>

// DataToSign is used to retrieve part of the announcement message which should
// be signed.
func (a *ChannelUpdate1) DataToSign() ([]byte, error) <span class="cov0" title="0">{
        // We should not include the signatures itself.
        b := make([]byte, 0, MaxMsgBody)
        buf := bytes.NewBuffer(b)
        if err := WriteBytes(buf, a.ChainHash[:]); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := WriteShortChannelID(buf, a.ShortChannelID); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := WriteUint32(buf, a.Timestamp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := WriteChanUpdateMsgFlags(buf, a.MessageFlags); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := WriteChanUpdateChanFlags(buf, a.ChannelFlags); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := WriteUint16(buf, a.TimeLockDelta); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := WriteMilliSatoshi(buf, a.HtlcMinimumMsat); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := WriteUint32(buf, a.BaseFee); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := WriteUint32(buf, a.FeeRate); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Now append optional fields if they are set. Currently, the only
        // optional field is max HTLC.
        <span class="cov0" title="0">if a.MessageFlags.HasMaxHtlc() </span><span class="cov0" title="0">{
                err := WriteMilliSatoshi(buf, a.HtlcMaximumMsat)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // Finally, append any extra opaque data.
        <span class="cov0" title="0">if err := WriteBytes(buf, a.ExtraOpaqueData); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return buf.Bytes(), nil</span>
}

// SCID returns the ShortChannelID of the channel that the update applies to.
//
// NOTE: this is part of the ChannelUpdate interface.
func (a *ChannelUpdate1) SCID() ShortChannelID <span class="cov0" title="0">{
        return a.ShortChannelID
}</span>

// IsNode1 is true if the update was produced by node 1 of the channel peers.
// Node 1 is the node with the lexicographically smaller public key.
//
// NOTE: this is part of the ChannelUpdate interface.
func (a *ChannelUpdate1) IsNode1() bool <span class="cov0" title="0">{
        return a.ChannelFlags&amp;ChanUpdateDirection == 0
}</span>

// IsDisabled is true if the update is announcing that the channel should be
// considered disabled.
//
// NOTE: this is part of the ChannelUpdate interface.
func (a *ChannelUpdate1) IsDisabled() bool <span class="cov0" title="0">{
        return a.ChannelFlags&amp;ChanUpdateDisabled == ChanUpdateDisabled
}</span>

// GetChainHash returns the hash of the chain that the message is referring to.
//
// NOTE: this is part of the ChannelUpdate interface.
func (a *ChannelUpdate1) GetChainHash() chainhash.Hash <span class="cov0" title="0">{
        return a.ChainHash
}</span>

// ForwardingPolicy returns the set of forwarding constraints of the update.
//
// NOTE: this is part of the ChannelUpdate interface.
func (a *ChannelUpdate1) ForwardingPolicy() *ForwardingPolicy <span class="cov0" title="0">{
        return &amp;ForwardingPolicy{
                TimeLockDelta: a.TimeLockDelta,
                BaseFee:       MilliSatoshi(a.BaseFee),
                FeeRate:       MilliSatoshi(a.FeeRate),
                MinHTLC:       a.HtlcMinimumMsat,
                HasMaxHTLC:    a.MessageFlags.HasMaxHtlc(),
                MaxHTLC:       a.HtlcMaximumMsat,
        }
}</span>

// CmpAge can be used to determine if the update is older or newer than the
// passed update. It returns 1 if this update is newer, -1 if it is older, and
// 0 if they are the same age.
//
// NOTE: this is part of the ChannelUpdate interface.
func (a *ChannelUpdate1) CmpAge(update ChannelUpdate) (CompareResult, error) <span class="cov0" title="0">{
        other, ok := update.(*ChannelUpdate1)
        if !ok </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("expected *ChannelUpdate1, got: %T",
                        update)
        }</span>

        <span class="cov0" title="0">switch </span>{
        case a.Timestamp &gt; other.Timestamp:<span class="cov0" title="0">
                return GreaterThan, nil</span>
        case a.Timestamp &lt; other.Timestamp:<span class="cov0" title="0">
                return LessThan, nil</span>
        default:<span class="cov0" title="0">
                return EqualTo, nil</span>
        }
}

// SetDisabledFlag can be used to adjust the disabled flag of an update.
//
// NOTE: this is part of the ChannelUpdate interface.
func (a *ChannelUpdate1) SetDisabledFlag(disabled bool) <span class="cov0" title="0">{
        if disabled </span><span class="cov0" title="0">{
                a.ChannelFlags |= ChanUpdateDisabled
        }</span> else<span class="cov0" title="0"> {
                a.ChannelFlags &amp;= ^ChanUpdateDisabled
        }</span>
}

// SetSCID can be used to overwrite the SCID of the update.
//
// NOTE: this is part of the ChannelUpdate interface.
func (a *ChannelUpdate1) SetSCID(scid ShortChannelID) <span class="cov0" title="0">{
        a.ShortChannelID = scid
}</span>

// A compile time assertion to ensure ChannelUpdate1 implements the
// ChannelUpdate interface.
var _ ChannelUpdate = (*ChannelUpdate1)(nil)

// SerializedSize returns the serialized size of the message in bytes.
//
// This is part of the lnwire.SizeableMessage interface.
func (a *ChannelUpdate1) SerializedSize() (uint32, error) <span class="cov0" title="0">{
        return MessageSerializedSize(a)
}</span>
</pre>
		
		<pre class="file" id="file60" style="display: none">package lnwire

import (
        "bytes"
        "fmt"
        "io"

        "github.com/btcsuite/btcd/chaincfg"
        "github.com/btcsuite/btcd/chaincfg/chainhash"
        "github.com/lightningnetwork/lnd/tlv"
)

const (
        defaultCltvExpiryDelta           = uint16(80)
        defaultHtlcMinMsat               = MilliSatoshi(1)
        defaultFeeBaseMsat               = uint32(1000)
        defaultFeeProportionalMillionths = uint32(1)
)

// ChannelUpdate2 message is used after taproot channel has been initially
// announced. Each side independently announces its fees and minimum expiry for
// HTLCs and other parameters. This message is also used to redeclare initially
// set channel parameters.
type ChannelUpdate2 struct {
        // Signature is used to validate the announced data and prove the
        // ownership of node id.
        Signature Sig

        // ChainHash denotes the target chain that this channel was opened
        // within. This value should be the genesis hash of the target chain.
        // Along with the short channel ID, this uniquely identifies the
        // channel globally in a blockchain.
        ChainHash tlv.RecordT[tlv.TlvType0, chainhash.Hash]

        // ShortChannelID is the unique description of the funding transaction.
        ShortChannelID tlv.RecordT[tlv.TlvType2, ShortChannelID]

        // BlockHeight allows ordering in the case of multiple announcements. We
        // should ignore the message if block height is not greater than the
        // last-received. The block height must always be greater or equal to
        // the block height that the channel funding transaction was confirmed
        // in.
        BlockHeight tlv.RecordT[tlv.TlvType4, uint32]

        // DisabledFlags is an optional bitfield that describes various reasons
        // that the node is communicating that the channel should be considered
        // disabled.
        DisabledFlags tlv.RecordT[tlv.TlvType6, ChanUpdateDisableFlags]

        // SecondPeer is used to indicate which node the channel node has
        // created and signed this message. If this field is present, it was
        // node 2 otherwise it was node 1.
        SecondPeer tlv.OptionalRecordT[tlv.TlvType8, TrueBoolean]

        // CLTVExpiryDelta is the minimum number of blocks this node requires to
        // be added to the expiry of HTLCs. This is a security parameter
        // determined by the node operator. This value represents the required
        // gap between the time locks of the incoming and outgoing HTLC's set
        // to this node.
        CLTVExpiryDelta tlv.RecordT[tlv.TlvType10, uint16]

        // HTLCMinimumMsat is the minimum HTLC value which will be accepted.
        HTLCMinimumMsat tlv.RecordT[tlv.TlvType12, MilliSatoshi]

        // HtlcMaximumMsat is the maximum HTLC value which will be accepted.
        HTLCMaximumMsat tlv.RecordT[tlv.TlvType14, MilliSatoshi]

        // FeeBaseMsat is the base fee that must be used for incoming HTLC's to
        // this particular channel. This value will be tacked onto the required
        // for a payment independent of the size of the payment.
        FeeBaseMsat tlv.RecordT[tlv.TlvType16, uint32]

        // FeeProportionalMillionths is the fee rate that will be charged per
        // millionth of a satoshi.
        FeeProportionalMillionths tlv.RecordT[tlv.TlvType18, uint32]

        // ExtraOpaqueData is the set of data that was appended to this message
        // to fill out the full maximum transport message size. These fields can
        // be used to specify optional data such as custom TLV fields.
        ExtraOpaqueData ExtraOpaqueData
}

// Decode deserializes a serialized ChannelUpdate2 stored in the passed
// io.Reader observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (c *ChannelUpdate2) Decode(r io.Reader, _ uint32) error <span class="cov0" title="0">{
        err := ReadElement(r, &amp;c.Signature)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">c.Signature.ForceSchnorr()

        return c.DecodeTLVRecords(r)</span>
}

// DecodeTLVRecords decodes only the TLV section of the message.
func (c *ChannelUpdate2) DecodeTLVRecords(r io.Reader) error <span class="cov0" title="0">{
        // First extract into extra opaque data.
        var tlvRecords ExtraOpaqueData
        if err := ReadElements(r, &amp;tlvRecords); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var (
                chainHash  = tlv.ZeroRecordT[tlv.TlvType0, [32]byte]()
                secondPeer = tlv.ZeroRecordT[tlv.TlvType8, TrueBoolean]()
        )
        typeMap, err := tlvRecords.ExtractRecords(
                &amp;chainHash, &amp;c.ShortChannelID, &amp;c.BlockHeight, &amp;c.DisabledFlags,
                &amp;secondPeer, &amp;c.CLTVExpiryDelta, &amp;c.HTLCMinimumMsat,
                &amp;c.HTLCMaximumMsat, &amp;c.FeeBaseMsat,
                &amp;c.FeeProportionalMillionths,
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // By default, the chain-hash is the bitcoin mainnet genesis block hash.
        <span class="cov0" title="0">c.ChainHash.Val = *chaincfg.MainNetParams.GenesisHash
        if _, ok := typeMap[c.ChainHash.TlvType()]; ok </span><span class="cov0" title="0">{
                c.ChainHash.Val = chainHash.Val
        }</span>

        // The presence of the second_peer tlv type indicates "true".
        <span class="cov0" title="0">if _, ok := typeMap[c.SecondPeer.TlvType()]; ok </span><span class="cov0" title="0">{
                c.SecondPeer = tlv.SomeRecordT(secondPeer)
        }</span>

        // If the CLTV expiry delta was not encoded, then set it to the default
        // value.
        <span class="cov0" title="0">if _, ok := typeMap[c.CLTVExpiryDelta.TlvType()]; !ok </span><span class="cov0" title="0">{
                c.CLTVExpiryDelta.Val = defaultCltvExpiryDelta
        }</span>

        // If the HTLC Minimum msat was not encoded, then set it to the default
        // value.
        <span class="cov0" title="0">if _, ok := typeMap[c.HTLCMinimumMsat.TlvType()]; !ok </span><span class="cov0" title="0">{
                c.HTLCMinimumMsat.Val = defaultHtlcMinMsat
        }</span>

        // If the base fee was not encoded, then set it to the default value.
        <span class="cov0" title="0">if _, ok := typeMap[c.FeeBaseMsat.TlvType()]; !ok </span><span class="cov0" title="0">{
                c.FeeBaseMsat.Val = defaultFeeBaseMsat
        }</span>

        // If the proportional fee was not encoded, then set it to the default
        // value.
        <span class="cov0" title="0">if _, ok := typeMap[c.FeeProportionalMillionths.TlvType()]; !ok </span><span class="cov0" title="0">{
                c.FeeProportionalMillionths.Val = defaultFeeProportionalMillionths //nolint:ll
        }</span>

        <span class="cov0" title="0">if len(tlvRecords) != 0 </span><span class="cov0" title="0">{
                c.ExtraOpaqueData = tlvRecords
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Encode serializes the target ChannelUpdate2 into the passed io.Writer
// observing the protocol version specified.
//
// This is part of the lnwire.Message interface.
func (c *ChannelUpdate2) Encode(w *bytes.Buffer, _ uint32) error <span class="cov0" title="0">{
        _, err := w.Write(c.Signature.RawBytes())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = c.DataToSign()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return WriteBytes(w, c.ExtraOpaqueData)</span>
}

// DataToSign is used to retrieve part of the announcement message which should
// be signed. For the ChannelUpdate2 message, this includes the serialised TLV
// records.
func (c *ChannelUpdate2) DataToSign() ([]byte, error) <span class="cov0" title="0">{
        // The chain-hash record is only included if it is _not_ equal to the
        // bitcoin mainnet genisis block hash.
        var recordProducers []tlv.RecordProducer
        if !c.ChainHash.Val.IsEqual(chaincfg.MainNetParams.GenesisHash) </span><span class="cov0" title="0">{
                hash := tlv.ZeroRecordT[tlv.TlvType0, [32]byte]()
                hash.Val = c.ChainHash.Val

                recordProducers = append(recordProducers, &amp;hash)
        }</span>

        <span class="cov0" title="0">recordProducers = append(recordProducers,
                &amp;c.ShortChannelID, &amp;c.BlockHeight,
        )

        // Only include the disable flags if any bit is set.
        if !c.DisabledFlags.Val.IsEnabled() </span><span class="cov0" title="0">{
                recordProducers = append(recordProducers, &amp;c.DisabledFlags)
        }</span>

        // We only need to encode the second peer boolean if it is true
        <span class="cov0" title="0">c.SecondPeer.WhenSome(func(r tlv.RecordT[tlv.TlvType8, TrueBoolean]) </span><span class="cov0" title="0">{
                recordProducers = append(recordProducers, &amp;r)
        }</span>)

        // We only encode the cltv expiry delta if it is not equal to the
        // default.
        <span class="cov0" title="0">if c.CLTVExpiryDelta.Val != defaultCltvExpiryDelta </span><span class="cov0" title="0">{
                recordProducers = append(recordProducers, &amp;c.CLTVExpiryDelta)
        }</span>

        <span class="cov0" title="0">if c.HTLCMinimumMsat.Val != defaultHtlcMinMsat </span><span class="cov0" title="0">{
                recordProducers = append(recordProducers, &amp;c.HTLCMinimumMsat)
        }</span>

        <span class="cov0" title="0">recordProducers = append(recordProducers, &amp;c.HTLCMaximumMsat)

        if c.FeeBaseMsat.Val != defaultFeeBaseMsat </span><span class="cov0" title="0">{
                recordProducers = append(recordProducers, &amp;c.FeeBaseMsat)
        }</span>

        <span class="cov0" title="0">if c.FeeProportionalMillionths.Val != defaultFeeProportionalMillionths </span><span class="cov0" title="0">{
                recordProducers = append(
                        recordProducers, &amp;c.FeeProportionalMillionths,
                )
        }</span>

        <span class="cov0" title="0">err := EncodeMessageExtraData(&amp;c.ExtraOpaqueData, recordProducers...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return c.ExtraOpaqueData, nil</span>
}

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (c *ChannelUpdate2) MsgType() MessageType <span class="cov0" title="0">{
        return MsgChannelUpdate2
}</span>

// SerializedSize returns the serialized size of the message in bytes.
//
// This is part of the lnwire.SizeableMessage interface.
func (c *ChannelUpdate2) SerializedSize() (uint32, error) <span class="cov0" title="0">{
        return MessageSerializedSize(c)
}</span>

func (c *ChannelUpdate2) ExtraData() ExtraOpaqueData <span class="cov0" title="0">{
        return c.ExtraOpaqueData
}</span>

// A compile time check to ensure ChannelUpdate2 implements the
// lnwire.Message interface.
var _ Message = (*ChannelUpdate2)(nil)

// SCID returns the ShortChannelID of the channel that the update applies to.
//
// NOTE: this is part of the ChannelUpdate interface.
func (c *ChannelUpdate2) SCID() ShortChannelID <span class="cov0" title="0">{
        return c.ShortChannelID.Val
}</span>

// IsNode1 is true if the update was produced by node 1 of the channel peers.
// Node 1 is the node with the lexicographically smaller public key.
//
// NOTE: this is part of the ChannelUpdate interface.
func (c *ChannelUpdate2) IsNode1() bool <span class="cov0" title="0">{
        return c.SecondPeer.IsNone()
}</span>

// IsDisabled is true if the update is announcing that the channel should be
// considered disabled.
//
// NOTE: this is part of the ChannelUpdate interface.
func (c *ChannelUpdate2) IsDisabled() bool <span class="cov0" title="0">{
        return !c.DisabledFlags.Val.IsEnabled()
}</span>

// GetChainHash returns the hash of the chain that the message is referring to.
//
// NOTE: this is part of the ChannelUpdate interface.
func (c *ChannelUpdate2) GetChainHash() chainhash.Hash <span class="cov0" title="0">{
        return c.ChainHash.Val
}</span>

// ForwardingPolicy returns the set of forwarding constraints of the update.
//
// NOTE: this is part of the ChannelUpdate interface.
func (c *ChannelUpdate2) ForwardingPolicy() *ForwardingPolicy <span class="cov0" title="0">{
        return &amp;ForwardingPolicy{
                TimeLockDelta: c.CLTVExpiryDelta.Val,
                BaseFee:       MilliSatoshi(c.FeeBaseMsat.Val),
                FeeRate:       MilliSatoshi(c.FeeProportionalMillionths.Val),
                MinHTLC:       c.HTLCMinimumMsat.Val,
                HasMaxHTLC:    true,
                MaxHTLC:       c.HTLCMaximumMsat.Val,
        }
}</span>

// CmpAge can be used to determine if the update is older or newer than the
// passed update. It returns 1 if this update is newer, -1 if it is older, and
// 0 if they are the same age.
//
// NOTE: this is part of the ChannelUpdate interface.
func (c *ChannelUpdate2) CmpAge(update ChannelUpdate) (CompareResult, error) <span class="cov0" title="0">{
        other, ok := update.(*ChannelUpdate2)
        if !ok </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("expected *ChannelUpdate2, got: %T",
                        update)
        }</span>

        <span class="cov0" title="0">switch </span>{
        case c.BlockHeight.Val &gt; other.BlockHeight.Val:<span class="cov0" title="0">
                return GreaterThan, nil</span>
        case c.BlockHeight.Val &lt; other.BlockHeight.Val:<span class="cov0" title="0">
                return LessThan, nil</span>
        default:<span class="cov0" title="0">
                return EqualTo, nil</span>
        }
}

// SetDisabledFlag can be used to adjust the disabled flag of an update.
//
// NOTE: this is part of the ChannelUpdate interface.
func (c *ChannelUpdate2) SetDisabledFlag(disabled bool) <span class="cov0" title="0">{
        if disabled </span><span class="cov0" title="0">{
                c.DisabledFlags.Val |= ChanUpdateDisableIncoming
                c.DisabledFlags.Val |= ChanUpdateDisableOutgoing
        }</span> else<span class="cov0" title="0"> {
                c.DisabledFlags.Val &amp;^= ChanUpdateDisableIncoming
                c.DisabledFlags.Val &amp;^= ChanUpdateDisableOutgoing
        }</span>
}

// SetSCID can be used to overwrite the SCID of the update.
//
// NOTE: this is part of the ChannelUpdate interface.
func (c *ChannelUpdate2) SetSCID(scid ShortChannelID) <span class="cov0" title="0">{
        c.ShortChannelID.Val = scid
}</span>

// A compile time check to ensure ChannelUpdate2 implements the
// lnwire.ChannelUpdate interface.
var _ ChannelUpdate = (*ChannelUpdate2)(nil)

// ChanUpdateDisableFlags is a bit vector that can be used to indicate various
// reasons for the channel being marked as disabled.
type ChanUpdateDisableFlags uint8

const (
        // ChanUpdateDisableIncoming is a bit indicates that a channel is
        // disabled in the inbound direction meaning that the node broadcasting
        // the update is communicating that they cannot receive funds.
        ChanUpdateDisableIncoming ChanUpdateDisableFlags = 1 &lt;&lt; iota

        // ChanUpdateDisableOutgoing is a bit indicates that a channel is
        // disabled in the outbound direction meaning that the node broadcasting
        // the update is communicating that they cannot send or route funds.
        ChanUpdateDisableOutgoing = 2
)

// IncomingDisabled returns true if the ChanUpdateDisableIncoming bit is set.
func (c ChanUpdateDisableFlags) IncomingDisabled() bool <span class="cov0" title="0">{
        return c&amp;ChanUpdateDisableIncoming == ChanUpdateDisableIncoming
}</span>

// OutgoingDisabled returns true if the ChanUpdateDisableOutgoing bit is set.
func (c ChanUpdateDisableFlags) OutgoingDisabled() bool <span class="cov0" title="0">{
        return c&amp;ChanUpdateDisableOutgoing == ChanUpdateDisableOutgoing
}</span>

// IsEnabled returns true if none of the disable bits are set.
func (c ChanUpdateDisableFlags) IsEnabled() bool <span class="cov0" title="0">{
        return c == 0
}</span>

// String returns the bitfield flags as a string.
func (c ChanUpdateDisableFlags) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("%08b", c)
}</span>

// Record returns the tlv record for the disable flags.
func (c *ChanUpdateDisableFlags) Record() tlv.Record <span class="cov0" title="0">{
        return tlv.MakeStaticRecord(0, c, 1, encodeDisableFlags,
                decodeDisableFlags)
}</span>

func encodeDisableFlags(w io.Writer, val interface{}, buf *[8]byte) error <span class="cov0" title="0">{
        if v, ok := val.(*ChanUpdateDisableFlags); ok </span><span class="cov0" title="0">{
                flagsInt := uint8(*v)

                return tlv.EUint8(w, &amp;flagsInt, buf)
        }</span>

        <span class="cov0" title="0">return tlv.NewTypeForEncodingErr(val, "lnwire.ChanUpdateDisableFlags")</span>
}

func decodeDisableFlags(r io.Reader, val interface{}, buf *[8]byte,
        l uint64) error <span class="cov0" title="0">{

        if v, ok := val.(*ChanUpdateDisableFlags); ok </span><span class="cov0" title="0">{
                var flagsInt uint8
                err := tlv.DUint8(r, &amp;flagsInt, buf, l)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">*v = ChanUpdateDisableFlags(flagsInt)

                return nil</span>
        }

        <span class="cov0" title="0">return tlv.NewTypeForDecodingErr(val, "lnwire.ChanUpdateDisableFlags",
                l, l)</span>
}

// TrueBoolean is a record that indicates true or false using the presence of
// the record. If the record is absent, it indicates false. If it is present,
// it indicates true.
type TrueBoolean struct{}

// Record returns the tlv record for the boolean entry.
func (b *TrueBoolean) Record() tlv.Record <span class="cov0" title="0">{
        return tlv.MakeStaticRecord(
                0, b, 0, booleanEncoder, booleanDecoder,
        )
}</span>

func booleanEncoder(_ io.Writer, val interface{}, _ *[8]byte) error <span class="cov0" title="0">{
        if _, ok := val.(*TrueBoolean); ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return tlv.NewTypeForEncodingErr(val, "TrueBoolean")</span>
}

func booleanDecoder(_ io.Reader, val interface{}, _ *[8]byte,
        l uint64) error <span class="cov0" title="0">{

        if _, ok := val.(*TrueBoolean); ok &amp;&amp; (l == 0 || l == 1) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return tlv.NewTypeForEncodingErr(val, "TrueBoolean")</span>
}
</pre>
		
		<pre class="file" id="file61" style="display: none">package lnwire

import (
        "bytes"
        "io"

        "github.com/btcsuite/btcd/btcutil"
        "github.com/lightningnetwork/lnd/tlv"
)

// ClosingSigs houses the 3 possible signatures that can be sent when
// attempting to complete a cooperative channel closure. A signature will
// either include both outputs, or only one of the outputs from either side.
type ClosingSigs struct {
        // CloserNoClosee is a signature that excludes the output of the
        // clsoee.
        CloserNoClosee tlv.OptionalRecordT[tlv.TlvType1, Sig]

        // NoCloserClosee is a signature that excludes the output of the
        // closer.
        NoCloserClosee tlv.OptionalRecordT[tlv.TlvType2, Sig]

        // CloserAndClosee is a signature that includes both outputs.
        CloserAndClosee tlv.OptionalRecordT[tlv.TlvType3, Sig]
}

// ClosingComplete is sent by either side to kick off the process of obtaining
// a valid signature on a c o-operative channel closure of their choice.
type ClosingComplete struct {
        // ChannelID serves to identify which channel is to be closed.
        ChannelID ChannelID

        // CloserScript is the script to which the channel funds will be paid
        // for the closer (the person sending the ClosingComplete) message.
        CloserScript DeliveryAddress

        // CloseeScript is the script to which the channel funds will be paid
        // (the person receiving the ClosingComplete message).
        CloseeScript DeliveryAddress

        // FeeSatoshis is the total fee in satoshis that the party to the
        // channel would like to propose for the close transaction.
        FeeSatoshis btcutil.Amount

        // LockTime is the locktime number to be used in the input spending the
        // funding transaction.
        LockTime uint32

        // ClosingSigs houses the 3 possible signatures that can be sent.
        ClosingSigs

        // ExtraData is the set of data that was appended to this message to
        // fill out the full maximum transport message size. These fields can
        // be used to specify optional data such as custom TLV fields.
        ExtraData ExtraOpaqueData
}

// decodeClosingSigs decodes the closing sig TLV records in the passed
// ExtraOpaqueData.
func decodeClosingSigs(c *ClosingSigs, tlvRecords ExtraOpaqueData) error <span class="cov0" title="0">{
        sig1 := c.CloserNoClosee.Zero()
        sig2 := c.NoCloserClosee.Zero()
        sig3 := c.CloserAndClosee.Zero()

        typeMap, err := tlvRecords.ExtractRecords(&amp;sig1, &amp;sig2, &amp;sig3)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // TODO(roasbeef): helper func to made decode of the optional vals
        // easier?

        <span class="cov0" title="0">if val, ok := typeMap[c.CloserNoClosee.TlvType()]; ok &amp;&amp; val == nil </span><span class="cov0" title="0">{
                c.CloserNoClosee = tlv.SomeRecordT(sig1)
        }</span>
        <span class="cov0" title="0">if val, ok := typeMap[c.NoCloserClosee.TlvType()]; ok &amp;&amp; val == nil </span><span class="cov0" title="0">{
                c.NoCloserClosee = tlv.SomeRecordT(sig2)
        }</span>
        <span class="cov0" title="0">if val, ok := typeMap[c.CloserAndClosee.TlvType()]; ok &amp;&amp; val == nil </span><span class="cov0" title="0">{
                c.CloserAndClosee = tlv.SomeRecordT(sig3)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Decode deserializes a serialized ClosingComplete message stored in the
// passed io.Reader.
func (c *ClosingComplete) Decode(r io.Reader, _ uint32) error <span class="cov0" title="0">{
        // First, read out all the fields that are hard coded into the message.
        err := ReadElements(
                r, &amp;c.ChannelID, &amp;c.CloserScript, &amp;c.CloseeScript,
                &amp;c.FeeSatoshis, &amp;c.LockTime,
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // With the hard coded messages read, we'll now read out the TLV fields
        // of the message.
        <span class="cov0" title="0">var tlvRecords ExtraOpaqueData
        if err := ReadElements(r, &amp;tlvRecords); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := decodeClosingSigs(&amp;c.ClosingSigs, tlvRecords); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if len(tlvRecords) != 0 </span><span class="cov0" title="0">{
                c.ExtraData = tlvRecords
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// closingSigRecords returns the set of records that encode the closing sigs,
// if present.
func closingSigRecords(c *ClosingSigs) []tlv.RecordProducer <span class="cov0" title="0">{
        recordProducers := make([]tlv.RecordProducer, 0, 3)
        c.CloserNoClosee.WhenSome(func(sig tlv.RecordT[tlv.TlvType1, Sig]) </span><span class="cov0" title="0">{
                recordProducers = append(recordProducers, &amp;sig)
        }</span>)
        <span class="cov0" title="0">c.NoCloserClosee.WhenSome(func(sig tlv.RecordT[tlv.TlvType2, Sig]) </span><span class="cov0" title="0">{
                recordProducers = append(recordProducers, &amp;sig)
        }</span>)
        <span class="cov0" title="0">c.CloserAndClosee.WhenSome(func(sig tlv.RecordT[tlv.TlvType3, Sig]) </span><span class="cov0" title="0">{
                recordProducers = append(recordProducers, &amp;sig)
        }</span>)

        <span class="cov0" title="0">return recordProducers</span>
}

// Encode serializes the target ClosingComplete into the passed io.Writer.
func (c *ClosingComplete) Encode(w *bytes.Buffer, _ uint32) error <span class="cov0" title="0">{
        if err := WriteChannelID(w, c.ChannelID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteDeliveryAddress(w, c.CloserScript); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := WriteDeliveryAddress(w, c.CloseeScript); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteSatoshi(w, c.FeeSatoshis); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteUint32(w, c.LockTime); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">recordProducers := closingSigRecords(&amp;c.ClosingSigs)

        err := EncodeMessageExtraData(&amp;c.ExtraData, recordProducers...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return WriteBytes(w, c.ExtraData)</span>
}

// MsgType returns the uint32 code which uniquely identifies this message as a
// ClosingComplete message on the wire.
//
// This is part of the lnwire.Message interface.
func (c *ClosingComplete) MsgType() MessageType <span class="cov0" title="0">{
        return MsgClosingComplete
}</span>

// SerializedSize returns the serialized size of the message in bytes.
//
// This is part of the lnwire.SizeableMessage interface.
func (c *ClosingComplete) SerializedSize() (uint32, error) <span class="cov0" title="0">{
        return MessageSerializedSize(c)
}</span>

// A compile time check to ensure ClosingComplete implements the lnwire.Message
// interface.
var _ Message = (*ClosingComplete)(nil)

// A compile time check to ensure ClosingComplete implements the
// lnwire.SizeableMessage interface.
var _ SizeableMessage = (*ClosingComplete)(nil)
</pre>
		
		<pre class="file" id="file62" style="display: none">package lnwire

import (
        "bytes"
        "io"

        "github.com/btcsuite/btcd/btcutil"
)

// ClosingSig is sent in response to a ClosingComplete message. It carries the
// signatures of the closee to the closer.
type ClosingSig struct {
        // ChannelID serves to identify which channel is to be closed.
        ChannelID ChannelID

        // CloserScript is the script to which the channel funds will be paid
        // for the closer (the person sending the ClosingComplete) message.
        CloserScript DeliveryAddress

        // CloseeScript is the script to which the channel funds will be paid
        // (the person receiving the ClosingComplete message).
        CloseeScript DeliveryAddress

        // FeeSatoshis is the total fee in satoshis that the party to the
        // channel proposed for the close transaction.
        FeeSatoshis btcutil.Amount

        // LockTime is the locktime number to be used in the input spending the
        // funding transaction.
        LockTime uint32

        // ClosingSigs houses the 3 possible signatures that can be sent.
        ClosingSigs

        // ExtraData is the set of data that was appended to this message to
        // fill out the full maximum transport message size. These fields can
        // be used to specify optional data such as custom TLV fields.
        ExtraData ExtraOpaqueData
}

// Decode deserializes a serialized ClosingSig message stored in the passed
// io.Reader.
func (c *ClosingSig) Decode(r io.Reader, _ uint32) error <span class="cov0" title="0">{
        // First, read out all the fields that are hard coded into the message.
        err := ReadElements(
                r, &amp;c.ChannelID, &amp;c.CloserScript, &amp;c.CloseeScript,
                &amp;c.FeeSatoshis, &amp;c.LockTime,
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // With the hard coded messages read, we'll now read out the TLV fields
        // of the message.
        <span class="cov0" title="0">var tlvRecords ExtraOpaqueData
        if err := ReadElements(r, &amp;tlvRecords); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := decodeClosingSigs(&amp;c.ClosingSigs, tlvRecords); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if len(tlvRecords) != 0 </span><span class="cov0" title="0">{
                c.ExtraData = tlvRecords
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Encode serializes the target ClosingSig into the passed io.Writer.
func (c *ClosingSig) Encode(w *bytes.Buffer, _ uint32) error <span class="cov0" title="0">{
        if err := WriteChannelID(w, c.ChannelID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteDeliveryAddress(w, c.CloserScript); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := WriteDeliveryAddress(w, c.CloseeScript); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteSatoshi(w, c.FeeSatoshis); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteUint32(w, c.LockTime); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">recordProducers := closingSigRecords(&amp;c.ClosingSigs)

        err := EncodeMessageExtraData(&amp;c.ExtraData, recordProducers...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return WriteBytes(w, c.ExtraData)</span>
}

// MsgType returns the uint32 code which uniquely identifies this message as a
// ClosingSig message on the wire.
//
// This is part of the lnwire.Message interface.
func (c *ClosingSig) MsgType() MessageType <span class="cov0" title="0">{
        return MsgClosingSig
}</span>

// SerializedSize returns the serialized size of the message in bytes.
//
// This is part of the lnwire.SizeableMessage interface.
func (c *ClosingSig) SerializedSize() (uint32, error) <span class="cov0" title="0">{
        return MessageSerializedSize(c)
}</span>

// A compile time check to ensure ClosingSig implements the lnwire.Message
// interface.
var _ Message = (*ClosingSig)(nil)

// A compile time check to ensure ClosingSig implements the
// lnwire.SizeableMessage interface.
var _ SizeableMessage = (*ClosingSig)(nil)
</pre>
		
		<pre class="file" id="file63" style="display: none">package lnwire

import (
        "bytes"
        "io"

        "github.com/btcsuite/btcd/btcutil"
        "github.com/lightningnetwork/lnd/tlv"
)

// ClosingSigned is sent by both parties to a channel once the channel is clear
// of HTLCs, and is primarily concerned with negotiating fees for the close
// transaction. Each party provides a signature for a transaction with a fee
// that they believe is fair. The process terminates when both sides agree on
// the same fee, or when one side force closes the channel.
//
// NOTE: The responder is able to send a signature without any additional
// messages as all transactions are assembled observing BIP 69 which defines a
// canonical ordering for input/outputs. Therefore, both sides are able to
// arrive at an identical closure transaction as they know the order of the
// inputs/outputs.
type ClosingSigned struct {
        // ChannelID serves to identify which channel is to be closed.
        ChannelID ChannelID

        // FeeSatoshis is the total fee in satoshis that the party to the
        // channel would like to propose for the close transaction.
        FeeSatoshis btcutil.Amount

        // Signature is for the proposed channel close transaction.
        Signature Sig

        // PartialSig is used to transmit a musig2 extended partial signature
        // that signs the latest fee offer. The nonce isn't sent along side, as
        // that has already been sent in the initial shutdown message.
        //
        // NOTE: This field is only populated if a musig2 taproot channel is
        // being signed for. In this case, the above Sig type MUST be blank.
        PartialSig OptPartialSigTLV

        // ExtraData is the set of data that was appended to this message to
        // fill out the full maximum transport message size. These fields can
        // be used to specify optional data such as custom TLV fields.
        ExtraData ExtraOpaqueData
}

// NewClosingSigned creates a new empty ClosingSigned message.
func NewClosingSigned(cid ChannelID, fs btcutil.Amount,
        sig Sig) *ClosingSigned <span class="cov0" title="0">{

        return &amp;ClosingSigned{
                ChannelID:   cid,
                FeeSatoshis: fs,
                Signature:   sig,
        }
}</span>

// A compile time check to ensure ClosingSigned implements the lnwire.Message
// interface.
var _ Message = (*ClosingSigned)(nil)

// A compile time check to ensure ClosingSigned implements the
// lnwire.SizeableMessage interface.
var _ SizeableMessage = (*ClosingSigned)(nil)

// Decode deserializes a serialized ClosingSigned message stored in the passed
// io.Reader observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (c *ClosingSigned) Decode(r io.Reader, pver uint32) error <span class="cov0" title="0">{
        err := ReadElements(
                r, &amp;c.ChannelID, &amp;c.FeeSatoshis, &amp;c.Signature,
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var tlvRecords ExtraOpaqueData
        if err := ReadElements(r, &amp;tlvRecords); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">partialSig := c.PartialSig.Zero()
        typeMap, err := tlvRecords.ExtractRecords(&amp;partialSig)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Set the corresponding TLV types if they were included in the stream.
        <span class="cov0" title="0">if val, ok := typeMap[c.PartialSig.TlvType()]; ok &amp;&amp; val == nil </span><span class="cov0" title="0">{
                c.PartialSig = tlv.SomeRecordT(partialSig)
        }</span>

        <span class="cov0" title="0">if len(tlvRecords) != 0 </span><span class="cov0" title="0">{
                c.ExtraData = tlvRecords
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Encode serializes the target ClosingSigned into the passed io.Writer
// observing the protocol version specified.
//
// This is part of the lnwire.Message interface.
func (c *ClosingSigned) Encode(w *bytes.Buffer, pver uint32) error <span class="cov0" title="0">{
        recordProducers := make([]tlv.RecordProducer, 0, 1)
        c.PartialSig.WhenSome(func(sig PartialSigTLV) </span><span class="cov0" title="0">{
                recordProducers = append(recordProducers, &amp;sig)
        }</span>)
        <span class="cov0" title="0">err := EncodeMessageExtraData(&amp;c.ExtraData, recordProducers...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteChannelID(w, c.ChannelID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteSatoshi(w, c.FeeSatoshis); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteSig(w, c.Signature); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return WriteBytes(w, c.ExtraData)</span>
}

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (c *ClosingSigned) MsgType() MessageType <span class="cov0" title="0">{
        return MsgClosingSigned
}</span>

// SerializedSize returns the serialized size of the message in bytes.
//
// This is part of the lnwire.SizeableMessage interface.
func (c *ClosingSigned) SerializedSize() (uint32, error) <span class="cov0" title="0">{
        return MessageSerializedSize(c)
}</span>
</pre>
		
		<pre class="file" id="file64" style="display: none">package lnwire

import (
        "bytes"
        "io"

        "github.com/lightningnetwork/lnd/tlv"
)

// CommitSig is sent by either side to stage any pending HTLC's in the
// receiver's pending set into a new commitment state. Implicitly, the new
// commitment transaction constructed which has been signed by CommitSig
// includes all HTLC's in the remote node's pending set. A CommitSig message
// may be sent after a series of UpdateAddHTLC/UpdateFulfillHTLC messages in
// order to batch add several HTLC's with a single signature covering all
// implicitly accepted HTLC's.
type CommitSig struct {
        // ChanID uniquely identifies to which currently active channel this
        // CommitSig applies to.
        ChanID ChannelID

        // CommitSig is Alice's signature for Bob's new commitment transaction.
        // Alice is able to send this signature without requesting any
        // additional data due to the piggybacking of Bob's next revocation
        // hash in his prior RevokeAndAck message, as well as the canonical
        // ordering used for all inputs/outputs within commitment transactions.
        // If initiating a new commitment state, this signature should ONLY
        // cover all of the sending party's pending log updates, and the log
        // updates of the remote party that have been ACK'd.
        CommitSig Sig

        // HtlcSigs is a signature for each relevant HTLC output within the
        // created commitment. The order of the signatures is expected to be
        // identical to the placement of the HTLC's within the BIP 69 sorted
        // commitment transaction. For each outgoing HTLC (from the PoV of the
        // sender of this message), a signature for an HTLC timeout transaction
        // should be signed, for each incoming HTLC the HTLC timeout
        // transaction should be signed.
        HtlcSigs []Sig

        // PartialSig is used to transmit a musig2 extended partial signature
        // that also carries along the public nonce of the signer.
        //
        // NOTE: This field is only populated if a musig2 taproot channel is
        // being signed for. In this case, the above Sig type MUST be blank.
        PartialSig OptPartialSigWithNonceTLV

        // CustomRecords maps TLV types to byte slices, storing arbitrary data
        // intended for inclusion in the ExtraData field.
        CustomRecords CustomRecords

        // ExtraData is the set of data that was appended to this message to
        // fill out the full maximum transport message size. These fields can
        // be used to specify optional data such as custom TLV fields.
        ExtraData ExtraOpaqueData
}

// NewCommitSig creates a new empty CommitSig message.
func NewCommitSig() *CommitSig <span class="cov0" title="0">{
        return &amp;CommitSig{}
}</span>

// A compile time check to ensure CommitSig implements the lnwire.Message
// interface.
var _ Message = (*CommitSig)(nil)

// A compile time check to ensure CommitSig implements the
// lnwire.SizeableMessage interface.
var _ SizeableMessage = (*CommitSig)(nil)

// Decode deserializes a serialized CommitSig message stored in the
// passed io.Reader observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (c *CommitSig) Decode(r io.Reader, pver uint32) error <span class="cov0" title="0">{
        // msgExtraData is a temporary variable used to read the message extra
        // data field from the reader.
        var msgExtraData ExtraOpaqueData

        err := ReadElements(r,
                &amp;c.ChanID,
                &amp;c.CommitSig,
                &amp;c.HtlcSigs,
                &amp;msgExtraData,
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Extract TLV records from the extra data field.
        <span class="cov0" title="0">partialSig := c.PartialSig.Zero()

        customRecords, parsed, extraData, err := ParseAndExtractCustomRecords(
                msgExtraData, &amp;partialSig,
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Set the corresponding TLV types if they were included in the stream.
        <span class="cov0" title="0">if _, ok := parsed[partialSig.TlvType()]; ok </span><span class="cov0" title="0">{
                c.PartialSig = tlv.SomeRecordT(partialSig)
        }</span>

        <span class="cov0" title="0">c.CustomRecords = customRecords
        c.ExtraData = extraData

        return nil</span>
}

// Encode serializes the target CommitSig into the passed io.Writer
// observing the protocol version specified.
//
// This is part of the lnwire.Message interface.
func (c *CommitSig) Encode(w *bytes.Buffer, pver uint32) error <span class="cov0" title="0">{
        recordProducers := make([]tlv.RecordProducer, 0, 1)
        c.PartialSig.WhenSome(func(sig PartialSigWithNonceTLV) </span><span class="cov0" title="0">{
                recordProducers = append(recordProducers, &amp;sig)
        }</span>)

        <span class="cov0" title="0">extraData, err := MergeAndEncode(
                recordProducers, c.ExtraData, c.CustomRecords,
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteChannelID(w, c.ChanID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteSig(w, c.CommitSig); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteSigs(w, c.HtlcSigs); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return WriteBytes(w, extraData)</span>
}

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (c *CommitSig) MsgType() MessageType <span class="cov0" title="0">{
        return MsgCommitSig
}</span>

// TargetChanID returns the channel id of the link for which this message is
// intended.
//
// NOTE: Part of peer.LinkUpdater interface.
func (c *CommitSig) TargetChanID() ChannelID <span class="cov0" title="0">{
        return c.ChanID
}</span>

// SerializedSize returns the serialized size of the message in bytes.
//
// This is part of the lnwire.SizeableMessage interface.
func (c *CommitSig) SerializedSize() (uint32, error) <span class="cov0" title="0">{
        return MessageSerializedSize(c)
}</span>
</pre>
		
		<pre class="file" id="file65" style="display: none">package lnwire

import (
        "bytes"
        "fmt"
        "io"
        "sync"
)

// CustomTypeStart is the start of the custom type range for peer messages as
// defined in BOLT 01.
const CustomTypeStart MessageType = 32768

var (
        // customTypeOverride contains a set of message types &lt; CustomTypeStart
        // that lnd allows to be treated as custom messages. This allows us to
        // override messages reserved for the protocol level and treat them as
        // custom messages. This set of message types is stored as a global so
        // that we do not need to pass around state when accounting for this
        // set of messages in message creation.
        //
        // Note: This global is protected by the customTypeOverride mutex.
        customTypeOverride map[MessageType]struct{}

        // customTypeOverrideMtx manages concurrent access to
        // customTypeOverride.
        customTypeOverrideMtx sync.RWMutex
)

// SetCustomOverrides validates that the set of override types are outside of
// the custom message range (there's no reason to override messages that are
// already within the range), and updates the customTypeOverride global to hold
// this set of message types. Note that this function will completely overwrite
// the set of overrides, so should be called with the full set of types.
func SetCustomOverrides(overrideTypes []uint16) error <span class="cov0" title="0">{
        customTypeOverrideMtx.Lock()
        defer customTypeOverrideMtx.Unlock()

        customTypeOverride = make(map[MessageType]struct{}, len(overrideTypes))

        for _, t := range overrideTypes </span><span class="cov0" title="0">{
                msgType := MessageType(t)

                if msgType &gt;= CustomTypeStart </span><span class="cov0" title="0">{
                        return fmt.Errorf("can't override type: %v, already "+
                                "in custom range", t)
                }</span>

                <span class="cov0" title="0">customTypeOverride[msgType] = struct{}{}</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// IsCustomOverride returns a bool indicating whether the message type is one
// of the protocol messages that we override for custom use.
func IsCustomOverride(t MessageType) bool <span class="cov0" title="0">{
        customTypeOverrideMtx.RLock()
        defer customTypeOverrideMtx.RUnlock()

        _, ok := customTypeOverride[t]

        return ok
}</span>

// Custom represents an application-defined wire message.
type Custom struct {
        Type MessageType
        Data []byte
}

// A compile time check to ensure Custom implements the lnwire.Message
// interface.
var _ Message = (*Custom)(nil)

// A compile time check to ensure Custom implements the lnwire.SizeableMessage
// interface.
var _ SizeableMessage = (*Custom)(nil)

// NewCustom instantiates a new custom message.
func NewCustom(msgType MessageType, data []byte) (*Custom, error) <span class="cov0" title="0">{
        if msgType &lt; CustomTypeStart &amp;&amp; !IsCustomOverride(msgType) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("msg type: %d not in custom range: %v "+
                        "and not overridden", msgType, CustomTypeStart)
        }</span>

        <span class="cov0" title="0">return &amp;Custom{
                Type: msgType,
                Data: data,
        }, nil</span>
}

// Encode serializes the target Custom message into the passed io.Writer
// implementation.
//
// This is part of the lnwire.Message interface.
func (c *Custom) Encode(b *bytes.Buffer, pver uint32) error <span class="cov0" title="0">{
        _, err := b.Write(c.Data)
        return err
}</span>

// Decode deserializes the serialized Custom message stored in the passed
// io.Reader into the target Custom message.
//
// This is part of the lnwire.Message interface.
func (c *Custom) Decode(r io.Reader, pver uint32) error <span class="cov0" title="0">{
        var b bytes.Buffer
        if _, err := io.Copy(&amp;b, r); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">c.Data = b.Bytes()

        return nil</span>
}

// MsgType returns the uint32 code which uniquely identifies this message as a
// Custom message on the wire.
//
// This is part of the lnwire.Message interface.
func (c *Custom) MsgType() MessageType <span class="cov0" title="0">{
        return c.Type
}</span>

// SerializedSize returns the serialized size of the message in bytes.
//
// This is part of the lnwire.SizeableMessage interface.
func (c *Custom) SerializedSize() (uint32, error) <span class="cov0" title="0">{
        return MessageSerializedSize(c)
}</span>
</pre>
		
		<pre class="file" id="file66" style="display: none">package lnwire

import (
        "bytes"
        "fmt"
        "io"
        "maps"
        "sort"

        "github.com/lightningnetwork/lnd/fn/v2"
        "github.com/lightningnetwork/lnd/tlv"
)

const (
        // MinCustomRecordsTlvType is the minimum custom records TLV type as
        // defined in BOLT 01.
        MinCustomRecordsTlvType = 65536
)

// CustomRecords stores a set of custom key/value pairs. Map keys are TLV types
// which must be greater than or equal to MinCustomRecordsTlvType.
type CustomRecords map[uint64][]byte

// NewCustomRecords creates a new CustomRecords instance from a
// tlv.TypeMap.
func NewCustomRecords(tlvMap tlv.TypeMap) (CustomRecords, error) <span class="cov0" title="0">{
        // Make comparisons in unit tests easy by returning nil if the map is
        // empty.
        if len(tlvMap) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">customRecords := make(CustomRecords, len(tlvMap))
        for k, v := range tlvMap </span><span class="cov0" title="0">{
                customRecords[uint64(k)] = v
        }</span>

        // Validate the custom records.
        <span class="cov0" title="0">err := customRecords.Validate()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("custom records from tlv map "+
                        "validation error: %w", err)
        }</span>

        <span class="cov0" title="0">return customRecords, nil</span>
}

// ParseCustomRecords creates a new CustomRecords instance from a tlv.Blob.
func ParseCustomRecords(b tlv.Blob) (CustomRecords, error) <span class="cov0" title="0">{
        return ParseCustomRecordsFrom(bytes.NewReader(b))
}</span>

// ParseCustomRecordsFrom creates a new CustomRecords instance from a reader.
func ParseCustomRecordsFrom(r io.Reader) (CustomRecords, error) <span class="cov0" title="0">{
        typeMap, err := DecodeRecords(r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error decoding HTLC record: %w", err)
        }</span>

        <span class="cov0" title="0">return NewCustomRecords(typeMap)</span>
}

// Validate checks that all custom records are in the custom type range.
func (c CustomRecords) Validate() error <span class="cov0" title="0">{
        if c == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">for key := range c </span><span class="cov0" title="0">{
                if key &lt; MinCustomRecordsTlvType </span><span class="cov0" title="0">{
                        return fmt.Errorf("custom records entry with TLV "+
                                "type below min: %d", MinCustomRecordsTlvType)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Copy returns a copy of the custom records.
func (c CustomRecords) Copy() CustomRecords <span class="cov0" title="0">{
        if c == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">customRecords := make(CustomRecords, len(c))
        for k, v := range c </span><span class="cov0" title="0">{
                customRecords[k] = v
        }</span>

        <span class="cov0" title="0">return customRecords</span>
}

// MergedCopy creates a copy of the records and merges them with the given
// records. If the same key is present in both sets, the value from the other
// records will be used.
func (c CustomRecords) MergedCopy(other CustomRecords) CustomRecords <span class="cov0" title="0">{
        copiedRecords := make(CustomRecords, len(c))
        maps.Copy(copiedRecords, c)
        maps.Copy(copiedRecords, other)

        return copiedRecords
}</span>

// ExtendRecordProducers extends the given records slice with the custom
// records. The resultant records slice will be sorted if the given records
// slice contains TLV types greater than or equal to MinCustomRecordsTlvType.
func (c CustomRecords) ExtendRecordProducers(
        producers []tlv.RecordProducer) ([]tlv.RecordProducer, error) <span class="cov0" title="0">{

        // If the custom records are nil or empty, there is nothing to do.
        if len(c) == 0 </span><span class="cov0" title="0">{
                return producers, nil
        }</span>

        // Validate the custom records.
        <span class="cov0" title="0">err := c.Validate()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Ensure that the existing records slice TLV types are not also present
        // in the custom records. If they are, the resultant extended records
        // slice would erroneously contain duplicate TLV types.
        <span class="cov0" title="0">for _, rp := range producers </span><span class="cov0" title="0">{
                record := rp.Record()
                recordTlvType := uint64(record.Type())

                _, foundDuplicateTlvType := c[recordTlvType]
                if foundDuplicateTlvType </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("custom records contains a TLV "+
                                "type that is already present in the "+
                                "existing records: %d", recordTlvType)
                }</span>
        }

        // Convert the custom records map to a TLV record producer slice and
        // append them to the exiting records slice.
        <span class="cov0" title="0">customRecordProducers := RecordsAsProducers(tlv.MapToRecords(c))
        producers = append(producers, customRecordProducers...)

        // If the records slice which was given as an argument included TLV
        // values greater than or equal to the minimum custom records TLV type
        // we will sort the extended records slice to ensure that it is ordered
        // correctly.
        SortProducers(producers)

        return producers, nil</span>
}

// RecordProducers returns a slice of record producers for the custom records.
func (c CustomRecords) RecordProducers() []tlv.RecordProducer <span class="cov0" title="0">{
        // If the custom records are nil or empty, return an empty slice.
        if len(c) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Convert the custom records map to a TLV record producer slice.
        <span class="cov0" title="0">records := tlv.MapToRecords(c)

        return RecordsAsProducers(records)</span>
}

// Serialize serializes the custom records into a byte slice.
func (c CustomRecords) Serialize() ([]byte, error) <span class="cov0" title="0">{
        records := tlv.MapToRecords(c)
        return EncodeRecords(records)
}</span>

// SerializeTo serializes the custom records into the given writer.
func (c CustomRecords) SerializeTo(w io.Writer) error <span class="cov0" title="0">{
        records := tlv.MapToRecords(c)
        return EncodeRecordsTo(w, records)
}</span>

// ProduceRecordsSorted converts a slice of record producers into a slice of
// records and then sorts it by type.
func ProduceRecordsSorted(recordProducers ...tlv.RecordProducer) []tlv.Record <span class="cov0" title="0">{
        records := fn.Map(
                recordProducers,
                func(producer tlv.RecordProducer) tlv.Record </span><span class="cov0" title="0">{
                        return producer.Record()
                }</span>,
        )

        // Ensure that the set of records are sorted before we attempt to
        // decode from the stream, to ensure they're canonical.
        <span class="cov0" title="0">tlv.SortRecords(records)

        return records</span>
}

// SortProducers sorts the given record producers by their type.
func SortProducers(producers []tlv.RecordProducer) <span class="cov0" title="0">{
        sort.Slice(producers, func(i, j int) bool </span><span class="cov0" title="0">{
                recordI := producers[i].Record()
                recordJ := producers[j].Record()
                return recordI.Type() &lt; recordJ.Type()
        }</span>)
}

// TlvMapToRecords converts a TLV map into a slice of records.
func TlvMapToRecords(tlvMap tlv.TypeMap) []tlv.Record <span class="cov0" title="0">{
        tlvMapGeneric := make(map[uint64][]byte)
        for k, v := range tlvMap </span><span class="cov0" title="0">{
                tlvMapGeneric[uint64(k)] = v
        }</span>

        <span class="cov0" title="0">return tlv.MapToRecords(tlvMapGeneric)</span>
}

// RecordsAsProducers converts a slice of records into a slice of record
// producers.
func RecordsAsProducers(records []tlv.Record) []tlv.RecordProducer <span class="cov0" title="0">{
        return fn.Map(records, func(record tlv.Record) tlv.RecordProducer </span><span class="cov0" title="0">{
                return &amp;record
        }</span>)
}

// EncodeRecords encodes the given records into a byte slice.
func EncodeRecords(records []tlv.Record) ([]byte, error) <span class="cov0" title="0">{
        var buf bytes.Buffer
        if err := EncodeRecordsTo(&amp;buf, records); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return buf.Bytes(), nil</span>
}

// EncodeRecordsTo encodes the given records into the given writer.
func EncodeRecordsTo(w io.Writer, records []tlv.Record) error <span class="cov0" title="0">{
        tlvStream, err := tlv.NewStream(records...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return tlvStream.Encode(w)</span>
}

// DecodeRecords decodes the given byte slice into the given records and returns
// the rest as a TLV type map.
func DecodeRecords(r io.Reader,
        records ...tlv.Record) (tlv.TypeMap, error) <span class="cov0" title="0">{

        tlvStream, err := tlv.NewStream(records...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return tlvStream.DecodeWithParsedTypes(r)</span>
}

// DecodeRecordsP2P decodes the given byte slice into the given records and
// returns the rest as a TLV type map. This function is identical to
// DecodeRecords except that the record size is capped at 65535.
func DecodeRecordsP2P(r *bytes.Reader,
        records ...tlv.Record) (tlv.TypeMap, error) <span class="cov0" title="0">{

        tlvStream, err := tlv.NewStream(records...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return tlvStream.DecodeWithParsedTypesP2P(r)</span>
}

// AssertUniqueTypes asserts that the given records have unique types.
func AssertUniqueTypes(r []tlv.Record) error <span class="cov0" title="0">{
        seen := make(fn.Set[tlv.Type], len(r))
        for _, record := range r </span><span class="cov0" title="0">{
                t := record.Type()
                if seen.Contains(t) </span><span class="cov0" title="0">{
                        return fmt.Errorf("duplicate record type: %d", t)
                }</span>
                <span class="cov0" title="0">seen.Add(t)</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file67" style="display: none">package lnwire

import (
        "bytes"
        "io"

        "github.com/btcsuite/btcd/btcec/v2/schnorr/musig2"
        "github.com/lightningnetwork/lnd/fn/v2"
        "github.com/lightningnetwork/lnd/tlv"
)

const (
        // DALocalMusig2Pubnonce is the TLV type number that identifies the
        // musig2 public nonce that we need to verify the commitment transaction
        // signature.
        DALocalMusig2Pubnonce tlv.Type = 0
)

// DynAck is the message used to accept the parameters of a dynamic commitment
// negotiation. Additional optional parameters will need to be present depending
// on the details of the dynamic commitment upgrade.
type DynAck struct {
        // ChanID is the ChannelID of the channel that is currently undergoing
        // a dynamic commitment negotiation
        ChanID ChannelID

        // LocalNonce is an optional field that is transmitted when accepting
        // a dynamic commitment upgrade to Taproot Channels. This nonce will be
        // used to verify the first commitment transaction signature. This will
        // only be populated if the DynPropose we are responding to specifies
        // taproot channels in the ChannelType field.
        LocalNonce fn.Option[Musig2Nonce]

        // ExtraData is the set of data that was appended to this message to
        // fill out the full maximum transport message size. These fields can
        // be used to specify optional data such as custom TLV fields.
        ExtraData ExtraOpaqueData
}

// A compile time check to ensure DynAck implements the lnwire.Message
// interface.
var _ Message = (*DynAck)(nil)

// A compile time check to ensure DynAck implements the lnwire.SizeableMessage
// interface.
var _ SizeableMessage = (*DynAck)(nil)

// Encode serializes the target DynAck into the passed io.Writer. Serialization
// will observe the rules defined by the passed protocol version.
//
// This is a part of the lnwire.Message interface.
func (da *DynAck) Encode(w *bytes.Buffer, _ uint32) error <span class="cov0" title="0">{
        if err := WriteChannelID(w, da.ChanID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var tlvRecords []tlv.Record
        da.LocalNonce.WhenSome(func(nonce Musig2Nonce) </span><span class="cov0" title="0">{
                tlvRecords = append(
                        tlvRecords, tlv.MakeStaticRecord(
                                DALocalMusig2Pubnonce, &amp;nonce,
                                musig2.PubNonceSize, nonceTypeEncoder,
                                nonceTypeDecoder,
                        ),
                )
        }</span>)
        <span class="cov0" title="0">tlv.SortRecords(tlvRecords)

        tlvStream, err := tlv.NewStream(tlvRecords...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var extraBytesWriter bytes.Buffer
        if err := tlvStream.Encode(&amp;extraBytesWriter); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">da.ExtraData = ExtraOpaqueData(extraBytesWriter.Bytes())

        return WriteBytes(w, da.ExtraData)</span>
}

// Decode deserializes the serialized DynAck stored in the passed io.Reader into
// the target DynAck using the deserialization rules defined by the passed
// protocol version.
//
// This is a part of the lnwire.Message interface.
func (da *DynAck) Decode(r io.Reader, _ uint32) error <span class="cov0" title="0">{
        // Parse out main message.
        if err := ReadElements(r, &amp;da.ChanID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Parse out TLV records.
        <span class="cov0" title="0">var tlvRecords ExtraOpaqueData
        if err := ReadElement(r, &amp;tlvRecords); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Prepare receiving buffers to be filled by TLV extraction.
        <span class="cov0" title="0">var localNonceScratch Musig2Nonce
        localNonce := tlv.MakeStaticRecord(
                DALocalMusig2Pubnonce, &amp;localNonceScratch, musig2.PubNonceSize,
                nonceTypeEncoder, nonceTypeDecoder,
        )

        // Create set of Records to read TLV bytestream into.
        records := []tlv.Record{localNonce}
        tlv.SortRecords(records)

        // Read TLV stream into record set.
        extraBytesReader := bytes.NewReader(tlvRecords)
        tlvStream, err := tlv.NewStream(records...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">typeMap, err := tlvStream.DecodeWithParsedTypesP2P(extraBytesReader)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Check the results of the TLV Stream decoding and appropriately set
        // message fields.
        <span class="cov0" title="0">if val, ok := typeMap[DALocalMusig2Pubnonce]; ok &amp;&amp; val == nil </span><span class="cov0" title="0">{
                da.LocalNonce = fn.Some(localNonceScratch)
        }</span>

        <span class="cov0" title="0">if len(tlvRecords) != 0 </span><span class="cov0" title="0">{
                da.ExtraData = tlvRecords
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// MsgType returns the MessageType code which uniquely identifies this message
// as a DynAck on the wire.
//
// This is part of the lnwire.Message interface.
func (da *DynAck) MsgType() MessageType <span class="cov0" title="0">{
        return MsgDynAck
}</span>

// SerializedSize returns the serialized size of the message in bytes.
//
// This is part of the lnwire.SizeableMessage interface.
func (da *DynAck) SerializedSize() (uint32, error) <span class="cov0" title="0">{
        return MessageSerializedSize(da)
}</span>
</pre>
		
		<pre class="file" id="file68" style="display: none">package lnwire

import (
        "bytes"
        "io"

        "github.com/btcsuite/btcd/btcec/v2"
        "github.com/btcsuite/btcd/btcutil"
        "github.com/lightningnetwork/lnd/fn/v2"
        "github.com/lightningnetwork/lnd/lnwallet/chainfee"
        "github.com/lightningnetwork/lnd/tlv"
)

const (
        // DPDustLimitSatoshis is the TLV type number that identifies the record
        // for DynPropose.DustLimit.
        DPDustLimitSatoshis tlv.Type = 0

        // DPMaxHtlcValueInFlightMsat is the TLV type number that identifies the
        // record for DynPropose.MaxValueInFlight.
        DPMaxHtlcValueInFlightMsat tlv.Type = 1

        // DPChannelReserveSatoshis is the TLV type number that identifies the
        // for DynPropose.ChannelReserve.
        DPChannelReserveSatoshis tlv.Type = 2

        // DPToSelfDelay is the TLV type number that identifies the record for
        // DynPropose.CsvDelay.
        DPToSelfDelay tlv.Type = 3

        // DPMaxAcceptedHtlcs is the TLV type number that identifies the record
        // for DynPropose.MaxAcceptedHTLCs.
        DPMaxAcceptedHtlcs tlv.Type = 4

        // DPFundingPubkey is the TLV type number that identifies the record for
        // DynPropose.FundingKey.
        DPFundingPubkey tlv.Type = 5

        // DPChannelType is the TLV type number that identifies the record for
        // DynPropose.ChannelType.
        DPChannelType tlv.Type = 6

        // DPKickoffFeerate is the TLV type number that identifies the record
        // for DynPropose.KickoffFeerate.
        DPKickoffFeerate tlv.Type = 7
)

// DynPropose is a message that is sent during a dynamic commitments negotiation
// process. It is sent by both parties to propose new channel parameters.
type DynPropose struct {
        // ChanID identifies the channel whose parameters we are trying to
        // re-negotiate.
        ChanID ChannelID

        // Initiator is a byte that identifies whether this message was sent as
        // the initiator of a dynamic commitment negotiation or the responder
        // of a dynamic commitment negotiation. bool true indicates it is the
        // initiator
        Initiator bool

        // DustLimit, if not nil, proposes a change to the dust_limit_satoshis
        // for the sender's commitment transaction.
        DustLimit fn.Option[btcutil.Amount]

        // MaxValueInFlight, if not nil, proposes a change to the
        // max_htlc_value_in_flight_msat limit of the sender.
        MaxValueInFlight fn.Option[MilliSatoshi]

        // ChannelReserve, if not nil, proposes a change to the
        // channel_reserve_satoshis requirement of the recipient.
        ChannelReserve fn.Option[btcutil.Amount]

        // CsvDelay, if not nil, proposes a change to the to_self_delay
        // requirement of the recipient.
        CsvDelay fn.Option[uint16]

        // MaxAcceptedHTLCs, if not nil, proposes a change to the
        // max_accepted_htlcs limit of the sender.
        MaxAcceptedHTLCs fn.Option[uint16]

        // FundingKey, if not nil, proposes a change to the funding_pubkey
        // parameter of the sender.
        FundingKey fn.Option[btcec.PublicKey]

        // ChannelType, if not nil, proposes a change to the channel_type
        // parameter.
        ChannelType fn.Option[ChannelType]

        // KickoffFeerate proposes the fee rate in satoshis per kw that it
        // is offering for a ChannelType conversion that requires a kickoff
        // transaction.
        KickoffFeerate fn.Option[chainfee.SatPerKWeight]

        // ExtraData is the set of data that was appended to this message to
        // fill out the full maximum transport message size. These fields can
        // be used to specify optional data such as custom TLV fields.
        //
        // NOTE: Since the fields in this structure are part of the TLV stream,
        // ExtraData will contain all TLV records _except_ the ones that are
        // present in earlier parts of this structure.
        ExtraData ExtraOpaqueData
}

// A compile time check to ensure DynPropose implements the lnwire.Message
// interface.
var _ Message = (*DynPropose)(nil)

// A compile time check to ensure DynPropose implements the
// lnwire.SizeableMessage interface.
var _ SizeableMessage = (*DynPropose)(nil)

// Encode serializes the target DynPropose into the passed io.Writer.
// Serialization will observe the rules defined by the passed protocol version.
//
// This is a part of the lnwire.Message interface.
func (dp *DynPropose) Encode(w *bytes.Buffer, _ uint32) error <span class="cov0" title="0">{
        var tlvRecords []tlv.Record
        dp.DustLimit.WhenSome(func(dl btcutil.Amount) </span><span class="cov0" title="0">{
                protoSats := uint64(dl)
                tlvRecords = append(
                        tlvRecords, tlv.MakePrimitiveRecord(
                                DPDustLimitSatoshis, &amp;protoSats,
                        ),
                )
        }</span>)
        <span class="cov0" title="0">dp.MaxValueInFlight.WhenSome(func(max MilliSatoshi) </span><span class="cov0" title="0">{
                protoSats := uint64(max)
                tlvRecords = append(
                        tlvRecords, tlv.MakePrimitiveRecord(
                                DPMaxHtlcValueInFlightMsat, &amp;protoSats,
                        ),
                )
        }</span>)
        <span class="cov0" title="0">dp.ChannelReserve.WhenSome(func(min btcutil.Amount) </span><span class="cov0" title="0">{
                channelReserve := uint64(min)
                tlvRecords = append(
                        tlvRecords, tlv.MakePrimitiveRecord(
                                DPChannelReserveSatoshis, &amp;channelReserve,
                        ),
                )
        }</span>)
        <span class="cov0" title="0">dp.CsvDelay.WhenSome(func(wait uint16) </span><span class="cov0" title="0">{
                tlvRecords = append(
                        tlvRecords, tlv.MakePrimitiveRecord(
                                DPToSelfDelay, &amp;wait,
                        ),
                )
        }</span>)
        <span class="cov0" title="0">dp.MaxAcceptedHTLCs.WhenSome(func(max uint16) </span><span class="cov0" title="0">{
                tlvRecords = append(
                        tlvRecords, tlv.MakePrimitiveRecord(
                                DPMaxAcceptedHtlcs, &amp;max,
                        ),
                )
        }</span>)
        <span class="cov0" title="0">dp.FundingKey.WhenSome(func(key btcec.PublicKey) </span><span class="cov0" title="0">{
                keyScratch := &amp;key
                tlvRecords = append(
                        tlvRecords, tlv.MakePrimitiveRecord(
                                DPFundingPubkey, &amp;keyScratch,
                        ),
                )
        }</span>)
        <span class="cov0" title="0">dp.ChannelType.WhenSome(func(ty ChannelType) </span><span class="cov0" title="0">{
                tlvRecords = append(
                        tlvRecords, tlv.MakeDynamicRecord(
                                DPChannelType, &amp;ty,
                                ty.featureBitLen,
                                channelTypeEncoder, channelTypeDecoder,
                        ),
                )
        }</span>)
        <span class="cov0" title="0">dp.KickoffFeerate.WhenSome(func(kickoffFeerate chainfee.SatPerKWeight) </span><span class="cov0" title="0">{
                protoSats := uint32(kickoffFeerate)
                tlvRecords = append(
                        tlvRecords, tlv.MakePrimitiveRecord(
                                DPKickoffFeerate, &amp;protoSats,
                        ),
                )
        }</span>)
        <span class="cov0" title="0">tlv.SortRecords(tlvRecords)

        tlvStream, err := tlv.NewStream(tlvRecords...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var extraBytesWriter bytes.Buffer
        if err := tlvStream.Encode(&amp;extraBytesWriter); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">dp.ExtraData = ExtraOpaqueData(extraBytesWriter.Bytes())

        if err := WriteChannelID(w, dp.ChanID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteBool(w, dp.Initiator); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return WriteBytes(w, dp.ExtraData)</span>
}

// Decode deserializes the serialized DynPropose stored in the passed io.Reader
// into the target DynPropose using the deserialization rules defined by the
// passed protocol version.
//
// This is a part of the lnwire.Message interface.
func (dp *DynPropose) Decode(r io.Reader, _ uint32) error <span class="cov0" title="0">{
        // Parse out the only required field.
        if err := ReadElements(r, &amp;dp.ChanID, &amp;dp.Initiator); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Parse out TLV stream.
        <span class="cov0" title="0">var tlvRecords ExtraOpaqueData
        if err := ReadElements(r, &amp;tlvRecords); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Prepare receiving buffers to be filled by TLV extraction.
        <span class="cov0" title="0">var dustLimitScratch uint64
        dustLimit := tlv.MakePrimitiveRecord(
                DPDustLimitSatoshis, &amp;dustLimitScratch,
        )

        var maxValueScratch uint64
        maxValue := tlv.MakePrimitiveRecord(
                DPMaxHtlcValueInFlightMsat, &amp;maxValueScratch,
        )

        var reserveScratch uint64
        reserve := tlv.MakePrimitiveRecord(
                DPChannelReserveSatoshis, &amp;reserveScratch,
        )

        var csvDelayScratch uint16
        csvDelay := tlv.MakePrimitiveRecord(DPToSelfDelay, &amp;csvDelayScratch)

        var maxHtlcsScratch uint16
        maxHtlcs := tlv.MakePrimitiveRecord(
                DPMaxAcceptedHtlcs, &amp;maxHtlcsScratch,
        )

        var fundingKeyScratch *btcec.PublicKey
        fundingKey := tlv.MakePrimitiveRecord(
                DPFundingPubkey, &amp;fundingKeyScratch,
        )

        var chanTypeScratch ChannelType
        chanType := tlv.MakeDynamicRecord(
                DPChannelType, &amp;chanTypeScratch, chanTypeScratch.featureBitLen,
                channelTypeEncoder, channelTypeDecoder,
        )

        var kickoffFeerateScratch uint32
        kickoffFeerate := tlv.MakePrimitiveRecord(
                DPKickoffFeerate, &amp;kickoffFeerateScratch,
        )

        // Create set of Records to read TLV bytestream into.
        records := []tlv.Record{
                dustLimit, maxValue, reserve, csvDelay, maxHtlcs, fundingKey,
                chanType, kickoffFeerate,
        }
        tlv.SortRecords(records)

        // Read TLV stream into record set.
        extraBytesReader := bytes.NewReader(tlvRecords)
        tlvStream, err := tlv.NewStream(records...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">typeMap, err := tlvStream.DecodeWithParsedTypesP2P(extraBytesReader)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Check the results of the TLV Stream decoding and appropriately set
        // message fields.
        <span class="cov0" title="0">if val, ok := typeMap[DPDustLimitSatoshis]; ok &amp;&amp; val == nil </span><span class="cov0" title="0">{
                dp.DustLimit = fn.Some(btcutil.Amount(dustLimitScratch))
        }</span>
        <span class="cov0" title="0">if val, ok := typeMap[DPMaxHtlcValueInFlightMsat]; ok &amp;&amp; val == nil </span><span class="cov0" title="0">{
                dp.MaxValueInFlight = fn.Some(MilliSatoshi(maxValueScratch))
        }</span>
        <span class="cov0" title="0">if val, ok := typeMap[DPChannelReserveSatoshis]; ok &amp;&amp; val == nil </span><span class="cov0" title="0">{
                dp.ChannelReserve = fn.Some(btcutil.Amount(reserveScratch))
        }</span>
        <span class="cov0" title="0">if val, ok := typeMap[DPToSelfDelay]; ok &amp;&amp; val == nil </span><span class="cov0" title="0">{
                dp.CsvDelay = fn.Some(csvDelayScratch)
        }</span>
        <span class="cov0" title="0">if val, ok := typeMap[DPMaxAcceptedHtlcs]; ok &amp;&amp; val == nil </span><span class="cov0" title="0">{
                dp.MaxAcceptedHTLCs = fn.Some(maxHtlcsScratch)
        }</span>
        <span class="cov0" title="0">if val, ok := typeMap[DPFundingPubkey]; ok &amp;&amp; val == nil </span><span class="cov0" title="0">{
                dp.FundingKey = fn.Some(*fundingKeyScratch)
        }</span>
        <span class="cov0" title="0">if val, ok := typeMap[DPChannelType]; ok &amp;&amp; val == nil </span><span class="cov0" title="0">{
                dp.ChannelType = fn.Some(chanTypeScratch)
        }</span>
        <span class="cov0" title="0">if val, ok := typeMap[DPKickoffFeerate]; ok &amp;&amp; val == nil </span><span class="cov0" title="0">{
                dp.KickoffFeerate = fn.Some(
                        chainfee.SatPerKWeight(kickoffFeerateScratch),
                )
        }</span>

        <span class="cov0" title="0">if len(tlvRecords) != 0 </span><span class="cov0" title="0">{
                dp.ExtraData = tlvRecords
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// MsgType returns the MessageType code which uniquely identifies this message
// as a DynPropose on the wire.
//
// This is part of the lnwire.Message interface.
func (dp *DynPropose) MsgType() MessageType <span class="cov0" title="0">{
        return MsgDynPropose
}</span>

// SerializedSize returns the serialized size of the message in bytes.
//
// This is part of the lnwire.SizeableMessage interface.
func (dp *DynPropose) SerializedSize() (uint32, error) <span class="cov0" title="0">{
        return MessageSerializedSize(dp)
}</span>
</pre>
		
		<pre class="file" id="file69" style="display: none">package lnwire

import (
        "bytes"
        "io"
)

// DynReject is a message that is sent during a dynamic commitments negotiation
// process. It is sent by both parties to propose new channel parameters.
type DynReject struct {
        // ChanID identifies the channel whose parameters we are trying to
        // re-negotiate.
        ChanID ChannelID

        // UpdateRejections is a bit vector that specifies which of the
        // DynPropose parameters we wish to call out as being unacceptable.
        UpdateRejections RawFeatureVector

        // ExtraData is the set of data that was appended to this message to
        // fill out the full maximum transport message size. These fields can
        // be used to specify optional data such as custom TLV fields.
        //
        // NOTE: Since the fields in this structure are part of the TLV stream,
        // ExtraData will contain all TLV records _except_ the ones that are
        // present in earlier parts of this structure.
        ExtraData ExtraOpaqueData
}

// A compile time check to ensure DynReject implements the lnwire.Message
// interface.
var _ Message = (*DynReject)(nil)

// A compile time check to ensure DynReject implements the
// lnwire.SizeableMessage interface.
var _ SizeableMessage = (*DynReject)(nil)

// Encode serializes the target DynReject into the passed io.Writer.
// Serialization will observe the rules defined by the passed protocol version.
//
// This is a part of the lnwire.Message interface.
func (dr *DynReject) Encode(w *bytes.Buffer, _ uint32) error <span class="cov0" title="0">{
        if err := WriteChannelID(w, dr.ChanID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteRawFeatureVector(w, &amp;dr.UpdateRejections); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return WriteBytes(w, dr.ExtraData)</span>
}

// Decode deserializes the serialized DynReject stored in the passed io.Reader
// into the target DynReject using the deserialization rules defined by the
// passed protocol version.
//
// This is a part of the lnwire.Message interface.
func (dr *DynReject) Decode(r io.Reader, _ uint32) error <span class="cov0" title="0">{
        var extra ExtraOpaqueData

        if err := ReadElements(
                r, &amp;dr.ChanID, &amp;dr.UpdateRejections, &amp;extra,
        ); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if len(extra) != 0 </span><span class="cov0" title="0">{
                dr.ExtraData = extra
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// MsgType returns the MessageType code which uniquely identifies this message
// as a DynReject on the wire.
//
// This is part of the lnwire.Message interface.
func (dr *DynReject) MsgType() MessageType <span class="cov0" title="0">{
        return MsgDynReject
}</span>

// SerializedSize returns the serialized size of the message in bytes.
//
// This is part of the lnwire.SizeableMessage interface.
func (dr *DynReject) SerializedSize() (uint32, error) <span class="cov0" title="0">{
        return MessageSerializedSize(dr)
}</span>
</pre>
		
		<pre class="file" id="file70" style="display: none">package lnwire

import "github.com/lightningnetwork/lnd/tlv"

// QueryEncoding is an enum-like type that represents exactly how a set data is
// encoded on the wire.
type QueryEncoding uint8

const (
        // EncodingSortedPlain signals that the set of data is encoded using the
        // regular encoding, in a sorted order.
        EncodingSortedPlain QueryEncoding = 0

        // EncodingSortedZlib signals that the set of data is encoded by first
        // sorting the set of channel ID's, as then compressing them using zlib.
        //
        // NOTE: this should no longer be used or accepted.
        EncodingSortedZlib QueryEncoding = 1
)

// recordProducer is a simple helper struct that implements the
// tlv.RecordProducer interface.
type recordProducer struct {
        record tlv.Record
}

// Record returns the underlying record.
func (r *recordProducer) Record() tlv.Record <span class="cov0" title="0">{
        return r.record
}</span>

// Ensure that recordProducer implements the tlv.RecordProducer interface.
var _ tlv.RecordProducer = (*recordProducer)(nil)
</pre>
		
		<pre class="file" id="file71" style="display: none">package lnwire

import (
        "bytes"
        "fmt"
        "io"
)

// FundingError represents a set of errors that can be encountered and sent
// during the funding workflow.
type FundingError uint8

const (
        // ErrMaxPendingChannels is returned by remote peer when the number of
        // active pending channels exceeds their maximum policy limit.
        ErrMaxPendingChannels FundingError = 1

        // ErrChanTooLarge is returned by a remote peer that receives a
        // FundingOpen request for a channel that is above their current
        // soft-limit.
        ErrChanTooLarge FundingError = 2
)

// String returns a human readable version of the target FundingError.
func (e FundingError) String() string <span class="cov0" title="0">{
        switch e </span>{
        case ErrMaxPendingChannels:<span class="cov0" title="0">
                return "Number of pending channels exceed maximum"</span>
        case ErrChanTooLarge:<span class="cov0" title="0">
                return "channel too large"</span>
        default:<span class="cov0" title="0">
                return "unknown error"</span>
        }
}

// Error returns the human readable version of the target FundingError.
//
// NOTE: Satisfies the Error interface.
func (e FundingError) Error() string <span class="cov0" title="0">{
        return e.String()
}</span>

// ErrorData is a set of bytes associated with a particular sent error. A
// receiving node SHOULD only print out data verbatim if the string is composed
// solely of printable ASCII characters. For reference, the printable character
// set includes byte values 32 through 127 inclusive.
type ErrorData []byte

// Error represents a generic error bound to an exact channel. The message
// format is purposefully general in order to allow expression of a wide array
// of possible errors. Each Error message is directed at a particular open
// channel referenced by ChannelPoint.
type Error struct {
        // ChanID references the active channel in which the error occurred
        // within. If the ChanID is all zeros, then this error applies to the
        // entire established connection.
        ChanID ChannelID

        // Data is the attached error data that describes the exact failure
        // which caused the error message to be sent.
        Data ErrorData
}

// NewError creates a new Error message.
func NewError() *Error <span class="cov0" title="0">{
        return &amp;Error{}
}</span>

// A compile time check to ensure Error implements the lnwire.Message
// interface.
var _ Message = (*Error)(nil)

// A compile time check to ensure Error implements the lnwire.SizeableMessage
// interface.
var _ SizeableMessage = (*Error)(nil)

// Error returns the string representation to Error.
//
// NOTE: Satisfies the error interface.
func (c *Error) Error() string <span class="cov0" title="0">{
        errMsg := "non-ascii data"
        if isASCII(c.Data) </span><span class="cov0" title="0">{
                errMsg = string(c.Data)
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("chan_id=%v, err=%v", c.ChanID, errMsg)</span>
}

// Decode deserializes a serialized Error message stored in the passed
// io.Reader observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (c *Error) Decode(r io.Reader, pver uint32) error <span class="cov0" title="0">{
        return ReadElements(r,
                &amp;c.ChanID,
                &amp;c.Data,
        )
}</span>

// Encode serializes the target Error into the passed io.Writer observing the
// protocol version specified.
//
// This is part of the lnwire.Message interface.
func (c *Error) Encode(w *bytes.Buffer, pver uint32) error <span class="cov0" title="0">{
        if err := WriteBytes(w, c.ChanID[:]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return WriteErrorData(w, c.Data)</span>
}

// MsgType returns the integer uniquely identifying an Error message on the
// wire.
//
// This is part of the lnwire.Message interface.
func (c *Error) MsgType() MessageType <span class="cov0" title="0">{
        return MsgError
}</span>

// SerializedSize returns the serialized size of the message in bytes.
//
// This is part of the lnwire.SizeableMessage interface.
func (c *Error) SerializedSize() (uint32, error) <span class="cov0" title="0">{
        return MessageSerializedSize(c)
}</span>

// isASCII is a helper method that checks whether all bytes in `data` would be
// printable ASCII characters if interpreted as a string.
func isASCII(data []byte) bool <span class="cov0" title="0">{
        for _, c := range data </span><span class="cov0" title="0">{
                if c &lt; 32 || c &gt; 126 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}
</pre>
		
		<pre class="file" id="file72" style="display: none">package lnwire

import (
        "bytes"
        "fmt"
        "io"

        "github.com/lightningnetwork/lnd/fn/v2"
        "github.com/lightningnetwork/lnd/tlv"
)

// ExtraOpaqueData is the set of data that was appended to this message, some
// of which we may not actually know how to iterate or parse. By holding onto
// this data, we ensure that we're able to properly validate the set of
// signatures that cover these new fields, and ensure we're able to make
// upgrades to the network in a forwards compatible manner.
type ExtraOpaqueData []byte

// NewExtraOpaqueData creates a new ExtraOpaqueData instance from a tlv.TypeMap.
func NewExtraOpaqueData(tlvMap tlv.TypeMap) (ExtraOpaqueData, error) <span class="cov0" title="0">{
        // If the tlv map is empty, we'll want to mirror the behavior of
        // decoding an empty extra opaque data field (see Decode method).
        if len(tlvMap) == 0 </span><span class="cov0" title="0">{
                return make([]byte, 0), nil
        }</span>

        // Convert the TLV map into a slice of records.
        <span class="cov0" title="0">records := TlvMapToRecords(tlvMap)

        // Encode the records into the extra data byte slice.
        return EncodeRecords(records)</span>
}

// Encode attempts to encode the raw extra bytes into the passed io.Writer.
func (e *ExtraOpaqueData) Encode(w *bytes.Buffer) error <span class="cov0" title="0">{
        eBytes := []byte((*e)[:])
        if err := WriteBytes(w, eBytes); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Decode attempts to unpack the raw bytes encoded in the passed-in io.Reader as
// a set of extra opaque data.
func (e *ExtraOpaqueData) Decode(r io.Reader) error <span class="cov0" title="0">{
        // First, we'll attempt to read a set of bytes contained within the
        // passed io.Reader (if any exist).
        rawBytes, err := io.ReadAll(r)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // If we _do_ have some bytes, then we'll swap out our backing pointer.
        // This ensures that any struct that embeds this type will properly
        // store the bytes once this method exits.
        <span class="cov0" title="0">if len(rawBytes) &gt; 0 </span><span class="cov0" title="0">{
                *e = rawBytes
        }</span> else<span class="cov0" title="0"> {
                *e = make([]byte, 0)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// PackRecords attempts to encode the set of tlv records into the target
// ExtraOpaqueData instance. The records will be encoded as a raw TLV stream
// and stored within the backing slice pointer.
func (e *ExtraOpaqueData) PackRecords(
        recordProducers ...tlv.RecordProducer) error <span class="cov0" title="0">{

        // Assemble all the records passed in series, then encode them.
        records := ProduceRecordsSorted(recordProducers...)
        encoded, err := EncodeRecords(records)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">*e = encoded

        return nil</span>
}

// ExtractRecords attempts to decode any types in the internal raw bytes as if
// it were a tlv stream. The set of raw parsed types is returned, and any
// passed records (if found in the stream) will be parsed into the proper
// tlv.Record.
func (e *ExtraOpaqueData) ExtractRecords(
        recordProducers ...tlv.RecordProducer) (tlv.TypeMap, error) <span class="cov0" title="0">{

        // First, assemble all the records passed in series.
        records := ProduceRecordsSorted(recordProducers...)
        extraBytesReader := bytes.NewReader(*e)

        // Since ExtraOpaqueData is provided by a potentially malicious peer,
        // pass it into the P2P decoding variant.
        return DecodeRecordsP2P(extraBytesReader, records...)
}</span>

// RecordProducers parses ExtraOpaqueData into a slice of TLV record producers
// by interpreting it as a TLV map.
func (e *ExtraOpaqueData) RecordProducers() ([]tlv.RecordProducer, error) <span class="cov0" title="0">{
        var recordProducers []tlv.RecordProducer

        // If the instance is nil or empty, return an empty slice.
        if e == nil || len(*e) == 0 </span><span class="cov0" title="0">{
                return recordProducers, nil
        }</span>

        // Parse the extra opaque data as a TLV map.
        <span class="cov0" title="0">tlvMap, err := e.ExtractRecords()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Convert the TLV map into a slice of record producers.
        <span class="cov0" title="0">records := TlvMapToRecords(tlvMap)

        return RecordsAsProducers(records), nil</span>
}

// EncodeMessageExtraData encodes the given recordProducers into the given
// extraData.
func EncodeMessageExtraData(extraData *ExtraOpaqueData,
        recordProducers ...tlv.RecordProducer) error <span class="cov0" title="0">{

        // Treat extraData as a mutable reference.
        if extraData == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("extra data cannot be nil")
        }</span>

        // Pack in the series of TLV records into this message. The order we
        // pass them in doesn't matter, as the method will ensure that things
        // are all properly sorted.
        <span class="cov0" title="0">return extraData.PackRecords(recordProducers...)</span>
}

// ParseAndExtractCustomRecords parses the given extra data into the passed-in
// records, then returns any remaining records split into custom records and
// extra data.
func ParseAndExtractCustomRecords(allExtraData ExtraOpaqueData,
        knownRecords ...tlv.RecordProducer) (CustomRecords,
        fn.Set[tlv.Type], ExtraOpaqueData, error) <span class="cov0" title="0">{

        extraDataTlvMap, err := allExtraData.ExtractRecords(knownRecords...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, err
        }</span>

        // Remove the known and now extracted records from the leftover extra
        // data map.
        <span class="cov0" title="0">parsedKnownRecords := make(fn.Set[tlv.Type], len(knownRecords))
        for _, producer := range knownRecords </span><span class="cov0" title="0">{
                r := producer.Record()

                // Only remove the records if it was parsed (remainder is nil).
                // We'll just store the type so we can tell the caller which
                // records were actually parsed fully.
                val, ok := extraDataTlvMap[r.Type()]
                if ok &amp;&amp; val == nil </span><span class="cov0" title="0">{
                        parsedKnownRecords.Add(r.Type())
                        delete(extraDataTlvMap, r.Type())
                }</span>
        }

        // Any records from the extra data TLV map which are in the custom
        // records TLV type range will be included in the custom records field
        // and removed from the extra data field.
        <span class="cov0" title="0">customRecordsTlvMap := make(tlv.TypeMap, len(extraDataTlvMap))
        for k, v := range extraDataTlvMap </span><span class="cov0" title="0">{
                // Skip records that are not in the custom records TLV type
                // range.
                if k &lt; MinCustomRecordsTlvType </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Include the record in the custom records map.
                <span class="cov0" title="0">customRecordsTlvMap[k] = v

                // Now that the record is included in the custom records map,
                // we can remove it from the extra data TLV map.
                delete(extraDataTlvMap, k)</span>
        }

        // Set the custom records field to the custom records specific TLV
        // record map.
        <span class="cov0" title="0">customRecords, err := NewCustomRecords(customRecordsTlvMap)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, err
        }</span>

        // Encode the remaining records back into the extra data field. These
        // records are not in the custom records TLV type range and do not
        // have associated fields in the struct that produced the records.
        <span class="cov0" title="0">extraData, err := NewExtraOpaqueData(extraDataTlvMap)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, err
        }</span>

        // Help with unit testing where we might have the empty value (nil) for
        // the extra data instead of the default that's returned by the
        // constructor (empty slice).
        <span class="cov0" title="0">if len(extraData) == 0 </span><span class="cov0" title="0">{
                extraData = nil
        }</span>

        <span class="cov0" title="0">return customRecords, parsedKnownRecords, extraData, nil</span>
}

// MergeAndEncode merges the known records with the extra data and custom
// records, then encodes the merged records into raw bytes.
func MergeAndEncode(knownRecords []tlv.RecordProducer,
        extraData ExtraOpaqueData, customRecords CustomRecords) ([]byte,
        error) <span class="cov0" title="0">{

        // Construct a slice of all the records that we should include in the
        // message extra data field. We will start by including any records from
        // the extra data field.
        mergedRecords, err := extraData.RecordProducers()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Merge the known and extra data records.
        <span class="cov0" title="0">mergedRecords = append(mergedRecords, knownRecords...)

        // Include custom records in the extra data wire field if they are
        // present. Ensure that the custom records are validated before encoding
        // them.
        if err := customRecords.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("custom records validation error: %w",
                        err)
        }</span>

        // Extend the message extra data records slice with TLV records from the
        // custom records field.
        <span class="cov0" title="0">mergedRecords = append(
                mergedRecords, customRecords.RecordProducers()...,
        )

        // Now we can sort the records and make sure there are no records with
        // the same type that would collide when encoding.
        sortedRecords := ProduceRecordsSorted(mergedRecords...)
        if err := AssertUniqueTypes(sortedRecords); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return EncodeRecords(sortedRecords)</span>
}
</pre>
		
		<pre class="file" id="file73" style="display: none">package lnwire

import (
        "encoding/binary"
        "errors"
        "fmt"
        "io"

        "github.com/lightningnetwork/lnd/tlv"
)

var (
        // ErrFeaturePairExists signals an error in feature vector construction
        // where the opposing bit in a feature pair has already been set.
        ErrFeaturePairExists = errors.New("feature pair exists")

        // ErrFeatureStandard is returned when attempts to modify LND's known
        // set of features are made.
        ErrFeatureStandard = errors.New("feature is used in standard " +
                "protocol set")

        // ErrFeatureBitMaximum is returned when a feature bit exceeds the
        // maximum allowable value.
        ErrFeatureBitMaximum = errors.New("feature bit exceeds allowed maximum")
)

// FeatureBit represents a feature that can be enabled in either a local or
// global feature vector at a specific bit position. Feature bits follow the
// "it's OK to be odd" rule, where features at even bit positions must be known
// to a node receiving them from a peer while odd bits do not. In accordance,
// feature bits are usually assigned in pairs, first being assigned an odd bit
// position which may later be changed to the preceding even position once
// knowledge of the feature becomes required on the network.
type FeatureBit uint16

const (
        // DataLossProtectRequired is a feature bit that indicates that a peer
        // *requires* the other party know about the data-loss-protect optional
        // feature. If the remote peer does not know of such a feature, then
        // the sending peer SHOULD disconnect them. The data-loss-protect
        // feature allows a peer that's lost partial data to recover their
        // settled funds of the latest commitment state.
        DataLossProtectRequired FeatureBit = 0

        // DataLossProtectOptional is an optional feature bit that indicates
        // that the sending peer knows of this new feature and can activate it
        // it. The data-loss-protect feature allows a peer that's lost partial
        // data to recover their settled funds of the latest commitment state.
        DataLossProtectOptional FeatureBit = 1

        // InitialRoutingSync is a local feature bit meaning that the receiving
        // node should send a complete dump of routing information when a new
        // connection is established.
        InitialRoutingSync FeatureBit = 3

        // UpfrontShutdownScriptRequired is a feature bit which indicates that a
        // peer *requires* that the remote peer accept an upfront shutdown script to
        // which payout is enforced on cooperative closes.
        UpfrontShutdownScriptRequired FeatureBit = 4

        // UpfrontShutdownScriptOptional is an optional feature bit which indicates
        // that the peer will accept an upfront shutdown script to which payout is
        // enforced on cooperative closes.
        UpfrontShutdownScriptOptional FeatureBit = 5

        // GossipQueriesRequired is a feature bit that indicates that the
        // receiving peer MUST know of the set of features that allows nodes to
        // more efficiently query the network view of peers on the network for
        // reconciliation purposes.
        GossipQueriesRequired FeatureBit = 6

        // GossipQueriesOptional is an optional feature bit that signals that
        // the setting peer knows of the set of features that allows more
        // efficient network view reconciliation.
        GossipQueriesOptional FeatureBit = 7

        // TLVOnionPayloadRequired is a feature bit that indicates a node is
        // able to decode the new TLV information included in the onion packet.
        TLVOnionPayloadRequired FeatureBit = 8

        // TLVOnionPayloadOptional is an optional feature bit that indicates a
        // node is able to decode the new TLV information included in the onion
        // packet.
        TLVOnionPayloadOptional FeatureBit = 9

        // StaticRemoteKeyRequired is a required feature bit that signals that
        // within one's commitment transaction, the key used for the remote
        // party's non-delay output should not be tweaked.
        StaticRemoteKeyRequired FeatureBit = 12

        // StaticRemoteKeyOptional is an optional feature bit that signals that
        // within one's commitment transaction, the key used for the remote
        // party's non-delay output should not be tweaked.
        StaticRemoteKeyOptional FeatureBit = 13

        // PaymentAddrRequired is a required feature bit that signals that a
        // node requires payment addresses, which are used to mitigate probing
        // attacks on the receiver of a payment.
        PaymentAddrRequired FeatureBit = 14

        // PaymentAddrOptional is an optional feature bit that signals that a
        // node supports payment addresses, which are used to mitigate probing
        // attacks on the receiver of a payment.
        PaymentAddrOptional FeatureBit = 15

        // MPPRequired is a required feature bit that signals that the receiver
        // of a payment requires settlement of an invoice with more than one
        // HTLC.
        MPPRequired FeatureBit = 16

        // MPPOptional is an optional feature bit that signals that the receiver
        // of a payment supports settlement of an invoice with more than one
        // HTLC.
        MPPOptional FeatureBit = 17

        // WumboChannelsRequired is a required feature bit that signals that a
        // node is willing to accept channels larger than 2^24 satoshis.
        WumboChannelsRequired FeatureBit = 18

        // WumboChannelsOptional is an optional feature bit that signals that a
        // node is willing to accept channels larger than 2^24 satoshis.
        WumboChannelsOptional FeatureBit = 19

        // AnchorsRequired is a required feature bit that signals that the node
        // requires channels to be made using commitments having anchor
        // outputs.
        AnchorsRequired FeatureBit = 20

        // AnchorsOptional is an optional feature bit that signals that the
        // node supports channels to be made using commitments having anchor
        // outputs.
        AnchorsOptional FeatureBit = 21

        // AnchorsZeroFeeHtlcTxRequired is a required feature bit that signals
        // that the node requires channels having zero-fee second-level HTLC
        // transactions, which also imply anchor commitments.
        AnchorsZeroFeeHtlcTxRequired FeatureBit = 22

        // AnchorsZeroFeeHtlcTxOptional is an optional feature bit that signals
        // that the node supports channels having zero-fee second-level HTLC
        // transactions, which also imply anchor commitments.
        AnchorsZeroFeeHtlcTxOptional FeatureBit = 23

        // RouteBlindingRequired is a required feature bit that signals that
        // the node supports blinded payments.
        RouteBlindingRequired FeatureBit = 24

        // RouteBlindingOptional is an optional feature bit that signals that
        // the node supports blinded payments.
        RouteBlindingOptional FeatureBit = 25

        // ShutdownAnySegwitRequired is an required feature bit that signals
        // that the sender is able to properly handle/parse segwit witness
        // programs up to version 16. This enables utilization of Taproot
        // addresses for cooperative closure addresses.
        ShutdownAnySegwitRequired FeatureBit = 26

        // ShutdownAnySegwitOptional is an optional feature bit that signals
        // that the sender is able to properly handle/parse segwit witness
        // programs up to version 16. This enables utilization of Taproot
        // addresses for cooperative closure addresses.
        ShutdownAnySegwitOptional FeatureBit = 27

        // AMPRequired is a required feature bit that signals that the receiver
        // of a payment supports accepts spontaneous payments, i.e.
        // sender-generated preimages according to BOLT XX.
        AMPRequired FeatureBit = 30

        // AMPOptional is an optional feature bit that signals that the receiver
        // of a payment supports accepts spontaneous payments, i.e.
        // sender-generated preimages according to BOLT XX.
        AMPOptional FeatureBit = 31

        // QuiescenceRequired is a required feature bit that denotes that a
        // connection established with this node must support the quiescence
        // protocol if it wants to have a channel relationship.
        QuiescenceRequired FeatureBit = 34

        // QuiescenceOptional is an optional feature bit that denotes that a
        // connection established with this node is permitted to use the
        // quiescence protocol.
        QuiescenceOptional FeatureBit = 35

        // ExplicitChannelTypeRequired is a required bit that denotes that a
        // connection established with this node is to use explicit channel
        // commitment types for negotiation instead of the existing implicit
        // negotiation methods. With this bit, there is no longer a "default"
        // implicit channel commitment type, allowing a connection to
        // open/maintain types of several channels over its lifetime.
        ExplicitChannelTypeRequired = 44

        // ExplicitChannelTypeOptional is an optional bit that denotes that a
        // connection established with this node is to use explicit channel
        // commitment types for negotiation instead of the existing implicit
        // negotiation methods. With this bit, there is no longer a "default"
        // implicit channel commitment type, allowing a connection to
        // TODO: Decide on actual feature bit value.
        ExplicitChannelTypeOptional = 45

        // ScidAliasRequired is a required feature bit that signals that the
        // node requires understanding of ShortChannelID aliases in the TLV
        // segment of the channel_ready message.
        ScidAliasRequired FeatureBit = 46

        // ScidAliasOptional is an optional feature bit that signals that the
        // node understands ShortChannelID aliases in the TLV segment of the
        // channel_ready message.
        ScidAliasOptional FeatureBit = 47

        // PaymentMetadataRequired is a required bit that denotes that if an
        // invoice contains metadata, it must be passed along with the payment
        // htlc(s).
        PaymentMetadataRequired = 48

        // PaymentMetadataOptional is an optional bit that denotes that if an
        // invoice contains metadata, it may be passed along with the payment
        // htlc(s).
        PaymentMetadataOptional = 49

        // ZeroConfRequired is a required feature bit that signals that the
        // node requires understanding of the zero-conf channel_type.
        ZeroConfRequired FeatureBit = 50

        // ZeroConfOptional is an optional feature bit that signals that the
        // node understands the zero-conf channel type.
        ZeroConfOptional FeatureBit = 51

        // KeysendRequired is a required bit that indicates that the node is
        // able and willing to accept keysend payments.
        KeysendRequired = 54

        // KeysendOptional is an optional bit that indicates that the node is
        // able and willing to accept keysend payments.
        KeysendOptional = 55

        // RbfCoopCloseRequired is a required feature bit that signals that
        // the new RBF-based co-op close protocol is supported.
        RbfCoopCloseRequired = 60

        // RbfCoopCloseOptional is an optional feature bit that signals that the
        // new RBF-based co-op close protocol is supported.
        RbfCoopCloseOptional = 61

        // RbfCoopCloseRequiredStaging is a required feature bit that signals
        // that the new RBF-based co-op close protocol is supported.
        RbfCoopCloseRequiredStaging = 160

        // RbfCoopCloseOptionalStaging is an optional feature bit that signals
        // that the new RBF-based co-op close protocol is supported.
        RbfCoopCloseOptionalStaging = 161

        // ScriptEnforcedLeaseRequired is a required feature bit that signals
        // that the node requires channels having zero-fee second-level HTLC
        // transactions, which also imply anchor commitments, along with an
        // additional CLTV constraint of a channel lease's expiration height
        // applied to all outputs that pay directly to the channel initiator.
        //
        // TODO: Decide on actual feature bit value.
        ScriptEnforcedLeaseRequired FeatureBit = 2022

        // ScriptEnforcedLeaseOptional is an optional feature bit that signals
        // that the node requires channels having zero-fee second-level HTLC
        // transactions, which also imply anchor commitments, along with an
        // additional CLTV constraint of a channel lease's expiration height
        // applied to all outputs that pay directly to the channel initiator.
        //
        // TODO: Decide on actual feature bit value.
        ScriptEnforcedLeaseOptional FeatureBit = 2023

        // SimpleTaprootChannelsRequiredFinal is a required bit that indicates
        // the node is able to create taproot-native channels. This is the
        // final feature bit to be used once the channel type is finalized.
        SimpleTaprootChannelsRequiredFinal = 80

        // SimpleTaprootChannelsOptionalFinal is an optional bit that indicates
        // the node is able to create taproot-native channels. This is the
        // final feature bit to be used once the channel type is finalized.
        SimpleTaprootChannelsOptionalFinal = 81

        // SimpleTaprootChannelsRequiredStaging is a required bit that indicates
        // the node is able to create taproot-native channels. This is a
        // feature bit used in the wild while the channel type is still being
        // finalized.
        SimpleTaprootChannelsRequiredStaging = 180

        // SimpleTaprootChannelsOptionalStaging is an optional bit that
        // indicates the node is able to create taproot-native channels. This
        // is a feature bit used in the wild while the channel type is still
        // being finalized.
        SimpleTaprootChannelsOptionalStaging = 181

        // ExperimentalEndorsementRequired is a required feature bit that
        // indicates that the node will relay experimental endorsement signals.
        ExperimentalEndorsementRequired FeatureBit = 260

        // ExperimentalEndorsementOptional is an optional feature bit that
        // indicates that the node will relay experimental endorsement signals.
        ExperimentalEndorsementOptional FeatureBit = 261

        // Bolt11BlindedPathsRequired is a required feature bit that indicates
        // that the node is able to understand the blinded path tagged field in
        // a BOLT 11 invoice.
        Bolt11BlindedPathsRequired = 262

        // Bolt11BlindedPathsOptional is an optional feature bit that indicates
        // that the node is able to understand the blinded path tagged field in
        // a BOLT 11 invoice.
        Bolt11BlindedPathsOptional = 263

        // SimpleTaprootOverlayChansRequired is a required bit that indicates
        // support for the special custom taproot overlay channel.
        SimpleTaprootOverlayChansOptional = 2025

        // SimpleTaprootOverlayChansRequired is a required bit that indicates
        // support for the special custom taproot overlay channel.
        SimpleTaprootOverlayChansRequired = 2026

        // MaxBolt11Feature is the maximum feature bit value allowed in bolt 11
        // invoices.
        //
        // The base 32 encoded tagged fields in invoices are limited to 10 bits
        // to express the length of the field's data.
        //nolint:ll
        // See: https://github.com/lightning/bolts/blob/master/11-payment-encoding.md#tagged-fields
        //
        // With a maximum length field of 1023 (2^10 -1) and 5 bit encoding,
        // the highest feature bit that can be expressed is:
        // 1023 * 5 - 1 = 5114.
        MaxBolt11Feature = 5114
)

// IsRequired returns true if the feature bit is even, and false otherwise.
func (b FeatureBit) IsRequired() bool <span class="cov0" title="0">{
        return b&amp;0x01 == 0x00
}</span>

// Features is a mapping of known feature bits to a descriptive name. All known
// feature bits must be assigned a name in this mapping, and feature bit pairs
// must be assigned together for correct behavior.
var Features = map[FeatureBit]string{
        DataLossProtectRequired:              "data-loss-protect",
        DataLossProtectOptional:              "data-loss-protect",
        InitialRoutingSync:                   "initial-routing-sync",
        UpfrontShutdownScriptRequired:        "upfront-shutdown-script",
        UpfrontShutdownScriptOptional:        "upfront-shutdown-script",
        GossipQueriesRequired:                "gossip-queries",
        GossipQueriesOptional:                "gossip-queries",
        TLVOnionPayloadRequired:              "tlv-onion",
        TLVOnionPayloadOptional:              "tlv-onion",
        StaticRemoteKeyOptional:              "static-remote-key",
        StaticRemoteKeyRequired:              "static-remote-key",
        PaymentAddrOptional:                  "payment-addr",
        PaymentAddrRequired:                  "payment-addr",
        MPPOptional:                          "multi-path-payments",
        MPPRequired:                          "multi-path-payments",
        AnchorsRequired:                      "anchor-commitments",
        AnchorsOptional:                      "anchor-commitments",
        AnchorsZeroFeeHtlcTxRequired:         "anchors-zero-fee-htlc-tx",
        AnchorsZeroFeeHtlcTxOptional:         "anchors-zero-fee-htlc-tx",
        WumboChannelsRequired:                "wumbo-channels",
        WumboChannelsOptional:                "wumbo-channels",
        AMPRequired:                          "amp",
        AMPOptional:                          "amp",
        QuiescenceRequired:                   "quiescence",
        QuiescenceOptional:                   "quiescence",
        PaymentMetadataOptional:              "payment-metadata",
        PaymentMetadataRequired:              "payment-metadata",
        ExplicitChannelTypeOptional:          "explicit-commitment-type",
        ExplicitChannelTypeRequired:          "explicit-commitment-type",
        KeysendOptional:                      "keysend",
        KeysendRequired:                      "keysend",
        ScriptEnforcedLeaseRequired:          "script-enforced-lease",
        ScriptEnforcedLeaseOptional:          "script-enforced-lease",
        ScidAliasRequired:                    "scid-alias",
        ScidAliasOptional:                    "scid-alias",
        ZeroConfRequired:                     "zero-conf",
        ZeroConfOptional:                     "zero-conf",
        RouteBlindingRequired:                "route-blinding",
        RouteBlindingOptional:                "route-blinding",
        ShutdownAnySegwitRequired:            "shutdown-any-segwit",
        ShutdownAnySegwitOptional:            "shutdown-any-segwit",
        SimpleTaprootChannelsRequiredFinal:   "simple-taproot-chans",
        SimpleTaprootChannelsOptionalFinal:   "simple-taproot-chans",
        SimpleTaprootChannelsRequiredStaging: "simple-taproot-chans-x",
        SimpleTaprootChannelsOptionalStaging: "simple-taproot-chans-x",
        SimpleTaprootOverlayChansOptional:    "taproot-overlay-chans",
        SimpleTaprootOverlayChansRequired:    "taproot-overlay-chans",
        ExperimentalEndorsementRequired:      "endorsement-x",
        ExperimentalEndorsementOptional:      "endorsement-x",
        Bolt11BlindedPathsOptional:           "bolt-11-blinded-paths",
        Bolt11BlindedPathsRequired:           "bolt-11-blinded-paths",
        RbfCoopCloseOptional:                 "rbf-coop-close",
        RbfCoopCloseRequired:                 "rbf-coop-close",
        RbfCoopCloseOptionalStaging:          "rbf-coop-close-x",
        RbfCoopCloseRequiredStaging:          "rbf-coop-close-x",
}

// RawFeatureVector represents a set of feature bits as defined in BOLT-09.  A
// RawFeatureVector itself just stores a set of bit flags but can be used to
// construct a FeatureVector which binds meaning to each bit. Feature vectors
// can be serialized and deserialized to/from a byte representation that is
// transmitted in Lightning network messages.
type RawFeatureVector struct {
        features map[FeatureBit]struct{}
}

// NewRawFeatureVector creates a feature vector with all of the feature bits
// given as arguments enabled.
func NewRawFeatureVector(bits ...FeatureBit) *RawFeatureVector <span class="cov0" title="0">{
        fv := &amp;RawFeatureVector{features: make(map[FeatureBit]struct{})}
        for _, bit := range bits </span><span class="cov0" title="0">{
                fv.Set(bit)
        }</span>
        <span class="cov0" title="0">return fv</span>
}

// IsEmpty returns whether the feature vector contains any feature bits.
func (fv RawFeatureVector) IsEmpty() bool <span class="cov0" title="0">{
        return len(fv.features) == 0
}</span>

// OnlyContains determines whether only the specified feature bits are found.
func (fv RawFeatureVector) OnlyContains(bits ...FeatureBit) bool <span class="cov0" title="0">{
        if len(bits) != len(fv.features) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">for _, bit := range bits </span><span class="cov0" title="0">{
                if !fv.IsSet(bit) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

// Equals determines whether two features vectors contain exactly the same
// features.
func (fv RawFeatureVector) Equals(other *RawFeatureVector) bool <span class="cov0" title="0">{
        if len(fv.features) != len(other.features) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">for bit := range fv.features </span><span class="cov0" title="0">{
                if _, ok := other.features[bit]; !ok </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

// Merges sets all feature bits in other on the receiver's feature vector.
func (fv *RawFeatureVector) Merge(other *RawFeatureVector) error <span class="cov0" title="0">{
        for bit := range other.features </span><span class="cov0" title="0">{
                err := fv.SafeSet(bit)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// ValidateUpdate checks whether a feature vector can safely be updated to the
// new feature vector provided, checking that it does not alter any of the
// "standard" features that are defined by LND. The new feature vector should
// be inclusive of all features in the original vector that it still wants to
// advertise, setting and unsetting updates as desired. Features in the vector
// are also checked against a maximum inclusive value, as feature vectors in
// different contexts have different maximum values.
func (fv *RawFeatureVector) ValidateUpdate(other *RawFeatureVector,
        maximumValue FeatureBit) error <span class="cov0" title="0">{

        // Run through the new set of features and check that we're not adding
        // any feature bits that are defined but not set in LND.
        for feature := range other.features </span><span class="cov0" title="0">{
                if fv.IsSet(feature) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if feature &gt; maximumValue </span><span class="cov0" title="0">{
                        return fmt.Errorf("can't set feature bit %d: %w %v",
                                feature, ErrFeatureBitMaximum,
                                maximumValue)
                }</span>

                <span class="cov0" title="0">if name, known := Features[feature]; known </span><span class="cov0" title="0">{
                        return fmt.Errorf("can't set feature "+
                                "bit %d (%v): %w", feature, name,
                                ErrFeatureStandard)
                }</span>
        }

        // Check that the new feature vector for this set does not unset any
        // features that are standard in LND by comparing the features in our
        // current set to the omitted values in the new set.
        <span class="cov0" title="0">for feature := range fv.features </span><span class="cov0" title="0">{
                if other.IsSet(feature) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if name, known := Features[feature]; known </span><span class="cov0" title="0">{
                        return fmt.Errorf("can't unset feature "+
                                "bit %d (%v): %w", feature, name,
                                ErrFeatureStandard)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// ValidatePairs checks each feature bit in a raw vector to ensure that the
// opposing bit is not set, validating that the vector has either the optional
// or required bit set, not both.
func (fv *RawFeatureVector) ValidatePairs() error <span class="cov0" title="0">{
        for feature := range fv.features </span><span class="cov0" title="0">{
                if _, ok := fv.features[feature^1]; ok </span><span class="cov0" title="0">{
                        return ErrFeaturePairExists
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Clone makes a copy of a feature vector.
func (fv *RawFeatureVector) Clone() *RawFeatureVector <span class="cov0" title="0">{
        newFeatures := NewRawFeatureVector()
        for bit := range fv.features </span><span class="cov0" title="0">{
                newFeatures.Set(bit)
        }</span>
        <span class="cov0" title="0">return newFeatures</span>
}

// IsSet returns whether a particular feature bit is enabled in the vector.
func (fv *RawFeatureVector) IsSet(feature FeatureBit) bool <span class="cov0" title="0">{
        _, ok := fv.features[feature]
        return ok
}</span>

// Set marks a feature as enabled in the vector.
func (fv *RawFeatureVector) Set(feature FeatureBit) <span class="cov0" title="0">{
        fv.features[feature] = struct{}{}
}</span>

// SafeSet sets the chosen feature bit in the feature vector, but returns an
// error if the opposing feature bit is already set. This ensures both that we
// are creating properly structured feature vectors, and in some cases, that
// peers are sending properly encoded ones, i.e. it can't be both optional and
// required.
func (fv *RawFeatureVector) SafeSet(feature FeatureBit) error <span class="cov0" title="0">{
        if _, ok := fv.features[feature^1]; ok </span><span class="cov0" title="0">{
                return ErrFeaturePairExists
        }</span>

        <span class="cov0" title="0">fv.Set(feature)
        return nil</span>
}

// Unset marks a feature as disabled in the vector.
func (fv *RawFeatureVector) Unset(feature FeatureBit) <span class="cov0" title="0">{
        delete(fv.features, feature)
}</span>

// SerializeSize returns the number of bytes needed to represent feature vector
// in byte format.
func (fv *RawFeatureVector) SerializeSize() int <span class="cov0" title="0">{
        // We calculate byte-length via the largest bit index.
        return fv.serializeSize(8)
}</span>

// SerializeSize32 returns the number of bytes needed to represent feature
// vector in base32 format.
func (fv *RawFeatureVector) SerializeSize32() int <span class="cov0" title="0">{
        // We calculate base32-length via the largest bit index.
        return fv.serializeSize(5)
}</span>

// serializeSize returns the number of bytes required to encode the feature
// vector using at most width bits per encoded byte.
func (fv *RawFeatureVector) serializeSize(width int) int <span class="cov0" title="0">{
        // Find the largest feature bit index
        max := -1
        for feature := range fv.features </span><span class="cov0" title="0">{
                index := int(feature)
                if index &gt; max </span><span class="cov0" title="0">{
                        max = index
                }</span>
        }
        <span class="cov0" title="0">if max == -1 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">return max/width + 1</span>
}

// Encode writes the feature vector in byte representation. Every feature
// encoded as a bit, and the bit vector is serialized using the least number of
// bytes. Since the bit vector length is variable, the first two bytes of the
// serialization represent the length.
func (fv *RawFeatureVector) Encode(w io.Writer) error <span class="cov0" title="0">{
        // Write length of feature vector.
        var l [2]byte
        length := fv.SerializeSize()
        binary.BigEndian.PutUint16(l[:], uint16(length))
        if _, err := w.Write(l[:]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return fv.encode(w, length, 8)</span>
}

// EncodeBase256 writes the feature vector in base256 representation. Every
// feature is encoded as a bit, and the bit vector is serialized using the least
// number of bytes.
func (fv *RawFeatureVector) EncodeBase256(w io.Writer) error <span class="cov0" title="0">{
        length := fv.SerializeSize()
        return fv.encode(w, length, 8)
}</span>

// EncodeBase32 writes the feature vector in base32 representation. Every feature
// is encoded as a bit, and the bit vector is serialized using the least number of
// bytes.
func (fv *RawFeatureVector) EncodeBase32(w io.Writer) error <span class="cov0" title="0">{
        length := fv.SerializeSize32()
        return fv.encode(w, length, 5)
}</span>

// encode writes the feature vector
func (fv *RawFeatureVector) encode(w io.Writer, length, width int) error <span class="cov0" title="0">{
        // Generate the data and write it.
        data := make([]byte, length)
        for feature := range fv.features </span><span class="cov0" title="0">{
                byteIndex := int(feature) / width
                bitIndex := int(feature) % width
                data[length-byteIndex-1] |= 1 &lt;&lt; uint(bitIndex)
        }</span>

        <span class="cov0" title="0">_, err := w.Write(data)
        return err</span>
}

// Decode reads the feature vector from its byte representation. Every feature
// is encoded as a bit, and the bit vector is serialized using the least number
// of bytes. Since the bit vector length is variable, the first two bytes of the
// serialization represent the length.
func (fv *RawFeatureVector) Decode(r io.Reader) error <span class="cov0" title="0">{
        // Read the length of the feature vector.
        var l [2]byte
        if _, err := io.ReadFull(r, l[:]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">length := binary.BigEndian.Uint16(l[:])

        return fv.decode(r, int(length), 8)</span>
}

// DecodeBase256 reads the feature vector from its base256 representation. Every
// feature encoded as a bit, and the bit vector is serialized using the least
// number of bytes.
func (fv *RawFeatureVector) DecodeBase256(r io.Reader, length int) error <span class="cov0" title="0">{
        return fv.decode(r, length, 8)
}</span>

// DecodeBase32 reads the feature vector from its base32 representation. Every
// feature encoded as a bit, and the bit vector is serialized using the least
// number of bytes.
func (fv *RawFeatureVector) DecodeBase32(r io.Reader, length int) error <span class="cov0" title="0">{
        return fv.decode(r, length, 5)
}</span>

// decode reads a feature vector from the next length bytes of the io.Reader,
// assuming each byte has width feature bits encoded per byte.
func (fv *RawFeatureVector) decode(r io.Reader, length, width int) error <span class="cov0" title="0">{
        // Read the feature vector data.
        data := make([]byte, length)
        if _, err := io.ReadFull(r, data); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Set feature bits from parsed data.
        <span class="cov0" title="0">bitsNumber := len(data) * width
        for i := 0; i &lt; bitsNumber; i++ </span><span class="cov0" title="0">{
                byteIndex := int(i / width)
                bitIndex := uint(i % width)
                if (data[length-byteIndex-1]&gt;&gt;bitIndex)&amp;1 == 1 </span><span class="cov0" title="0">{
                        fv.Set(FeatureBit(i))
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// sizeFunc returns the length required to encode the feature vector.
func (fv *RawFeatureVector) sizeFunc() uint64 <span class="cov0" title="0">{
        return uint64(fv.SerializeSize())
}</span>

// Record returns a TLV record that can be used to encode/decode raw feature
// vectors. Note that the length of the feature vector is not included, because
// it is covered by the TLV record's length field.
func (fv *RawFeatureVector) Record() tlv.Record <span class="cov0" title="0">{
        return tlv.MakeDynamicRecord(
                0, fv, fv.sizeFunc, rawFeatureEncoder, rawFeatureDecoder,
        )
}</span>

// rawFeatureEncoder is a custom TLV encoder for raw feature vectors.
func rawFeatureEncoder(w io.Writer, val interface{}, _ *[8]byte) error <span class="cov0" title="0">{
        if v, ok := val.(*RawFeatureVector); ok </span><span class="cov0" title="0">{
                // Encode the feature bits as a byte slice without its length
                // prepended, as that's already taken care of by the TLV record.
                fv := *v
                return fv.encode(w, fv.SerializeSize(), 8)
        }</span>

        <span class="cov0" title="0">return tlv.NewTypeForEncodingErr(val, "lnwire.RawFeatureVector")</span>
}

// rawFeatureDecoder is a custom TLV decoder for raw feature vectors.
func rawFeatureDecoder(r io.Reader, val interface{}, _ *[8]byte,
        l uint64) error <span class="cov0" title="0">{

        if v, ok := val.(*RawFeatureVector); ok </span><span class="cov0" title="0">{
                fv := NewRawFeatureVector()
                if err := fv.decode(r, int(l), 8); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">*v = *fv

                return nil</span>
        }

        <span class="cov0" title="0">return tlv.NewTypeForEncodingErr(val, "lnwire.RawFeatureVector")</span>
}

// FeatureVector represents a set of enabled features. The set stores
// information on enabled flags and metadata about the feature names. A feature
// vector is serializable to a compact byte representation that is included in
// Lightning network messages.
type FeatureVector struct {
        *RawFeatureVector
        featureNames map[FeatureBit]string
}

// NewFeatureVector constructs a new FeatureVector from a raw feature vector
// and mapping of feature definitions. If the feature vector argument is nil, a
// new one will be constructed with no enabled features.
func NewFeatureVector(featureVector *RawFeatureVector,
        featureNames map[FeatureBit]string) *FeatureVector <span class="cov0" title="0">{

        if featureVector == nil </span><span class="cov0" title="0">{
                featureVector = NewRawFeatureVector()
        }</span>
        <span class="cov0" title="0">return &amp;FeatureVector{
                RawFeatureVector: featureVector,
                featureNames:     featureNames,
        }</span>
}

// EmptyFeatureVector returns a feature vector with no bits set.
func EmptyFeatureVector() *FeatureVector <span class="cov0" title="0">{
        return NewFeatureVector(nil, Features)
}</span>

// Record implements the RecordProducer interface for FeatureVector. Note that
// it uses a zero-value type is used to produce the record, as we expect this
// type value to be overwritten when used in generic TLV record production.
// This allows a single Record function to serve in the many different contexts
// in which feature vectors are encoded. This record wraps the encoding/
// decoding for our raw feature vectors so that we can directly parse fully
// formed feature vector types.
func (fv *FeatureVector) Record() tlv.Record <span class="cov0" title="0">{
        return tlv.MakeDynamicRecord(0, fv, fv.sizeFunc,
                func(w io.Writer, val interface{}, buf *[8]byte) error </span><span class="cov0" title="0">{
                        if f, ok := val.(*FeatureVector); ok </span><span class="cov0" title="0">{
                                return rawFeatureEncoder(
                                        w, f.RawFeatureVector, buf,
                                )
                        }</span>

                        <span class="cov0" title="0">return tlv.NewTypeForEncodingErr(
                                val, "*lnwire.FeatureVector",
                        )</span>
                },
                func(r io.Reader, val interface{}, buf *[8]byte,
                        l uint64) error <span class="cov0" title="0">{

                        if f, ok := val.(*FeatureVector); ok </span><span class="cov0" title="0">{
                                features := NewFeatureVector(nil, Features)
                                err := rawFeatureDecoder(
                                        r, features.RawFeatureVector, buf, l,
                                )
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>

                                <span class="cov0" title="0">*f = *features

                                return nil</span>
                        }

                        <span class="cov0" title="0">return tlv.NewTypeForDecodingErr(
                                val, "*lnwire.FeatureVector", l, l,
                        )</span>
                },
        )
}

// HasFeature returns whether a particular feature is included in the set. The
// feature can be seen as set either if the bit is set directly OR the queried
// bit has the same meaning as its corresponding even/odd bit, which is set
// instead. The second case is because feature bits are generally assigned in
// pairs where both the even and odd position represent the same feature.
func (fv *FeatureVector) HasFeature(feature FeatureBit) bool <span class="cov0" title="0">{
        return fv.IsSet(feature) ||
                (fv.isFeatureBitPair(feature) &amp;&amp; fv.IsSet(feature^1))
}</span>

// RequiresFeature returns true if the referenced feature vector *requires*
// that the given required bit be set. This method can be used with both
// optional and required feature bits as a parameter.
func (fv *FeatureVector) RequiresFeature(feature FeatureBit) bool <span class="cov0" title="0">{
        // If we weren't passed a required feature bit, then we'll flip the
        // lowest bit to query for the required version of the feature. This
        // lets callers pass in both the optional and required bits.
        if !feature.IsRequired() </span><span class="cov0" title="0">{
                feature ^= 1
        }</span>

        <span class="cov0" title="0">return fv.IsSet(feature)</span>
}

// UnknownRequiredFeatures returns a list of feature bits set in the vector
// that are unknown and in an even bit position. Feature bits with an even
// index must be known to a node receiving the feature vector in a message.
func (fv *FeatureVector) UnknownRequiredFeatures() []FeatureBit <span class="cov0" title="0">{
        var unknown []FeatureBit
        for feature := range fv.features </span><span class="cov0" title="0">{
                if feature%2 == 0 &amp;&amp; !fv.IsKnown(feature) </span><span class="cov0" title="0">{
                        unknown = append(unknown, feature)
                }</span>
        }
        <span class="cov0" title="0">return unknown</span>
}

// UnknownFeatures returns a boolean if a feature vector contains *any*
// unknown features (even if they are odd).
func (fv *FeatureVector) UnknownFeatures() bool <span class="cov0" title="0">{
        for feature := range fv.features </span><span class="cov0" title="0">{
                if !fv.IsKnown(feature) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// Name returns a string identifier for the feature represented by this bit. If
// the bit does not represent a known feature, this returns a string indicating
// as such.
func (fv *FeatureVector) Name(bit FeatureBit) string <span class="cov0" title="0">{
        name, known := fv.featureNames[bit]
        if !known </span><span class="cov0" title="0">{
                return "unknown"
        }</span>
        <span class="cov0" title="0">return name</span>
}

// IsKnown returns whether this feature bit represents a known feature.
func (fv *FeatureVector) IsKnown(bit FeatureBit) bool <span class="cov0" title="0">{
        _, known := fv.featureNames[bit]
        return known
}</span>

// isFeatureBitPair returns whether this feature bit and its corresponding
// even/odd bit both represent the same feature. This may often be the case as
// bits are generally assigned in pairs, first being assigned an odd bit
// position then being promoted to an even bit position once the network is
// ready.
func (fv *FeatureVector) isFeatureBitPair(bit FeatureBit) bool <span class="cov0" title="0">{
        name1, known1 := fv.featureNames[bit]
        name2, known2 := fv.featureNames[bit^1]
        return known1 &amp;&amp; known2 &amp;&amp; name1 == name2
}</span>

// Features returns the set of raw features contained in the feature vector.
func (fv *FeatureVector) Features() map[FeatureBit]struct{} <span class="cov0" title="0">{
        fs := make(map[FeatureBit]struct{}, len(fv.RawFeatureVector.features))
        for b := range fv.RawFeatureVector.features </span><span class="cov0" title="0">{
                fs[b] = struct{}{}
        }</span>
        <span class="cov0" title="0">return fs</span>
}

// Clone copies a feature vector, carrying over its feature bits. The feature
// names are not copied.
func (fv *FeatureVector) Clone() *FeatureVector <span class="cov0" title="0">{
        features := fv.RawFeatureVector.Clone()
        return NewFeatureVector(features, fv.featureNames)
}</span>
</pre>
		
		<pre class="file" id="file74" style="display: none">package lnwire

import (
        "bytes"
        "io"

        "github.com/btcsuite/btcd/wire"
        "github.com/lightningnetwork/lnd/tlv"
)

// FundingCreated is sent from Alice (the initiator) to Bob (the responder),
// once Alice receives Bob's contributions as well as his channel constraints.
// Once bob receives this message, he'll gain access to an immediately
// broadcastable commitment transaction and will reply with a signature for
// Alice's version of the commitment transaction.
type FundingCreated struct {
        // PendingChannelID serves to uniquely identify the future channel
        // created by the initiated single funder workflow.
        PendingChannelID [32]byte

        // FundingPoint is the outpoint of the funding transaction created by
        // Alice. With this, Bob is able to generate both his version and
        // Alice's version of the commitment transaction.
        FundingPoint wire.OutPoint

        // CommitSig is Alice's signature from Bob's version of the commitment
        // transaction.
        CommitSig Sig

        // PartialSig is used to transmit a musig2 extended partial signature
        // that also carries along the public nonce of the signer.
        //
        // NOTE: This field is only populated if a musig2 taproot channel is
        // being signed for. In this case, the above Sig type MUST be blank.
        PartialSig OptPartialSigWithNonceTLV

        // ExtraData is the set of data that was appended to this message to
        // fill out the full maximum transport message size. These fields can
        // be used to specify optional data such as custom TLV fields.
        ExtraData ExtraOpaqueData
}

// A compile time check to ensure FundingCreated implements the lnwire.Message
// interface.
var _ Message = (*FundingCreated)(nil)

// A compile time check to ensure FundingCreated implements the
// lnwire.SizeableMessage interface.
var _ SizeableMessage = (*FundingCreated)(nil)

// Encode serializes the target FundingCreated into the passed io.Writer
// implementation. Serialization will observe the rules defined by the passed
// protocol version.
//
// This is part of the lnwire.Message interface.
func (f *FundingCreated) Encode(w *bytes.Buffer, pver uint32) error <span class="cov0" title="0">{
        recordProducers := make([]tlv.RecordProducer, 0, 1)
        f.PartialSig.WhenSome(func(sig PartialSigWithNonceTLV) </span><span class="cov0" title="0">{
                recordProducers = append(recordProducers, &amp;sig)
        }</span>)
        <span class="cov0" title="0">err := EncodeMessageExtraData(&amp;f.ExtraData, recordProducers...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteBytes(w, f.PendingChannelID[:]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteOutPoint(w, f.FundingPoint); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteSig(w, f.CommitSig); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return WriteBytes(w, f.ExtraData)</span>
}

// Decode deserializes the serialized FundingCreated stored in the passed
// io.Reader into the target FundingCreated using the deserialization rules
// defined by the passed protocol version.
//
// This is part of the lnwire.Message interface.
func (f *FundingCreated) Decode(r io.Reader, pver uint32) error <span class="cov0" title="0">{
        err := ReadElements(
                r, f.PendingChannelID[:], &amp;f.FundingPoint, &amp;f.CommitSig,
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var tlvRecords ExtraOpaqueData
        if err := ReadElements(r, &amp;tlvRecords); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">partialSig := f.PartialSig.Zero()
        typeMap, err := tlvRecords.ExtractRecords(&amp;partialSig)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Set the corresponding TLV types if they were included in the stream.
        <span class="cov0" title="0">if val, ok := typeMap[f.PartialSig.TlvType()]; ok &amp;&amp; val == nil </span><span class="cov0" title="0">{
                f.PartialSig = tlv.SomeRecordT(partialSig)
        }</span>

        <span class="cov0" title="0">if len(tlvRecords) != 0 </span><span class="cov0" title="0">{
                f.ExtraData = tlvRecords
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// MsgType returns the uint32 code which uniquely identifies this message as a
// FundingCreated on the wire.
//
// This is part of the lnwire.Message interface.
func (f *FundingCreated) MsgType() MessageType <span class="cov0" title="0">{
        return MsgFundingCreated
}</span>

// SerializedSize returns the serialized size of the message in bytes.
//
// This is part of the lnwire.SizeableMessage interface.
func (f *FundingCreated) SerializedSize() (uint32, error) <span class="cov0" title="0">{
        return MessageSerializedSize(f)
}</span>
</pre>
		
		<pre class="file" id="file75" style="display: none">package lnwire

import (
        "bytes"
        "io"

        "github.com/lightningnetwork/lnd/tlv"
)

// FundingSigned is sent from Bob (the responder) to Alice (the initiator)
// after receiving the funding outpoint and her signature for Bob's version of
// the commitment transaction.
type FundingSigned struct {
        // ChannelPoint is the particular active channel that this
        // FundingSigned is bound to.
        ChanID ChannelID

        // CommitSig is Bob's signature for Alice's version of the commitment
        // transaction.
        CommitSig Sig

        // PartialSig is used to transmit a musig2 extended partial signature
        // that also carries along the public nonce of the signer.
        //
        // NOTE: This field is only populated if a musig2 taproot channel is
        // being signed for. In this case, the above Sig type MUST be blank.
        PartialSig OptPartialSigWithNonceTLV

        // ExtraData is the set of data that was appended to this message to
        // fill out the full maximum transport message size. These fields can
        // be used to specify optional data such as custom TLV fields.
        ExtraData ExtraOpaqueData
}

// A compile time check to ensure FundingSigned implements the lnwire.Message
// interface.
var _ Message = (*FundingSigned)(nil)

// A compile time check to ensure FundingSigned implements the
// lnwire.SizeableMessage interface.
var _ SizeableMessage = (*FundingSigned)(nil)

// Encode serializes the target FundingSigned into the passed io.Writer
// implementation. Serialization will observe the rules defined by the passed
// protocol version.
//
// This is part of the lnwire.Message interface.
func (f *FundingSigned) Encode(w *bytes.Buffer, pver uint32) error <span class="cov0" title="0">{
        recordProducers := make([]tlv.RecordProducer, 0, 1)
        f.PartialSig.WhenSome(func(sig PartialSigWithNonceTLV) </span><span class="cov0" title="0">{
                recordProducers = append(recordProducers, &amp;sig)
        }</span>)
        <span class="cov0" title="0">err := EncodeMessageExtraData(&amp;f.ExtraData, recordProducers...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteChannelID(w, f.ChanID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteSig(w, f.CommitSig); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return WriteBytes(w, f.ExtraData)</span>
}

// Decode deserializes the serialized FundingSigned stored in the passed
// io.Reader into the target FundingSigned using the deserialization rules
// defined by the passed protocol version.
//
// This is part of the lnwire.Message interface.
func (f *FundingSigned) Decode(r io.Reader, pver uint32) error <span class="cov0" title="0">{
        err := ReadElements(r, &amp;f.ChanID, &amp;f.CommitSig)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var tlvRecords ExtraOpaqueData
        if err := ReadElements(r, &amp;tlvRecords); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">partialSig := f.PartialSig.Zero()
        typeMap, err := tlvRecords.ExtractRecords(&amp;partialSig)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Set the corresponding TLV types if they were included in the stream.
        <span class="cov0" title="0">if val, ok := typeMap[f.PartialSig.TlvType()]; ok &amp;&amp; val == nil </span><span class="cov0" title="0">{
                f.PartialSig = tlv.SomeRecordT(partialSig)
        }</span>

        <span class="cov0" title="0">if len(tlvRecords) != 0 </span><span class="cov0" title="0">{
                f.ExtraData = tlvRecords
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// MsgType returns the uint32 code which uniquely identifies this message as a
// FundingSigned on the wire.
//
// This is part of the lnwire.Message interface.
func (f *FundingSigned) MsgType() MessageType <span class="cov0" title="0">{
        return MsgFundingSigned
}</span>

// SerializedSize returns the serialized size of the message in bytes.
//
// This is part of the lnwire.SizeableMessage interface.
func (f *FundingSigned) SerializedSize() (uint32, error) <span class="cov0" title="0">{
        return MessageSerializedSize(f)
}</span>
</pre>
		
		<pre class="file" id="file76" style="display: none">package lnwire

import (
        "bytes"
        "io"

        "github.com/btcsuite/btcd/chaincfg/chainhash"
        "github.com/lightningnetwork/lnd/tlv"
)

// GossipTimestampRange is a message that allows the sender to restrict the set
// of future gossip announcements sent by the receiver. Nodes should send this
// if they have the gossip-queries feature bit active. Nodes are able to send
// new GossipTimestampRange messages to replace the prior window.
type GossipTimestampRange struct {
        // ChainHash denotes the chain that the sender wishes to restrict the
        // set of received announcements of.
        ChainHash chainhash.Hash

        // FirstTimestamp is the timestamp of the earliest announcement message
        // that should be sent by the receiver. This is only to be used for
        // querying message of gossip 1.0 which are timestamped using Unix
        // timestamps. FirstBlockHeight and BlockRange should be used to
        // query for announcement messages timestamped using block heights.
        FirstTimestamp uint32

        // TimestampRange is the horizon beyond the FirstTimestamp that any
        // announcement messages should be sent for. The receiving node MUST
        // NOT send any announcements that have a timestamp greater than
        // FirstTimestamp + TimestampRange. This is used together with
        // FirstTimestamp to query for gossip 1.0 messages timestamped with
        // Unix timestamps.
        TimestampRange uint32

        // FirstBlockHeight is the height of earliest announcement message that
        // should be sent by the receiver. This is used only for querying
        // announcement messages that use block heights as a timestamp.
        FirstBlockHeight tlv.OptionalRecordT[tlv.TlvType2, uint32]

        // BlockRange is the horizon beyond FirstBlockHeight that any
        // announcement messages should be sent for. The receiving node MUST NOT
        // send any announcements that have a timestamp greater than
        // FirstBlockHeight + BlockRange.
        BlockRange tlv.OptionalRecordT[tlv.TlvType4, uint32]

        // ExtraData is the set of data that was appended to this message to
        // fill out the full maximum transport message size. These fields can
        // be used to specify optional data such as custom TLV fields.
        ExtraData ExtraOpaqueData
}

// NewGossipTimestampRange creates a new empty GossipTimestampRange message.
func NewGossipTimestampRange() *GossipTimestampRange <span class="cov0" title="0">{
        return &amp;GossipTimestampRange{}
}</span>

// A compile time check to ensure GossipTimestampRange implements the
// lnwire.Message interface.
var _ Message = (*GossipTimestampRange)(nil)

// A compile time check to ensure GossipTimestampRange implements the
// lnwire.SizeableMessage interface.
var _ SizeableMessage = (*GossipTimestampRange)(nil)

// Decode deserializes a serialized GossipTimestampRange message stored in the
// passed io.Reader observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (g *GossipTimestampRange) Decode(r io.Reader, _ uint32) error <span class="cov0" title="0">{
        err := ReadElements(r,
                g.ChainHash[:],
                &amp;g.FirstTimestamp,
                &amp;g.TimestampRange,
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var tlvRecords ExtraOpaqueData
        if err := ReadElements(r, &amp;tlvRecords); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var (
                firstBlock = tlv.ZeroRecordT[tlv.TlvType2, uint32]()
                blockRange = tlv.ZeroRecordT[tlv.TlvType4, uint32]()
        )
        typeMap, err := tlvRecords.ExtractRecords(&amp;firstBlock, &amp;blockRange)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if val, ok := typeMap[g.FirstBlockHeight.TlvType()]; ok &amp;&amp; val == nil </span><span class="cov0" title="0">{
                g.FirstBlockHeight = tlv.SomeRecordT(firstBlock)
        }</span>
        <span class="cov0" title="0">if val, ok := typeMap[g.BlockRange.TlvType()]; ok &amp;&amp; val == nil </span><span class="cov0" title="0">{
                g.BlockRange = tlv.SomeRecordT(blockRange)
        }</span>

        <span class="cov0" title="0">if len(tlvRecords) != 0 </span><span class="cov0" title="0">{
                g.ExtraData = tlvRecords
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Encode serializes the target GossipTimestampRange into the passed io.Writer
// observing the protocol version specified.
//
// This is part of the lnwire.Message interface.
func (g *GossipTimestampRange) Encode(w *bytes.Buffer, pver uint32) error <span class="cov0" title="0">{
        if err := WriteBytes(w, g.ChainHash[:]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteUint32(w, g.FirstTimestamp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteUint32(w, g.TimestampRange); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">recordProducers := make([]tlv.RecordProducer, 0, 2)
        g.FirstBlockHeight.WhenSome(
                func(height tlv.RecordT[tlv.TlvType2, uint32]) </span><span class="cov0" title="0">{
                        recordProducers = append(recordProducers, &amp;height)
                }</span>,
        )
        <span class="cov0" title="0">g.BlockRange.WhenSome(
                func(blockRange tlv.RecordT[tlv.TlvType4, uint32]) </span><span class="cov0" title="0">{
                        recordProducers = append(recordProducers, &amp;blockRange)
                }</span>,
        )
        <span class="cov0" title="0">err := EncodeMessageExtraData(&amp;g.ExtraData, recordProducers...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return WriteBytes(w, g.ExtraData)</span>
}

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (g *GossipTimestampRange) MsgType() MessageType <span class="cov0" title="0">{
        return MsgGossipTimestampRange
}</span>

// SerializedSize returns the serialized size of the message in bytes.
//
// This is part of the lnwire.SizeableMessage interface.
func (g *GossipTimestampRange) SerializedSize() (uint32, error) <span class="cov0" title="0">{
        return MessageSerializedSize(g)
}</span>
</pre>
		
		<pre class="file" id="file77" style="display: none">package lnwire

import (
        "bytes"
        "io"
)

// Init is the first message reveals the features supported or required by this
// node. Nodes wait for receipt of the other's features to simplify error
// diagnosis where features are incompatible. Each node MUST wait to receive
// init before sending any other messages.
type Init struct {
        // GlobalFeatures is a legacy feature vector used for backwards
        // compatibility with older nodes. Any features defined here should be
        // merged with those presented in Features.
        GlobalFeatures *RawFeatureVector

        // Features is a feature vector containing the features supported by
        // the remote node.
        //
        // NOTE: Older nodes may place some features in GlobalFeatures, but all
        // new features are to be added in Features. When handling an Init
        // message, any GlobalFeatures should be merged into the unified
        // Features field.
        Features *RawFeatureVector

        // ExtraData is the set of data that was appended to this message to
        // fill out the full maximum transport message size. These fields can
        // be used to specify optional data such as custom TLV fields.
        ExtraData ExtraOpaqueData
}

// NewInitMessage creates new instance of init message object.
func NewInitMessage(gf *RawFeatureVector, f *RawFeatureVector) *Init <span class="cov0" title="0">{
        return &amp;Init{
                GlobalFeatures: gf,
                Features:       f,
                ExtraData:      make([]byte, 0),
        }
}</span>

// A compile time check to ensure Init implements the lnwire.Message
// interface.
var _ Message = (*Init)(nil)

// A compile time check to ensure Init implements the lnwire.SizeableMessage
// interface.
var _ SizeableMessage = (*Init)(nil)

// Decode deserializes a serialized Init message stored in the passed
// io.Reader observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (msg *Init) Decode(r io.Reader, pver uint32) error <span class="cov0" title="0">{
        return ReadElements(r,
                &amp;msg.GlobalFeatures,
                &amp;msg.Features,
                &amp;msg.ExtraData,
        )
}</span>

// Encode serializes the target Init into the passed io.Writer observing
// the protocol version specified.
//
// This is part of the lnwire.Message interface.
func (msg *Init) Encode(w *bytes.Buffer, pver uint32) error <span class="cov0" title="0">{
        if err := WriteRawFeatureVector(w, msg.GlobalFeatures); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteRawFeatureVector(w, msg.Features); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return WriteBytes(w, msg.ExtraData)</span>
}

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (msg *Init) MsgType() MessageType <span class="cov0" title="0">{
        return MsgInit
}</span>

// SerializedSize returns the serialized size of the message in bytes.
//
// This is part of the lnwire.SizeableMessage interface.
func (msg *Init) SerializedSize() (uint32, error) <span class="cov0" title="0">{
        return MessageSerializedSize(msg)
}</span>
</pre>
		
		<pre class="file" id="file78" style="display: none">package lnwire

import (
        "bytes"
        "io"
)

// KickoffSig is the message used to transmit the signature for a kickoff
// transaction during the execution phase of a dynamic commitment negotiation
// that requires a reanchoring step.
type KickoffSig struct {
        // ChanID identifies the channel id for which this signature is
        // intended.
        ChanID ChannelID

        // Signature contains the ECDSA signature that signs the kickoff
        // transaction.
        Signature Sig

        // ExtraData is the set of data that was appended to this message to
        // fill out the full maximum transport message size. These fields can
        // be used to specify optional data such as custom TLV fields.
        ExtraData ExtraOpaqueData
}

// A compile time check to ensure that KickoffSig implements the lnwire.Message
// interface.
var _ Message = (*KickoffSig)(nil)

// A compile time check to ensure KickoffSig implements the
// lnwire.SizeableMessage interface.
var _ SizeableMessage = (*KickoffSig)(nil)

// Encode serializes the target KickoffSig into the passed bytes.Buffer
// observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (ks *KickoffSig) Encode(w *bytes.Buffer, _ uint32) error <span class="cov0" title="0">{
        if err := WriteChannelID(w, ks.ChanID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := WriteSig(w, ks.Signature); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return WriteBytes(w, ks.ExtraData)</span>
}

// Decode deserializes a serialized KickoffSig message stored in the passed
// io.Reader observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (ks *KickoffSig) Decode(r io.Reader, _ uint32) error <span class="cov0" title="0">{
        return ReadElements(r, &amp;ks.ChanID, &amp;ks.Signature, &amp;ks.ExtraData)
}</span>

// MsgType returns the integer uniquely identifying KickoffSig on the wire.
//
// This is part of the lnwire.Message interface.
func (ks *KickoffSig) MsgType() MessageType <span class="cov0" title="0">{ return MsgKickoffSig }</span>

// SerializedSize returns the serialized size of the message in bytes.
//
// This is part of the lnwire.SizeableMessage interface.
func (ks *KickoffSig) SerializedSize() (uint32, error) <span class="cov0" title="0">{
        return MessageSerializedSize(ks)
}</span>
</pre>
		
		<pre class="file" id="file79" style="display: none">package lnwire

import (
        "bytes"
        "encoding/binary"
        "fmt"
        "image/color"
        "io"
        "math"
        "net"

        "github.com/btcsuite/btcd/btcec/v2"
        "github.com/btcsuite/btcd/btcutil"
        "github.com/btcsuite/btcd/chaincfg/chainhash"
        "github.com/btcsuite/btcd/wire"
        "github.com/go-errors/errors"
        "github.com/lightningnetwork/lnd/tor"
)

const (
        // MaxSliceLength is the maximum allowed length for any opaque byte
        // slices in the wire protocol.
        MaxSliceLength = 65535

        // MaxMsgBody is the largest payload any message is allowed to provide.
        // This is two less than the MaxSliceLength as each message has a 2
        // byte type that precedes the message body.
        MaxMsgBody = 65533
)

// PkScript is simple type definition which represents a raw serialized public
// key script.
type PkScript []byte

// addressType specifies the network protocol and version that should be used
// when connecting to a node at a particular address.
type addressType uint8

const (
        // noAddr denotes a blank address. An address of this type indicates
        // that a node doesn't have any advertised addresses.
        noAddr addressType = 0

        // tcp4Addr denotes an IPv4 TCP address.
        tcp4Addr addressType = 1

        // tcp6Addr denotes an IPv6 TCP address.
        tcp6Addr addressType = 2

        // v2OnionAddr denotes a version 2 Tor onion service address.
        v2OnionAddr addressType = 3

        // v3OnionAddr denotes a version 3 Tor (prop224) onion service address.
        v3OnionAddr addressType = 4
)

// AddrLen returns the number of bytes that it takes to encode the target
// address.
func (a addressType) AddrLen() uint16 <span class="cov0" title="0">{
        switch a </span>{
        case noAddr:<span class="cov0" title="0">
                return 0</span>
        case tcp4Addr:<span class="cov0" title="0">
                return 6</span>
        case tcp6Addr:<span class="cov0" title="0">
                return 18</span>
        case v2OnionAddr:<span class="cov0" title="0">
                return 12</span>
        case v3OnionAddr:<span class="cov0" title="0">
                return 37</span>
        default:<span class="cov0" title="0">
                return 0</span>
        }
}

// WriteElement is a one-stop shop to write the big endian representation of
// any element which is to be serialized for the wire protocol.
//
// TODO(yy): rm this method once we finish dereferencing it from other
// packages.
func WriteElement(w *bytes.Buffer, element interface{}) error <span class="cov0" title="0">{
        switch e := element.(type) </span>{
        case NodeAlias:<span class="cov0" title="0">
                if _, err := w.Write(e[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        case QueryEncoding:<span class="cov0" title="0">
                var b [1]byte
                b[0] = uint8(e)
                if _, err := w.Write(b[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        case uint8:<span class="cov0" title="0">
                var b [1]byte
                b[0] = e
                if _, err := w.Write(b[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        case FundingFlag:<span class="cov0" title="0">
                var b [1]byte
                b[0] = uint8(e)
                if _, err := w.Write(b[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        case uint16:<span class="cov0" title="0">
                var b [2]byte
                binary.BigEndian.PutUint16(b[:], e)
                if _, err := w.Write(b[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        case ChanUpdateMsgFlags:<span class="cov0" title="0">
                var b [1]byte
                b[0] = uint8(e)
                if _, err := w.Write(b[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        case ChanUpdateChanFlags:<span class="cov0" title="0">
                var b [1]byte
                b[0] = uint8(e)
                if _, err := w.Write(b[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        case MilliSatoshi:<span class="cov0" title="0">
                var b [8]byte
                binary.BigEndian.PutUint64(b[:], uint64(e))
                if _, err := w.Write(b[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        case btcutil.Amount:<span class="cov0" title="0">
                var b [8]byte
                binary.BigEndian.PutUint64(b[:], uint64(e))
                if _, err := w.Write(b[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        case uint32:<span class="cov0" title="0">
                var b [4]byte
                binary.BigEndian.PutUint32(b[:], e)
                if _, err := w.Write(b[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        case uint64:<span class="cov0" title="0">
                var b [8]byte
                binary.BigEndian.PutUint64(b[:], e)
                if _, err := w.Write(b[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        case *btcec.PublicKey:<span class="cov0" title="0">
                if e == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("cannot write nil pubkey")
                }</span>

                <span class="cov0" title="0">var b [33]byte
                serializedPubkey := e.SerializeCompressed()
                copy(b[:], serializedPubkey)
                if _, err := w.Write(b[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        case []Sig:<span class="cov0" title="0">
                var b [2]byte
                numSigs := uint16(len(e))
                binary.BigEndian.PutUint16(b[:], numSigs)
                if _, err := w.Write(b[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">for _, sig := range e </span><span class="cov0" title="0">{
                        if err := WriteElement(w, sig); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

        case Sig:<span class="cov0" title="0">
                // Write buffer
                if _, err := w.Write(e.bytes[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        case PartialSig:<span class="cov0" title="0">
                if err := e.Encode(w); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        case PingPayload:<span class="cov0" title="0">
                var l [2]byte
                binary.BigEndian.PutUint16(l[:], uint16(len(e)))
                if _, err := w.Write(l[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if _, err := w.Write(e[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        case PongPayload:<span class="cov0" title="0">
                var l [2]byte
                binary.BigEndian.PutUint16(l[:], uint16(len(e)))
                if _, err := w.Write(l[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if _, err := w.Write(e[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        case WarningData:<span class="cov0" title="0">
                var l [2]byte
                binary.BigEndian.PutUint16(l[:], uint16(len(e)))
                if _, err := w.Write(l[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if _, err := w.Write(e[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        case ErrorData:<span class="cov0" title="0">
                var l [2]byte
                binary.BigEndian.PutUint16(l[:], uint16(len(e)))
                if _, err := w.Write(l[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if _, err := w.Write(e[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        case OpaqueReason:<span class="cov0" title="0">
                var l [2]byte
                binary.BigEndian.PutUint16(l[:], uint16(len(e)))
                if _, err := w.Write(l[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if _, err := w.Write(e[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        case [33]byte:<span class="cov0" title="0">
                if _, err := w.Write(e[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        case []byte:<span class="cov0" title="0">
                if _, err := w.Write(e[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        case PkScript:<span class="cov0" title="0">
                // The largest script we'll accept is a p2wsh which is exactly
                // 34 bytes long.
                scriptLength := len(e)
                if scriptLength &gt; 34 </span><span class="cov0" title="0">{
                        return fmt.Errorf("'PkScript' too long")
                }</span>

                <span class="cov0" title="0">if err := wire.WriteVarBytes(w, 0, e); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        case *RawFeatureVector:<span class="cov0" title="0">
                if e == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("cannot write nil feature vector")
                }</span>

                <span class="cov0" title="0">if err := e.Encode(w); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        case wire.OutPoint:<span class="cov0" title="0">
                var h [32]byte
                copy(h[:], e.Hash[:])
                if _, err := w.Write(h[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if e.Index &gt; math.MaxUint16 </span><span class="cov0" title="0">{
                        return fmt.Errorf("index for outpoint (%v) is "+
                                "greater than max index of %v", e.Index,
                                math.MaxUint16)
                }</span>

                <span class="cov0" title="0">var idx [2]byte
                binary.BigEndian.PutUint16(idx[:], uint16(e.Index))
                if _, err := w.Write(idx[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        case ChannelID:<span class="cov0" title="0">
                if _, err := w.Write(e[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        case FailCode:<span class="cov0" title="0">
                if err := WriteElement(w, uint16(e)); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        case ShortChannelID:<span class="cov0" title="0">
                // Check that field fit in 3 bytes and write the blockHeight
                if e.BlockHeight &gt; ((1 &lt;&lt; 24) - 1) </span><span class="cov0" title="0">{
                        return errors.New("block height should fit in 3 bytes")
                }</span>

                <span class="cov0" title="0">var blockHeight [4]byte
                binary.BigEndian.PutUint32(blockHeight[:], e.BlockHeight)

                if _, err := w.Write(blockHeight[1:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Check that field fit in 3 bytes and write the txIndex
                <span class="cov0" title="0">if e.TxIndex &gt; ((1 &lt;&lt; 24) - 1) </span><span class="cov0" title="0">{
                        return errors.New("tx index should fit in 3 bytes")
                }</span>

                <span class="cov0" title="0">var txIndex [4]byte
                binary.BigEndian.PutUint32(txIndex[:], e.TxIndex)
                if _, err := w.Write(txIndex[1:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Write the txPosition
                <span class="cov0" title="0">var txPosition [2]byte
                binary.BigEndian.PutUint16(txPosition[:], e.TxPosition)
                if _, err := w.Write(txPosition[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        case *net.TCPAddr:<span class="cov0" title="0">
                if e == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("cannot write nil TCPAddr")
                }</span>

                <span class="cov0" title="0">if e.IP.To4() != nil </span><span class="cov0" title="0">{
                        var descriptor [1]byte
                        descriptor[0] = uint8(tcp4Addr)
                        if _, err := w.Write(descriptor[:]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">var ip [4]byte
                        copy(ip[:], e.IP.To4())
                        if _, err := w.Write(ip[:]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                } else<span class="cov0" title="0"> {
                        var descriptor [1]byte
                        descriptor[0] = uint8(tcp6Addr)
                        if _, err := w.Write(descriptor[:]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">var ip [16]byte
                        copy(ip[:], e.IP.To16())
                        if _, err := w.Write(ip[:]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov0" title="0">var port [2]byte
                binary.BigEndian.PutUint16(port[:], uint16(e.Port))
                if _, err := w.Write(port[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        case *tor.OnionAddr:<span class="cov0" title="0">
                if e == nil </span><span class="cov0" title="0">{
                        return errors.New("cannot write nil onion address")
                }</span>

                <span class="cov0" title="0">var suffixIndex int
                switch len(e.OnionService) </span>{
                case tor.V2Len:<span class="cov0" title="0">
                        descriptor := []byte{byte(v2OnionAddr)}
                        if _, err := w.Write(descriptor); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">suffixIndex = tor.V2Len - tor.OnionSuffixLen</span>
                case tor.V3Len:<span class="cov0" title="0">
                        descriptor := []byte{byte(v3OnionAddr)}
                        if _, err := w.Write(descriptor); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">suffixIndex = tor.V3Len - tor.OnionSuffixLen</span>
                default:<span class="cov0" title="0">
                        return errors.New("unknown onion service length")</span>
                }

                <span class="cov0" title="0">host, err := tor.Base32Encoding.DecodeString(
                        e.OnionService[:suffixIndex],
                )
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if _, err := w.Write(host); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">var port [2]byte
                binary.BigEndian.PutUint16(port[:], uint16(e.Port))
                if _, err := w.Write(port[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        case []net.Addr:<span class="cov0" title="0">
                // First, we'll encode all the addresses into an intermediate
                // buffer. We need to do this in order to compute the total
                // length of the addresses.
                var addrBuf bytes.Buffer
                for _, address := range e </span><span class="cov0" title="0">{
                        if err := WriteElement(&amp;addrBuf, address); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                // With the addresses fully encoded, we can now write out the
                // number of bytes needed to encode them.
                <span class="cov0" title="0">addrLen := addrBuf.Len()
                if err := WriteElement(w, uint16(addrLen)); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Finally, we'll write out the raw addresses themselves, but
                // only if we have any bytes to write.
                <span class="cov0" title="0">if addrLen &gt; 0 </span><span class="cov0" title="0">{
                        if _, err := w.Write(addrBuf.Bytes()); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

        case color.RGBA:<span class="cov0" title="0">
                if err := WriteElements(w, e.R, e.G, e.B); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        case DeliveryAddress:<span class="cov0" title="0">
                var length [2]byte
                binary.BigEndian.PutUint16(length[:], uint16(len(e)))
                if _, err := w.Write(length[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if _, err := w.Write(e[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        case bool:<span class="cov0" title="0">
                var b [1]byte
                if e </span><span class="cov0" title="0">{
                        b[0] = 1
                }</span>
                <span class="cov0" title="0">if _, err := w.Write(b[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        case ExtraOpaqueData:<span class="cov0" title="0">
                return e.Encode(w)</span>

        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown type in WriteElement: %T", e)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// WriteElements is writes each element in the elements slice to the passed
// buffer using WriteElement.
//
// TODO(yy): rm this method once we finish dereferencing it from other
// packages.
func WriteElements(buf *bytes.Buffer, elements ...interface{}) error <span class="cov0" title="0">{
        for _, element := range elements </span><span class="cov0" title="0">{
                err := WriteElement(buf, element)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// ReadElement is a one-stop utility function to deserialize any datastructure
// encoded using the serialization format of lnwire.
func ReadElement(r io.Reader, element interface{}) error <span class="cov0" title="0">{
        var err error
        switch e := element.(type) </span>{
        case *bool:<span class="cov0" title="0">
                var b [1]byte
                if _, err := io.ReadFull(r, b[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if b[0] == 1 </span><span class="cov0" title="0">{
                        *e = true
                }</span>

        case *NodeAlias:<span class="cov0" title="0">
                var a [32]byte
                if _, err := io.ReadFull(r, a[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">alias, err := NewNodeAlias(string(a[:]))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">*e = alias</span>

        case *QueryEncoding:<span class="cov0" title="0">
                var b [1]uint8
                if _, err := r.Read(b[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">*e = QueryEncoding(b[0])</span>

        case *uint8:<span class="cov0" title="0">
                var b [1]uint8
                if _, err := r.Read(b[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">*e = b[0]</span>

        case *FundingFlag:<span class="cov0" title="0">
                var b [1]uint8
                if _, err := r.Read(b[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">*e = FundingFlag(b[0])</span>

        case *uint16:<span class="cov0" title="0">
                var b [2]byte
                if _, err := io.ReadFull(r, b[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">*e = binary.BigEndian.Uint16(b[:])</span>

        case *ChanUpdateMsgFlags:<span class="cov0" title="0">
                var b [1]uint8
                if _, err := r.Read(b[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">*e = ChanUpdateMsgFlags(b[0])</span>

        case *ChanUpdateChanFlags:<span class="cov0" title="0">
                var b [1]uint8
                if _, err := r.Read(b[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">*e = ChanUpdateChanFlags(b[0])</span>

        case *uint32:<span class="cov0" title="0">
                var b [4]byte
                if _, err := io.ReadFull(r, b[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">*e = binary.BigEndian.Uint32(b[:])</span>

        case *uint64:<span class="cov0" title="0">
                var b [8]byte
                if _, err := io.ReadFull(r, b[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">*e = binary.BigEndian.Uint64(b[:])</span>

        case *MilliSatoshi:<span class="cov0" title="0">
                var b [8]byte
                if _, err := io.ReadFull(r, b[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">*e = MilliSatoshi(int64(binary.BigEndian.Uint64(b[:])))</span>

        case *btcutil.Amount:<span class="cov0" title="0">
                var b [8]byte
                if _, err := io.ReadFull(r, b[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">*e = btcutil.Amount(int64(binary.BigEndian.Uint64(b[:])))</span>

        case **btcec.PublicKey:<span class="cov0" title="0">
                var b [btcec.PubKeyBytesLenCompressed]byte
                if _, err = io.ReadFull(r, b[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">pubKey, err := btcec.ParsePubKey(b[:])
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">*e = pubKey</span>

        case *RawFeatureVector:<span class="cov0" title="0">
                f := NewRawFeatureVector()
                err = f.Decode(r)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">*e = *f</span>

        case **RawFeatureVector:<span class="cov0" title="0">
                f := NewRawFeatureVector()
                err = f.Decode(r)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">*e = f</span>

        case *[]Sig:<span class="cov0" title="0">
                var l [2]byte
                if _, err := io.ReadFull(r, l[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">numSigs := binary.BigEndian.Uint16(l[:])

                var sigs []Sig
                if numSigs &gt; 0 </span><span class="cov0" title="0">{
                        sigs = make([]Sig, numSigs)
                        for i := 0; i &lt; int(numSigs); i++ </span><span class="cov0" title="0">{
                                if err := ReadElement(r, &amp;sigs[i]); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }
                <span class="cov0" title="0">*e = sigs</span>

        case *Sig:<span class="cov0" title="0">
                if _, err := io.ReadFull(r, e.bytes[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        case *OpaqueReason:<span class="cov0" title="0">
                var l [2]byte
                if _, err := io.ReadFull(r, l[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">reasonLen := binary.BigEndian.Uint16(l[:])

                *e = OpaqueReason(make([]byte, reasonLen))
                if _, err := io.ReadFull(r, *e); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        case *WarningData:<span class="cov0" title="0">
                var l [2]byte
                if _, err := io.ReadFull(r, l[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">errorLen := binary.BigEndian.Uint16(l[:])

                *e = WarningData(make([]byte, errorLen))
                if _, err := io.ReadFull(r, *e); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        case *ErrorData:<span class="cov0" title="0">
                var l [2]byte
                if _, err := io.ReadFull(r, l[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">errorLen := binary.BigEndian.Uint16(l[:])

                *e = ErrorData(make([]byte, errorLen))
                if _, err := io.ReadFull(r, *e); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        case *PingPayload:<span class="cov0" title="0">
                var l [2]byte
                if _, err := io.ReadFull(r, l[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">pingLen := binary.BigEndian.Uint16(l[:])

                *e = PingPayload(make([]byte, pingLen))
                if _, err := io.ReadFull(r, *e); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        case *PongPayload:<span class="cov0" title="0">
                var l [2]byte
                if _, err := io.ReadFull(r, l[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">pongLen := binary.BigEndian.Uint16(l[:])

                *e = PongPayload(make([]byte, pongLen))
                if _, err := io.ReadFull(r, *e); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        case *[33]byte:<span class="cov0" title="0">
                if _, err := io.ReadFull(r, e[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        case []byte:<span class="cov0" title="0">
                if _, err := io.ReadFull(r, e); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        case *PkScript:<span class="cov0" title="0">
                pkScript, err := wire.ReadVarBytes(r, 0, 34, "pkscript")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">*e = pkScript</span>

        case *wire.OutPoint:<span class="cov0" title="0">
                var h [32]byte
                if _, err = io.ReadFull(r, h[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">hash, err := chainhash.NewHash(h[:])
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">var idxBytes [2]byte
                _, err = io.ReadFull(r, idxBytes[:])
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">index := binary.BigEndian.Uint16(idxBytes[:])

                *e = wire.OutPoint{
                        Hash:  *hash,
                        Index: uint32(index),
                }</span>

        case *FailCode:<span class="cov0" title="0">
                if err := ReadElement(r, (*uint16)(e)); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        case *ChannelID:<span class="cov0" title="0">
                if _, err := io.ReadFull(r, e[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        case *ShortChannelID:<span class="cov0" title="0">
                var blockHeight [4]byte
                if _, err = io.ReadFull(r, blockHeight[1:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">var txIndex [4]byte
                if _, err = io.ReadFull(r, txIndex[1:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">var txPosition [2]byte
                if _, err = io.ReadFull(r, txPosition[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">*e = ShortChannelID{
                        BlockHeight: binary.BigEndian.Uint32(blockHeight[:]),
                        TxIndex:     binary.BigEndian.Uint32(txIndex[:]),
                        TxPosition:  binary.BigEndian.Uint16(txPosition[:]),
                }</span>

        case *[]net.Addr:<span class="cov0" title="0">
                // First, we'll read the number of total bytes that have been
                // used to encode the set of addresses.
                var numAddrsBytes [2]byte
                if _, err = io.ReadFull(r, numAddrsBytes[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">addrsLen := binary.BigEndian.Uint16(numAddrsBytes[:])

                // With the number of addresses, read, we'll now pull in the
                // buffer of the encoded addresses into memory.
                addrs := make([]byte, addrsLen)
                if _, err := io.ReadFull(r, addrs[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">addrBuf := bytes.NewReader(addrs)

                // Finally, we'll parse the remaining address payload in
                // series, using the first byte to denote how to decode the
                // address itself.
                var (
                        addresses     []net.Addr
                        addrBytesRead uint16
                )

                for addrBytesRead &lt; addrsLen </span><span class="cov0" title="0">{
                        var descriptor [1]byte
                        if _, err = io.ReadFull(addrBuf, descriptor[:]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">addrBytesRead++

                        var address net.Addr
                        switch aType := addressType(descriptor[0]); aType </span>{
                        case noAddr:<span class="cov0" title="0">
                                addrBytesRead += aType.AddrLen()
                                continue</span>

                        case tcp4Addr:<span class="cov0" title="0">
                                var ip [4]byte
                                if _, err := io.ReadFull(addrBuf, ip[:]); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>

                                <span class="cov0" title="0">var port [2]byte
                                if _, err := io.ReadFull(addrBuf, port[:]); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>

                                <span class="cov0" title="0">address = &amp;net.TCPAddr{
                                        IP:   net.IP(ip[:]),
                                        Port: int(binary.BigEndian.Uint16(port[:])),
                                }
                                addrBytesRead += aType.AddrLen()</span>

                        case tcp6Addr:<span class="cov0" title="0">
                                var ip [16]byte
                                if _, err := io.ReadFull(addrBuf, ip[:]); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>

                                <span class="cov0" title="0">var port [2]byte
                                if _, err := io.ReadFull(addrBuf, port[:]); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>

                                <span class="cov0" title="0">address = &amp;net.TCPAddr{
                                        IP:   net.IP(ip[:]),
                                        Port: int(binary.BigEndian.Uint16(port[:])),
                                }
                                addrBytesRead += aType.AddrLen()</span>

                        case v2OnionAddr:<span class="cov0" title="0">
                                var h [tor.V2DecodedLen]byte
                                if _, err := io.ReadFull(addrBuf, h[:]); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>

                                <span class="cov0" title="0">var p [2]byte
                                if _, err := io.ReadFull(addrBuf, p[:]); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>

                                <span class="cov0" title="0">onionService := tor.Base32Encoding.EncodeToString(h[:])
                                onionService += tor.OnionSuffix
                                port := int(binary.BigEndian.Uint16(p[:]))

                                address = &amp;tor.OnionAddr{
                                        OnionService: onionService,
                                        Port:         port,
                                }
                                addrBytesRead += aType.AddrLen()</span>

                        case v3OnionAddr:<span class="cov0" title="0">
                                var h [tor.V3DecodedLen]byte
                                if _, err := io.ReadFull(addrBuf, h[:]); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>

                                <span class="cov0" title="0">var p [2]byte
                                if _, err := io.ReadFull(addrBuf, p[:]); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>

                                <span class="cov0" title="0">onionService := tor.Base32Encoding.EncodeToString(h[:])
                                onionService += tor.OnionSuffix
                                port := int(binary.BigEndian.Uint16(p[:]))

                                address = &amp;tor.OnionAddr{
                                        OnionService: onionService,
                                        Port:         port,
                                }
                                addrBytesRead += aType.AddrLen()</span>

                        default:<span class="cov0" title="0">
                                // If we don't understand this address type,
                                // we just store it along with the remaining
                                // address bytes as type OpaqueAddrs. We need
                                // to hold onto the bytes so that we can still
                                // write them back to the wire when we
                                // propagate this message.
                                payloadLen := 1 + addrsLen - addrBytesRead
                                payload := make([]byte, payloadLen)

                                // First write a byte for the address type that
                                // we already read.
                                payload[0] = byte(aType)

                                // Now append the rest of the address bytes.
                                _, err := io.ReadFull(addrBuf, payload[1:])
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>

                                <span class="cov0" title="0">address = &amp;OpaqueAddrs{
                                        Payload: payload,
                                }
                                addrBytesRead = addrsLen</span>
                        }

                        <span class="cov0" title="0">addresses = append(addresses, address)</span>
                }

                <span class="cov0" title="0">*e = addresses</span>

        case *color.RGBA:<span class="cov0" title="0">
                err := ReadElements(r,
                        &amp;e.R,
                        &amp;e.G,
                        &amp;e.B,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        case *DeliveryAddress:<span class="cov0" title="0">
                var addrLen [2]byte
                if _, err = io.ReadFull(r, addrLen[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">length := binary.BigEndian.Uint16(addrLen[:])

                var addrBytes [deliveryAddressMaxSize]byte

                if length &gt; deliveryAddressMaxSize </span><span class="cov0" title="0">{
                        return fmt.Errorf(
                                "cannot read %d bytes into addrBytes", length,
                        )
                }</span>
                <span class="cov0" title="0">if _, err = io.ReadFull(r, addrBytes[:length]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">*e = addrBytes[:length]</span>

        case *PartialSig:<span class="cov0" title="0">
                var sig PartialSig
                if err = sig.Decode(r); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">*e = sig</span>

        case *ExtraOpaqueData:<span class="cov0" title="0">
                return e.Decode(r)</span>

        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown type in ReadElement: %T", e)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// ReadElements deserializes a variable number of elements into the passed
// io.Reader, with each element being deserialized according to the ReadElement
// function.
func ReadElements(r io.Reader, elements ...interface{}) error <span class="cov0" title="0">{
        for _, element := range elements </span><span class="cov0" title="0">{
                err := ReadElement(r, element)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file80" style="display: none">// Copyright (c) 2013-2017 The btcsuite developers
// Copyright (c) 2015-2016 The Decred developers
// code derived from https://github .com/btcsuite/btcd/blob/master/wire/message.go
// Copyright (C) 2015-2022 The Lightning Network Developers

package lnwire

import (
        "bytes"
        "encoding/binary"
        "fmt"
        "io"
)

// MessageTypeSize is the size in bytes of the message type field in the header
// of all messages.
const MessageTypeSize = 2

// MessageType is the unique 2 byte big-endian integer that indicates the type
// of message on the wire. All messages have a very simple header which
// consists simply of 2-byte message type. We omit a length field, and checksum
// as the Lightning Protocol is intended to be encapsulated within a
// confidential+authenticated cryptographic messaging protocol.
type MessageType uint16

// The currently defined message types within this current version of the
// Lightning protocol.
const (
        MsgWarning                 MessageType = 1
        MsgStfu                                = 2
        MsgInit                                = 16
        MsgError                               = 17
        MsgPing                                = 18
        MsgPong                                = 19
        MsgOpenChannel                         = 32
        MsgAcceptChannel                       = 33
        MsgFundingCreated                      = 34
        MsgFundingSigned                       = 35
        MsgChannelReady                        = 36
        MsgShutdown                            = 38
        MsgClosingSigned                       = 39
        MsgClosingComplete                     = 40
        MsgClosingSig                          = 41
        MsgDynPropose                          = 111
        MsgDynAck                              = 113
        MsgDynReject                           = 115
        MsgUpdateAddHTLC                       = 128
        MsgUpdateFulfillHTLC                   = 130
        MsgUpdateFailHTLC                      = 131
        MsgCommitSig                           = 132
        MsgRevokeAndAck                        = 133
        MsgUpdateFee                           = 134
        MsgUpdateFailMalformedHTLC             = 135
        MsgChannelReestablish                  = 136
        MsgChannelAnnouncement                 = 256
        MsgNodeAnnouncement                    = 257
        MsgChannelUpdate                       = 258
        MsgAnnounceSignatures                  = 259
        MsgAnnounceSignatures2                 = 260
        MsgQueryShortChanIDs                   = 261
        MsgReplyShortChanIDsEnd                = 262
        MsgQueryChannelRange                   = 263
        MsgReplyChannelRange                   = 264
        MsgGossipTimestampRange                = 265
        MsgChannelAnnouncement2                = 267
        MsgChannelUpdate2                      = 271
        MsgKickoffSig                          = 777

        // MsgEnd defines the end of the official message range of the protocol.
        // If a new message is added beyond this message, then this should be
        // modified.
        MsgEnd = 778
)

// IsChannelUpdate is a filter function that discerns channel update messages
// from the other messages in the Lightning Network Protocol.
func (t MessageType) IsChannelUpdate() bool <span class="cov0" title="0">{
        switch t </span>{
        case MsgUpdateAddHTLC:<span class="cov0" title="0">
                return true</span>
        case MsgUpdateFulfillHTLC:<span class="cov0" title="0">
                return true</span>
        case MsgUpdateFailHTLC:<span class="cov0" title="0">
                return true</span>
        case MsgUpdateFailMalformedHTLC:<span class="cov0" title="0">
                return true</span>
        case MsgUpdateFee:<span class="cov0" title="0">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// ErrorEncodeMessage is used when failed to encode the message payload.
func ErrorEncodeMessage(err error) error <span class="cov0" title="0">{
        return fmt.Errorf("failed to encode message to buffer, got %w", err)
}</span>

// ErrorWriteMessageType is used when failed to write the message type.
func ErrorWriteMessageType(err error) error <span class="cov0" title="0">{
        return fmt.Errorf("failed to write message type, got %w", err)
}</span>

// ErrorPayloadTooLarge is used when the payload size exceeds the
// MaxMsgBody.
func ErrorPayloadTooLarge(size int) error <span class="cov0" title="0">{
        return fmt.Errorf(
                "message payload is too large - encoded %d bytes, "+
                        "but maximum message payload is %d bytes",
                size, MaxMsgBody,
        )
}</span>

// String return the string representation of message type.
func (t MessageType) String() string <span class="cov0" title="0">{
        switch t </span>{
        case MsgWarning:<span class="cov0" title="0">
                return "Warning"</span>
        case MsgStfu:<span class="cov0" title="0">
                return "Stfu"</span>
        case MsgInit:<span class="cov0" title="0">
                return "Init"</span>
        case MsgOpenChannel:<span class="cov0" title="0">
                return "MsgOpenChannel"</span>
        case MsgAcceptChannel:<span class="cov0" title="0">
                return "MsgAcceptChannel"</span>
        case MsgFundingCreated:<span class="cov0" title="0">
                return "MsgFundingCreated"</span>
        case MsgFundingSigned:<span class="cov0" title="0">
                return "MsgFundingSigned"</span>
        case MsgChannelReady:<span class="cov0" title="0">
                return "ChannelReady"</span>
        case MsgShutdown:<span class="cov0" title="0">
                return "Shutdown"</span>
        case MsgClosingSigned:<span class="cov0" title="0">
                return "ClosingSigned"</span>
        case MsgDynPropose:<span class="cov0" title="0">
                return "DynPropose"</span>
        case MsgDynAck:<span class="cov0" title="0">
                return "DynAck"</span>
        case MsgDynReject:<span class="cov0" title="0">
                return "DynReject"</span>
        case MsgKickoffSig:<span class="cov0" title="0">
                return "KickoffSig"</span>
        case MsgUpdateAddHTLC:<span class="cov0" title="0">
                return "UpdateAddHTLC"</span>
        case MsgUpdateFailHTLC:<span class="cov0" title="0">
                return "UpdateFailHTLC"</span>
        case MsgUpdateFulfillHTLC:<span class="cov0" title="0">
                return "UpdateFulfillHTLC"</span>
        case MsgCommitSig:<span class="cov0" title="0">
                return "CommitSig"</span>
        case MsgRevokeAndAck:<span class="cov0" title="0">
                return "RevokeAndAck"</span>
        case MsgUpdateFailMalformedHTLC:<span class="cov0" title="0">
                return "UpdateFailMalformedHTLC"</span>
        case MsgChannelReestablish:<span class="cov0" title="0">
                return "ChannelReestablish"</span>
        case MsgError:<span class="cov0" title="0">
                return "Error"</span>
        case MsgChannelAnnouncement:<span class="cov0" title="0">
                return "ChannelAnnouncement"</span>
        case MsgChannelUpdate:<span class="cov0" title="0">
                return "ChannelUpdate"</span>
        case MsgNodeAnnouncement:<span class="cov0" title="0">
                return "NodeAnnouncement"</span>
        case MsgPing:<span class="cov0" title="0">
                return "Ping"</span>
        case MsgAnnounceSignatures:<span class="cov0" title="0">
                return "AnnounceSignatures"</span>
        case MsgPong:<span class="cov0" title="0">
                return "Pong"</span>
        case MsgUpdateFee:<span class="cov0" title="0">
                return "UpdateFee"</span>
        case MsgQueryShortChanIDs:<span class="cov0" title="0">
                return "QueryShortChanIDs"</span>
        case MsgReplyShortChanIDsEnd:<span class="cov0" title="0">
                return "ReplyShortChanIDsEnd"</span>
        case MsgQueryChannelRange:<span class="cov0" title="0">
                return "QueryChannelRange"</span>
        case MsgReplyChannelRange:<span class="cov0" title="0">
                return "ReplyChannelRange"</span>
        case MsgGossipTimestampRange:<span class="cov0" title="0">
                return "GossipTimestampRange"</span>
        case MsgClosingComplete:<span class="cov0" title="0">
                return "ClosingComplete"</span>
        case MsgClosingSig:<span class="cov0" title="0">
                return "ClosingSig"</span>
        case MsgAnnounceSignatures2:<span class="cov0" title="0">
                return "MsgAnnounceSignatures2"</span>
        case MsgChannelAnnouncement2:<span class="cov0" title="0">
                return "ChannelAnnouncement2"</span>
        case MsgChannelUpdate2:<span class="cov0" title="0">
                return "ChannelUpdate2"</span>
        default:<span class="cov0" title="0">
                return "&lt;unknown&gt;"</span>
        }
}

// UnknownMessage is an implementation of the error interface that allows the
// creation of an error in response to an unknown message.
type UnknownMessage struct {
        messageType MessageType
}

// Error returns a human readable string describing the error.
//
// This is part of the error interface.
func (u *UnknownMessage) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("unable to parse message of unknown type: %v",
                u.messageType)
}</span>

// Serializable is an interface which defines a lightning wire serializable
// object.
type Serializable interface {
        // Decode reads the bytes stream and converts it to the object.
        Decode(io.Reader, uint32) error

        // Encode converts object to the bytes stream and write it into the
        // write buffer.
        Encode(*bytes.Buffer, uint32) error
}

// Message is an interface that defines a lightning wire protocol message. The
// interface is general in order to allow implementing types full control over
// the representation of its data.
type Message interface {
        Serializable
        MsgType() MessageType
}

// LinkUpdater is an interface implemented by most messages in BOLT 2 that are
// allowed to update the channel state.
type LinkUpdater interface {
        // All LinkUpdater messages are messages and so we embed the interface
        // so that we can treat it as a message if all we know about it is that
        // it is a LinkUpdater message.
        Message

        // TargetChanID returns the channel id of the link for which this
        // message is intended.
        TargetChanID() ChannelID
}

// SizeableMessage is an interface that extends the base Message interface with
// a method to calculate the serialized size of a message.
type SizeableMessage interface {
        Message

        // SerializedSize returns the serialized size of the message in bytes.
        // The returned size includes the message type header bytes.
        SerializedSize() (uint32, error)
}

// MessageSerializedSize calculates the serialized size of a message in bytes.
// This is a helper function that can be used by all message types to implement
// the SerializedSize method.
func MessageSerializedSize(msg Message) (uint32, error) <span class="cov0" title="0">{
        var buf bytes.Buffer

        // Encode the message to the buffer.
        if err := msg.Encode(&amp;buf, 0); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        // Add the size of the message type.
        <span class="cov0" title="0">return uint32(buf.Len()) + MessageTypeSize, nil</span>
}

// makeEmptyMessage creates a new empty message of the proper concrete type
// based on the passed message type.
func makeEmptyMessage(msgType MessageType) (Message, error) <span class="cov0" title="0">{
        var msg Message

        switch msgType </span>{
        case MsgWarning:<span class="cov0" title="0">
                msg = &amp;Warning{}</span>
        case MsgStfu:<span class="cov0" title="0">
                msg = &amp;Stfu{}</span>
        case MsgInit:<span class="cov0" title="0">
                msg = &amp;Init{}</span>
        case MsgOpenChannel:<span class="cov0" title="0">
                msg = &amp;OpenChannel{}</span>
        case MsgAcceptChannel:<span class="cov0" title="0">
                msg = &amp;AcceptChannel{}</span>
        case MsgFundingCreated:<span class="cov0" title="0">
                msg = &amp;FundingCreated{}</span>
        case MsgFundingSigned:<span class="cov0" title="0">
                msg = &amp;FundingSigned{}</span>
        case MsgChannelReady:<span class="cov0" title="0">
                msg = &amp;ChannelReady{}</span>
        case MsgShutdown:<span class="cov0" title="0">
                msg = &amp;Shutdown{}</span>
        case MsgClosingSigned:<span class="cov0" title="0">
                msg = &amp;ClosingSigned{}</span>
        case MsgDynPropose:<span class="cov0" title="0">
                msg = &amp;DynPropose{}</span>
        case MsgDynAck:<span class="cov0" title="0">
                msg = &amp;DynAck{}</span>
        case MsgDynReject:<span class="cov0" title="0">
                msg = &amp;DynReject{}</span>
        case MsgKickoffSig:<span class="cov0" title="0">
                msg = &amp;KickoffSig{}</span>
        case MsgUpdateAddHTLC:<span class="cov0" title="0">
                msg = &amp;UpdateAddHTLC{}</span>
        case MsgUpdateFailHTLC:<span class="cov0" title="0">
                msg = &amp;UpdateFailHTLC{}</span>
        case MsgUpdateFulfillHTLC:<span class="cov0" title="0">
                msg = &amp;UpdateFulfillHTLC{}</span>
        case MsgCommitSig:<span class="cov0" title="0">
                msg = &amp;CommitSig{}</span>
        case MsgRevokeAndAck:<span class="cov0" title="0">
                msg = &amp;RevokeAndAck{}</span>
        case MsgUpdateFee:<span class="cov0" title="0">
                msg = &amp;UpdateFee{}</span>
        case MsgUpdateFailMalformedHTLC:<span class="cov0" title="0">
                msg = &amp;UpdateFailMalformedHTLC{}</span>
        case MsgChannelReestablish:<span class="cov0" title="0">
                msg = &amp;ChannelReestablish{}</span>
        case MsgError:<span class="cov0" title="0">
                msg = &amp;Error{}</span>
        case MsgChannelAnnouncement:<span class="cov0" title="0">
                msg = &amp;ChannelAnnouncement1{}</span>
        case MsgChannelUpdate:<span class="cov0" title="0">
                msg = &amp;ChannelUpdate1{}</span>
        case MsgNodeAnnouncement:<span class="cov0" title="0">
                msg = &amp;NodeAnnouncement{}</span>
        case MsgPing:<span class="cov0" title="0">
                msg = &amp;Ping{}</span>
        case MsgAnnounceSignatures:<span class="cov0" title="0">
                msg = &amp;AnnounceSignatures1{}</span>
        case MsgPong:<span class="cov0" title="0">
                msg = &amp;Pong{}</span>
        case MsgQueryShortChanIDs:<span class="cov0" title="0">
                msg = &amp;QueryShortChanIDs{}</span>
        case MsgReplyShortChanIDsEnd:<span class="cov0" title="0">
                msg = &amp;ReplyShortChanIDsEnd{}</span>
        case MsgQueryChannelRange:<span class="cov0" title="0">
                msg = &amp;QueryChannelRange{}</span>
        case MsgReplyChannelRange:<span class="cov0" title="0">
                msg = &amp;ReplyChannelRange{}</span>
        case MsgGossipTimestampRange:<span class="cov0" title="0">
                msg = &amp;GossipTimestampRange{}</span>
        case MsgClosingComplete:<span class="cov0" title="0">
                msg = &amp;ClosingComplete{}</span>
        case MsgClosingSig:<span class="cov0" title="0">
                msg = &amp;ClosingSig{}</span>
        case MsgAnnounceSignatures2:<span class="cov0" title="0">
                msg = &amp;AnnounceSignatures2{}</span>
        case MsgChannelAnnouncement2:<span class="cov0" title="0">
                msg = &amp;ChannelAnnouncement2{}</span>
        case MsgChannelUpdate2:<span class="cov0" title="0">
                msg = &amp;ChannelUpdate2{}</span>
        default:<span class="cov0" title="0">
                // If the message is not within our custom range and has not
                // specifically been overridden, return an unknown message.
                //
                // Note that we do not allow custom message overrides to replace
                // known message types, only protocol messages that are not yet
                // known to lnd.
                if msgType &lt; CustomTypeStart &amp;&amp; !IsCustomOverride(msgType) </span><span class="cov0" title="0">{
                        return nil, &amp;UnknownMessage{msgType}
                }</span>

                <span class="cov0" title="0">msg = &amp;Custom{
                        Type: msgType,
                }</span>
        }

        <span class="cov0" title="0">return msg, nil</span>
}

// MakeEmptyMessage creates a new empty message of the proper concrete type
// based on the passed message type. This is exported to be used in tests.
func MakeEmptyMessage(msgType MessageType) (Message, error) <span class="cov0" title="0">{
        return makeEmptyMessage(msgType)
}</span>

// WriteMessage writes a lightning Message to a buffer including the necessary
// header information and returns the number of bytes written. If any error is
// encountered, the buffer passed will be reset to its original state since we
// don't want any broken bytes left. In other words, no bytes will be written
// if there's an error. Either all or none of the message bytes will be written
// to the buffer.
//
// NOTE: this method is not concurrent safe.
func WriteMessage(buf *bytes.Buffer, msg Message, pver uint32) (int, error) <span class="cov0" title="0">{
        // Record the size of the bytes already written in buffer.
        oldByteSize := buf.Len()

        // cleanBrokenBytes is a helper closure that helps reset the buffer to
        // its original state. It truncates all the bytes written in current
        // scope.
        var cleanBrokenBytes = func(b *bytes.Buffer) int </span><span class="cov0" title="0">{
                b.Truncate(oldByteSize)
                return 0
        }</span>

        // Write the message type.
        <span class="cov0" title="0">var mType [2]byte
        binary.BigEndian.PutUint16(mType[:], uint16(msg.MsgType()))
        msgTypeBytes, err := buf.Write(mType[:])
        if err != nil </span><span class="cov0" title="0">{
                return cleanBrokenBytes(buf), ErrorWriteMessageType(err)
        }</span>

        // Use the write buffer to encode our message.
        <span class="cov0" title="0">if err := msg.Encode(buf, pver); err != nil </span><span class="cov0" title="0">{
                return cleanBrokenBytes(buf), ErrorEncodeMessage(err)
        }</span>

        // Enforce maximum overall message payload. The write buffer now has
        // the size of len(originalBytes) + len(payload) + len(type). We want
        // to enforce the payload here, so we subtract it by the length of the
        // type and old bytes.
        <span class="cov0" title="0">lenp := buf.Len() - oldByteSize - msgTypeBytes
        if lenp &gt; MaxMsgBody </span><span class="cov0" title="0">{
                return cleanBrokenBytes(buf), ErrorPayloadTooLarge(lenp)
        }</span>

        <span class="cov0" title="0">return buf.Len() - oldByteSize, nil</span>
}

// ReadMessage reads, validates, and parses the next Lightning message from r
// for the provided protocol version.
func ReadMessage(r io.Reader, pver uint32) (Message, error) <span class="cov0" title="0">{
        // First, we'll read out the first two bytes of the message so we can
        // create the proper empty message.
        var mType [2]byte
        if _, err := io.ReadFull(r, mType[:]); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">msgType := MessageType(binary.BigEndian.Uint16(mType[:]))

        // Now that we know the target message type, we can create the proper
        // empty message type and decode the message into it.
        msg, err := makeEmptyMessage(msgType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := msg.Decode(r, pver); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return msg, nil</span>
}
</pre>
		
		<pre class="file" id="file81" style="display: none">package lnwire

import (
        "fmt"
        "io"

        "github.com/btcsuite/btcd/btcutil"
        "github.com/lightningnetwork/lnd/tlv"
)

const (
        // mSatScale is a value that's used to scale satoshis to milli-satoshis, and
        // the other way around.
        mSatScale uint64 = 1000

        // MaxMilliSatoshi is the maximum number of msats that can be expressed
        // in this data type.
        MaxMilliSatoshi = ^MilliSatoshi(0)
)

// MilliSatoshi are the native unit of the Lightning Network. A milli-satoshi
// is simply 1/1000th of a satoshi. There are 1000 milli-satoshis in a single
// satoshi. Within the network, all HTLC payments are denominated in
// milli-satoshis. As milli-satoshis aren't deliverable on the native
// blockchain, before settling to broadcasting, the values are rounded down to
// the nearest satoshi.
type MilliSatoshi uint64

// NewMSatFromSatoshis creates a new MilliSatoshi instance from a target amount
// of satoshis.
func NewMSatFromSatoshis(sat btcutil.Amount) MilliSatoshi <span class="cov0" title="0">{
        return MilliSatoshi(uint64(sat) * mSatScale)
}</span>

// ToBTC converts the target MilliSatoshi amount to its corresponding value
// when expressed in BTC.
func (m MilliSatoshi) ToBTC() float64 <span class="cov0" title="0">{
        sat := m.ToSatoshis()
        return sat.ToBTC()
}</span>

// ToSatoshis converts the target MilliSatoshi amount to satoshis. Simply, this
// sheds a factor of 1000 from the mSAT amount in order to convert it to SAT.
func (m MilliSatoshi) ToSatoshis() btcutil.Amount <span class="cov0" title="0">{
        return btcutil.Amount(uint64(m) / mSatScale)
}</span>

// String returns the string representation of the mSAT amount.
func (m MilliSatoshi) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("%v mSAT", uint64(m))
}</span>

// TODO(roasbeef): extend with arithmetic operations?

// Record returns a TLV record that can be used to encode/decode a MilliSatoshi
// to/from a TLV stream.
func (m *MilliSatoshi) Record() tlv.Record <span class="cov0" title="0">{
        return tlv.MakeDynamicRecord(
                0, m, tlv.SizeBigSize(m), encodeMilliSatoshis,
                decodeMilliSatoshis,
        )
}</span>

func encodeMilliSatoshis(w io.Writer, val interface{}, buf *[8]byte) error <span class="cov0" title="0">{
        if v, ok := val.(*MilliSatoshi); ok </span><span class="cov0" title="0">{
                bigSize := uint64(*v)

                return tlv.EBigSize(w, &amp;bigSize, buf)
        }</span>

        <span class="cov0" title="0">return tlv.NewTypeForEncodingErr(val, "lnwire.MilliSatoshi")</span>
}

func decodeMilliSatoshis(r io.Reader, val interface{}, buf *[8]byte,
        l uint64) error <span class="cov0" title="0">{

        if v, ok := val.(*MilliSatoshi); ok </span><span class="cov0" title="0">{
                var bigSize uint64
                err := tlv.DBigSize(r, &amp;bigSize, buf, l)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">*v = MilliSatoshi(bigSize)

                return nil</span>
        }

        <span class="cov0" title="0">return tlv.NewTypeForDecodingErr(val, "lnwire.MilliSatoshi", l, l)</span>
}
</pre>
		
		<pre class="file" id="file82" style="display: none">package lnwire

import (
        "io"

        "github.com/btcsuite/btcd/btcec/v2/schnorr/musig2"
        "github.com/lightningnetwork/lnd/tlv"
)

// NonceRecordTypeT is the TLV type used to encode a local musig2 nonce.
type NonceRecordTypeT = tlv.TlvType4

// nonceRecordType is the TLV (integer) type used to encode a local musig2
// nonce.
var nonceRecordType tlv.Type = (NonceRecordTypeT)(nil).TypeVal()

type (
        // Musig2Nonce represents a musig2 public nonce, which is the
        // concatenation of two EC points serialized in compressed format.
        Musig2Nonce [musig2.PubNonceSize]byte

        // Musig2NonceTLV is a TLV type that can be used to encode/decode a
        // musig2 nonce. This is an optional TLV.
        Musig2NonceTLV = tlv.RecordT[NonceRecordTypeT, Musig2Nonce]

        // OptMusig2NonceTLV is a TLV type that can be used to encode/decode a
        // musig2 nonce.
        OptMusig2NonceTLV = tlv.OptionalRecordT[NonceRecordTypeT, Musig2Nonce]
)

// Record returns a TLV record that can be used to encode/decode the musig2
// nonce from a given TLV stream.
func (m *Musig2Nonce) Record() tlv.Record <span class="cov0" title="0">{
        return tlv.MakeStaticRecord(
                nonceRecordType, m, musig2.PubNonceSize,
                nonceTypeEncoder, nonceTypeDecoder,
        )
}</span>

// nonceTypeEncoder is a custom TLV encoder for the Musig2Nonce type.
func nonceTypeEncoder(w io.Writer, val interface{}, _ *[8]byte) error <span class="cov0" title="0">{
        if v, ok := val.(*Musig2Nonce); ok </span><span class="cov0" title="0">{
                _, err := w.Write(v[:])
                return err
        }</span>

        <span class="cov0" title="0">return tlv.NewTypeForEncodingErr(val, "lnwire.Musig2Nonce")</span>
}

// nonceTypeDecoder is a custom TLV decoder for the Musig2Nonce record.
func nonceTypeDecoder(r io.Reader, val interface{}, _ *[8]byte,
        l uint64) error <span class="cov0" title="0">{

        if v, ok := val.(*Musig2Nonce); ok </span><span class="cov0" title="0">{
                _, err := io.ReadFull(r, v[:])
                return err
        }</span>

        <span class="cov0" title="0">return tlv.NewTypeForDecodingErr(
                val, "lnwire.Musig2Nonce", l, musig2.PubNonceSize,
        )</span>
}

// SomeMusig2Nonce is a helper function that creates a musig2 nonce TLV.
func SomeMusig2Nonce(nonce Musig2Nonce) OptMusig2NonceTLV <span class="cov0" title="0">{
        return tlv.SomeRecordT(
                tlv.NewRecordT[NonceRecordTypeT, Musig2Nonce](nonce),
        )
}</span>
</pre>
		
		<pre class="file" id="file83" style="display: none">package lnwire

import (
        "fmt"
        "net"

        "github.com/btcsuite/btcd/btcec/v2"
        "github.com/btcsuite/btcd/wire"
)

// NetAddress represents information pertaining to the identity and network
// reachability of a peer. Information stored includes the node's identity
// public key for establishing a confidential+authenticated connection, the
// service bits it supports, and a TCP address the node is reachable at.
//
// TODO(roasbeef): merge with LinkNode in some fashion
type NetAddress struct {
        // IdentityKey is the long-term static public key for a node. This node is
        // used throughout the network as a node's identity key. It is used to
        // authenticate any data sent to the network on behalf of the node, and
        // additionally to establish a confidential+authenticated connection with
        // the node.
        IdentityKey *btcec.PublicKey

        // Address is the IP address and port of the node. This is left
        // general so that multiple implementations can be used.
        Address net.Addr

        // ChainNet is the Bitcoin network this node is associated with.
        // TODO(roasbeef): make a slice in the future for multi-chain
        ChainNet wire.BitcoinNet
}

// A compile time assertion to ensure that NetAddress meets the net.Addr
// interface.
var _ net.Addr = (*NetAddress)(nil)

// String returns a human readable string describing the target NetAddress. The
// current string format is: &lt;pubkey&gt;@host.
//
// This part of the net.Addr interface.
func (n *NetAddress) String() string <span class="cov0" title="0">{
        // TODO(roasbeef): use base58?
        pubkey := n.IdentityKey.SerializeCompressed()

        return fmt.Sprintf("%x@%v", pubkey, n.Address)
}</span>

// Network returns the name of the network this address is bound to.
//
// This part of the net.Addr interface.
func (n *NetAddress) Network() string <span class="cov0" title="0">{
        return n.Address.Network()
}</span>
</pre>
		
		<pre class="file" id="file84" style="display: none">package lnwire

import (
        "bytes"
        "fmt"
        "image/color"
        "io"
        "net"
        "unicode/utf8"
)

// ErrUnknownAddrType is an error returned if we encounter an unknown address type
// when parsing addresses.
type ErrUnknownAddrType struct {
        addrType addressType
}

// Error returns a human readable string describing the error.
//
// NOTE: implements the error interface.
func (e ErrUnknownAddrType) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("unknown address type: %v", e.addrType)
}</span>

// ErrInvalidNodeAlias is an error returned if a node alias we parse on the
// wire is invalid, as in it has non UTF-8 characters.
type ErrInvalidNodeAlias struct{}

// Error returns a human readable string describing the error.
//
// NOTE: implements the error interface.
func (e ErrInvalidNodeAlias) Error() string <span class="cov0" title="0">{
        return "node alias has non-utf8 characters"
}</span>

// NodeAlias is a hex encoded UTF-8 string that may be displayed as an
// alternative to the node's ID. Notice that aliases are not unique and may be
// freely chosen by the node operators.
type NodeAlias [32]byte

// NewNodeAlias creates a new instance of a NodeAlias. Verification is
// performed on the passed string to ensure it meets the alias requirements.
func NewNodeAlias(s string) (NodeAlias, error) <span class="cov0" title="0">{
        var n NodeAlias

        if len(s) &gt; 32 </span><span class="cov0" title="0">{
                return n, fmt.Errorf("alias too large: max is %v, got %v", 32,
                        len(s))
        }</span>

        <span class="cov0" title="0">if !utf8.ValidString(s) </span><span class="cov0" title="0">{
                return n, &amp;ErrInvalidNodeAlias{}
        }</span>

        <span class="cov0" title="0">copy(n[:], []byte(s))
        return n, nil</span>
}

// String returns a utf8 string representation of the alias bytes.
func (n NodeAlias) String() string <span class="cov0" title="0">{
        // Trim trailing zero-bytes for presentation
        return string(bytes.Trim(n[:], "\x00"))
}</span>

// NodeAnnouncement message is used to announce the presence of a Lightning
// node and also to signal that the node is accepting incoming connections.
// Each NodeAnnouncement authenticating the advertised information within the
// announcement via a signature using the advertised node pubkey.
type NodeAnnouncement struct {
        // Signature is used to prove the ownership of node id.
        Signature Sig

        // Features is the list of protocol features this node supports.
        Features *RawFeatureVector

        // Timestamp allows ordering in the case of multiple announcements.
        Timestamp uint32

        // NodeID is a public key which is used as node identification.
        NodeID [33]byte

        // RGBColor is used to customize their node's appearance in maps and
        // graphs
        RGBColor color.RGBA

        // Alias is used to customize their node's appearance in maps and
        // graphs
        Alias NodeAlias

        // Address includes two specification fields: 'ipv6' and 'port' on
        // which the node is accepting incoming connections.
        Addresses []net.Addr

        // ExtraOpaqueData is the set of data that was appended to this
        // message, some of which we may not actually know how to iterate or
        // parse. By holding onto this data, we ensure that we're able to
        // properly validate the set of signatures that cover these new fields,
        // and ensure we're able to make upgrades to the network in a forwards
        // compatible manner.
        ExtraOpaqueData ExtraOpaqueData
}

// A compile time check to ensure NodeAnnouncement implements the
// lnwire.Message interface.
var _ Message = (*NodeAnnouncement)(nil)

// A compile time check to ensure NodeAnnouncement implements the
// lnwire.SizeableMessage interface.
var _ SizeableMessage = (*NodeAnnouncement)(nil)

// Decode deserializes a serialized NodeAnnouncement stored in the passed
// io.Reader observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (a *NodeAnnouncement) Decode(r io.Reader, pver uint32) error <span class="cov0" title="0">{
        return ReadElements(r,
                &amp;a.Signature,
                &amp;a.Features,
                &amp;a.Timestamp,
                &amp;a.NodeID,
                &amp;a.RGBColor,
                &amp;a.Alias,
                &amp;a.Addresses,
                &amp;a.ExtraOpaqueData,
        )
}</span>

// Encode serializes the target NodeAnnouncement into the passed io.Writer
// observing the protocol version specified.
//
// This is part of the lnwire.Message interface.
func (a *NodeAnnouncement) Encode(w *bytes.Buffer, pver uint32) error <span class="cov0" title="0">{
        if err := WriteSig(w, a.Signature); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteRawFeatureVector(w, a.Features); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteUint32(w, a.Timestamp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteBytes(w, a.NodeID[:]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteColorRGBA(w, a.RGBColor); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteNodeAlias(w, a.Alias); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteNetAddrs(w, a.Addresses); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return WriteBytes(w, a.ExtraOpaqueData)</span>
}

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (a *NodeAnnouncement) MsgType() MessageType <span class="cov0" title="0">{
        return MsgNodeAnnouncement
}</span>

// DataToSign returns the part of the message that should be signed.
func (a *NodeAnnouncement) DataToSign() ([]byte, error) <span class="cov0" title="0">{

        // We should not include the signatures itself.
        buffer := make([]byte, 0, MaxMsgBody)
        buf := bytes.NewBuffer(buffer)

        if err := WriteRawFeatureVector(buf, a.Features); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := WriteUint32(buf, a.Timestamp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := WriteBytes(buf, a.NodeID[:]); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := WriteColorRGBA(buf, a.RGBColor); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := WriteNodeAlias(buf, a.Alias); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := WriteNetAddrs(buf, a.Addresses); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := WriteBytes(buf, a.ExtraOpaqueData); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return buf.Bytes(), nil</span>
}

// SerializedSize returns the serialized size of the message in bytes.
//
// This is part of the lnwire.SizeableMessage interface.
func (a *NodeAnnouncement) SerializedSize() (uint32, error) <span class="cov0" title="0">{
        return MessageSerializedSize(a)
}</span>
</pre>
		
		<pre class="file" id="file85" style="display: none">package lnwire

import (
        "bufio"
        "bytes"
        "crypto/sha256"
        "encoding/binary"
        "fmt"
        "io"

        "github.com/davecgh/go-spew/spew"
        "github.com/go-errors/errors"
        "github.com/lightningnetwork/lnd/fn/v2"
        "github.com/lightningnetwork/lnd/tlv"
)

// FailureMessage represents the onion failure object identified by its unique
// failure code.
type FailureMessage interface {
        // Code returns a failure code describing the exact nature of the
        // error.
        Code() FailCode

        // Error returns a human readable string describing the error. With
        // this method, the FailureMessage interface meets the built-in error
        // interface.
        Error() string
}

// FailureMessageLength is the size of the failure message plus the size of
// padding. The FailureMessage message should always be EXACTLY this size.
const FailureMessageLength = 256

const (
        // FlagBadOnion error flag describes an unparsable, encrypted by
        // previous node.
        FlagBadOnion FailCode = 0x8000

        // FlagPerm error flag indicates a permanent failure.
        FlagPerm FailCode = 0x4000

        // FlagNode error flag indicates a node failure.
        FlagNode FailCode = 0x2000

        // FlagUpdate error flag indicates a new channel update is enclosed
        // within the error.
        FlagUpdate FailCode = 0x1000
)

// FailCode specifies the precise reason that an upstream HTLC was canceled.
// Each UpdateFailHTLC message carries a FailCode which is to be passed
// backwards, encrypted at each step back to the source of the HTLC within the
// route.
type FailCode uint16

// The currently defined onion failure types within this current version of the
// Lightning protocol.
const (
        CodeNone                             FailCode = 0
        CodeInvalidRealm                              = FlagBadOnion | 1
        CodeTemporaryNodeFailure                      = FlagNode | 2
        CodePermanentNodeFailure                      = FlagPerm | FlagNode | 2
        CodeRequiredNodeFeatureMissing                = FlagPerm | FlagNode | 3
        CodeInvalidOnionVersion                       = FlagBadOnion | FlagPerm | 4
        CodeInvalidOnionHmac                          = FlagBadOnion | FlagPerm | 5
        CodeInvalidOnionKey                           = FlagBadOnion | FlagPerm | 6
        CodeTemporaryChannelFailure                   = FlagUpdate | 7
        CodePermanentChannelFailure                   = FlagPerm | 8
        CodeRequiredChannelFeatureMissing             = FlagPerm | 9
        CodeUnknownNextPeer                           = FlagPerm | 10
        CodeAmountBelowMinimum                        = FlagUpdate | 11
        CodeFeeInsufficient                           = FlagUpdate | 12
        CodeIncorrectCltvExpiry                       = FlagUpdate | 13
        CodeExpiryTooSoon                             = FlagUpdate | 14
        CodeChannelDisabled                           = FlagUpdate | 20
        CodeIncorrectOrUnknownPaymentDetails          = FlagPerm | 15
        CodeIncorrectPaymentAmount                    = FlagPerm | 16
        CodeFinalExpiryTooSoon               FailCode = 17
        CodeFinalIncorrectCltvExpiry         FailCode = 18
        CodeFinalIncorrectHtlcAmount         FailCode = 19
        CodeExpiryTooFar                     FailCode = 21
        CodeInvalidOnionPayload                       = FlagPerm | 22
        CodeMPPTimeout                       FailCode = 23
        CodeInvalidBlinding                           = FlagBadOnion | FlagPerm | 24 //nolint:ll
)

// String returns the string representation of the failure code.
func (c FailCode) String() string <span class="cov0" title="0">{
        switch c </span>{
        case CodeInvalidRealm:<span class="cov0" title="0">
                return "InvalidRealm"</span>

        case CodeTemporaryNodeFailure:<span class="cov0" title="0">
                return "TemporaryNodeFailure"</span>

        case CodePermanentNodeFailure:<span class="cov0" title="0">
                return "PermanentNodeFailure"</span>

        case CodeRequiredNodeFeatureMissing:<span class="cov0" title="0">
                return "RequiredNodeFeatureMissing"</span>

        case CodeInvalidOnionVersion:<span class="cov0" title="0">
                return "InvalidOnionVersion"</span>

        case CodeInvalidOnionHmac:<span class="cov0" title="0">
                return "InvalidOnionHmac"</span>

        case CodeInvalidOnionKey:<span class="cov0" title="0">
                return "InvalidOnionKey"</span>

        case CodeTemporaryChannelFailure:<span class="cov0" title="0">
                return "TemporaryChannelFailure"</span>

        case CodePermanentChannelFailure:<span class="cov0" title="0">
                return "PermanentChannelFailure"</span>

        case CodeRequiredChannelFeatureMissing:<span class="cov0" title="0">
                return "RequiredChannelFeatureMissing"</span>

        case CodeUnknownNextPeer:<span class="cov0" title="0">
                return "UnknownNextPeer"</span>

        case CodeAmountBelowMinimum:<span class="cov0" title="0">
                return "AmountBelowMinimum"</span>

        case CodeFeeInsufficient:<span class="cov0" title="0">
                return "FeeInsufficient"</span>

        case CodeIncorrectCltvExpiry:<span class="cov0" title="0">
                return "IncorrectCltvExpiry"</span>

        case CodeIncorrectPaymentAmount:<span class="cov0" title="0">
                return "IncorrectPaymentAmount"</span>

        case CodeExpiryTooSoon:<span class="cov0" title="0">
                return "ExpiryTooSoon"</span>

        case CodeChannelDisabled:<span class="cov0" title="0">
                return "ChannelDisabled"</span>

        case CodeIncorrectOrUnknownPaymentDetails:<span class="cov0" title="0">
                return "IncorrectOrUnknownPaymentDetails"</span>

        case CodeFinalExpiryTooSoon:<span class="cov0" title="0">
                return "FinalExpiryTooSoon"</span>

        case CodeFinalIncorrectCltvExpiry:<span class="cov0" title="0">
                return "FinalIncorrectCltvExpiry"</span>

        case CodeFinalIncorrectHtlcAmount:<span class="cov0" title="0">
                return "FinalIncorrectHtlcAmount"</span>

        case CodeExpiryTooFar:<span class="cov0" title="0">
                return "ExpiryTooFar"</span>

        case CodeInvalidOnionPayload:<span class="cov0" title="0">
                return "InvalidOnionPayload"</span>

        case CodeMPPTimeout:<span class="cov0" title="0">
                return "MPPTimeout"</span>

        case CodeInvalidBlinding:<span class="cov0" title="0">
                return "InvalidBlinding"</span>

        default:<span class="cov0" title="0">
                return "&lt;unknown&gt;"</span>
        }
}

// FailInvalidRealm is returned if the realm byte is unknown.
//
// NOTE: May be returned by any node in the payment route.
type FailInvalidRealm struct{}

// Returns a human readable string describing the target FailureMessage.
//
// NOTE: Implements the error interface.
func (f *FailInvalidRealm) Error() string <span class="cov0" title="0">{
        return f.Code().String()
}</span>

// Code returns the failure unique code.
//
// NOTE: Part of the FailureMessage interface.
func (f *FailInvalidRealm) Code() FailCode <span class="cov0" title="0">{
        return CodeInvalidRealm
}</span>

// FailTemporaryNodeFailure is returned if an otherwise unspecified transient
// error occurs for the entire node.
//
// NOTE: May be returned by any node in the payment route.
type FailTemporaryNodeFailure struct{}

// Code returns the failure unique code.
// NOTE: Part of the FailureMessage interface.
func (f *FailTemporaryNodeFailure) Code() FailCode <span class="cov0" title="0">{
        return CodeTemporaryNodeFailure
}</span>

// Returns a human readable string describing the target FailureMessage.
//
// NOTE: Implements the error interface.
func (f *FailTemporaryNodeFailure) Error() string <span class="cov0" title="0">{
        return f.Code().String()
}</span>

// FailPermanentNodeFailure is returned if an otherwise unspecified permanent
// error occurs for the entire node.
//
// NOTE: May be returned by any node in the payment route.
type FailPermanentNodeFailure struct{}

// Code returns the failure unique code.
//
// NOTE: Part of the FailureMessage interface.
func (f *FailPermanentNodeFailure) Code() FailCode <span class="cov0" title="0">{
        return CodePermanentNodeFailure
}</span>

// Returns a human readable string describing the target FailureMessage.
//
// NOTE: Implements the error interface.
func (f *FailPermanentNodeFailure) Error() string <span class="cov0" title="0">{
        return f.Code().String()
}</span>

// FailRequiredNodeFeatureMissing is returned if a node has requirement
// advertised in its node_announcement features which were not present in the
// onion.
//
// NOTE: May be returned by any node in the payment route.
type FailRequiredNodeFeatureMissing struct{}

// Code returns the failure unique code.
//
// NOTE: Part of the FailureMessage interface.
func (f *FailRequiredNodeFeatureMissing) Code() FailCode <span class="cov0" title="0">{
        return CodeRequiredNodeFeatureMissing
}</span>

// Returns a human readable string describing the target FailureMessage.
//
// NOTE: Implements the error interface.
func (f *FailRequiredNodeFeatureMissing) Error() string <span class="cov0" title="0">{
        return f.Code().String()
}</span>

// FailPermanentChannelFailure is return if an otherwise unspecified permanent
// error occurs for the outgoing channel (eg. channel (recently).
//
// NOTE: May be returned by any node in the payment route.
type FailPermanentChannelFailure struct{}

// Code returns the failure unique code.
//
// NOTE: Part of the FailureMessage interface.
func (f *FailPermanentChannelFailure) Code() FailCode <span class="cov0" title="0">{
        return CodePermanentChannelFailure
}</span>

// Returns a human readable string describing the target FailureMessage.
//
// NOTE: Implements the error interface.
func (f *FailPermanentChannelFailure) Error() string <span class="cov0" title="0">{
        return f.Code().String()
}</span>

// FailRequiredChannelFeatureMissing is returned if the outgoing channel has a
// requirement advertised in its channel announcement features which were not
// present in the onion.
//
// NOTE: May only be returned by intermediate nodes.
type FailRequiredChannelFeatureMissing struct{}

// Code returns the failure unique code.
//
// NOTE: Part of the FailureMessage interface.
func (f *FailRequiredChannelFeatureMissing) Code() FailCode <span class="cov0" title="0">{
        return CodeRequiredChannelFeatureMissing
}</span>

// Returns a human readable string describing the target FailureMessage.
//
// NOTE: Implements the error interface.
func (f *FailRequiredChannelFeatureMissing) Error() string <span class="cov0" title="0">{
        return f.Code().String()
}</span>

// FailUnknownNextPeer is returned if the next peer specified by the onion is
// not known.
//
// NOTE: May only be returned by intermediate nodes.
type FailUnknownNextPeer struct{}

// Code returns the failure unique code.
//
// NOTE: Part of the FailureMessage interface.
func (f *FailUnknownNextPeer) Code() FailCode <span class="cov0" title="0">{
        return CodeUnknownNextPeer
}</span>

// Returns a human readable string describing the target FailureMessage.
//
// NOTE: Implements the error interface.
func (f *FailUnknownNextPeer) Error() string <span class="cov0" title="0">{
        return f.Code().String()
}</span>

// FailIncorrectPaymentAmount is returned if the amount paid is less than the
// amount expected, the final node MUST fail the HTLC. If the amount paid is
// more than twice the amount expected, the final node SHOULD fail the HTLC.
// This allows the sender to reduce information leakage by altering the amount,
// without allowing accidental gross overpayment.
//
// NOTE: May only be returned by the final node in the path.
type FailIncorrectPaymentAmount struct{}

// Code returns the failure unique code.
//
// NOTE: Part of the FailureMessage interface.
func (f *FailIncorrectPaymentAmount) Code() FailCode <span class="cov0" title="0">{
        return CodeIncorrectPaymentAmount
}</span>

// Returns a human readable string describing the target FailureMessage.
//
// NOTE: Implements the error interface.
func (f *FailIncorrectPaymentAmount) Error() string <span class="cov0" title="0">{
        return f.Code().String()
}</span>

// FailIncorrectDetails is returned for two reasons:
//
// 1) if the payment hash has already been paid, the final node MAY treat the
// payment hash as unknown, or may succeed in accepting the HTLC. If the
// payment hash is unknown, the final node MUST fail the HTLC.
//
// 2) if the amount paid is less than the amount expected, the final node MUST
// fail the HTLC. If the amount paid is more than twice the amount expected,
// the final node SHOULD fail the HTLC. This allows the sender to reduce
// information leakage by altering the amount, without allowing accidental
// gross overpayment.
//
// NOTE: May only be returned by the final node in the path.
type FailIncorrectDetails struct {
        // amount is the value of the extended HTLC.
        amount MilliSatoshi

        // height is the block height when the htlc was received.
        height uint32

        // extraOpaqueData contains additional failure message tlv data.
        extraOpaqueData ExtraOpaqueData
}

// NewFailIncorrectDetails makes a new instance of the FailIncorrectDetails
// error bound to the specified HTLC amount and acceptance height.
func NewFailIncorrectDetails(amt MilliSatoshi,
        height uint32) *FailIncorrectDetails <span class="cov0" title="0">{

        return &amp;FailIncorrectDetails{
                amount:          amt,
                height:          height,
                extraOpaqueData: []byte{},
        }
}</span>

// Amount is the value of the extended HTLC.
func (f *FailIncorrectDetails) Amount() MilliSatoshi <span class="cov0" title="0">{
        return f.amount
}</span>

// Height is the block height when the htlc was received.
func (f *FailIncorrectDetails) Height() uint32 <span class="cov0" title="0">{
        return f.height
}</span>

// ExtraOpaqueData returns additional failure message tlv data.
func (f *FailIncorrectDetails) ExtraOpaqueData() ExtraOpaqueData <span class="cov0" title="0">{
        return f.extraOpaqueData
}</span>

// Code returns the failure unique code.
//
// NOTE: Part of the FailureMessage interface.
func (f *FailIncorrectDetails) Code() FailCode <span class="cov0" title="0">{
        return CodeIncorrectOrUnknownPaymentDetails
}</span>

// Returns a human readable string describing the target FailureMessage.
//
// NOTE: Implements the error interface.
func (f *FailIncorrectDetails) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf(
                "%v(amt=%v, height=%v)", CodeIncorrectOrUnknownPaymentDetails,
                f.amount, f.height,
        )
}</span>

// Decode decodes the failure from bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailIncorrectDetails) Decode(r io.Reader, pver uint32) error <span class="cov0" title="0">{
        err := ReadElement(r, &amp;f.amount)
        switch </span>{
        // This is an optional tack on that was added later in the protocol. As
        // a result, older nodes may not include this value. We'll account for
        // this by checking for io.EOF here which means that no bytes were read
        // at all.
        case err == io.EOF:<span class="cov0" title="0">
                return nil</span>

        case err != nil:<span class="cov0" title="0">
                return err</span>
        }

        // At a later stage, the height field was also tacked on. We need to
        // check for io.EOF here as well.
        <span class="cov0" title="0">err = ReadElement(r, &amp;f.height)
        switch </span>{
        case err == io.EOF:<span class="cov0" title="0">
                return nil</span>

        case err != nil:<span class="cov0" title="0">
                return err</span>
        }

        <span class="cov0" title="0">return f.extraOpaqueData.Decode(r)</span>
}

// Encode writes the failure in bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailIncorrectDetails) Encode(w *bytes.Buffer, pver uint32) error <span class="cov0" title="0">{
        if err := WriteMilliSatoshi(w, f.amount); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteUint32(w, f.height); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return f.extraOpaqueData.Encode(w)</span>
}

// FailFinalExpiryTooSoon is returned if the cltv_expiry is too low, the final
// node MUST fail the HTLC.
//
// NOTE: May only be returned by the final node in the path.
type FailFinalExpiryTooSoon struct{}

// Code returns the failure unique code.
//
// NOTE: Part of the FailureMessage interface.
func (f *FailFinalExpiryTooSoon) Code() FailCode <span class="cov0" title="0">{
        return CodeFinalExpiryTooSoon
}</span>

// Returns a human readable string describing the target FailureMessage.
//
// NOTE: Implements the error interface.
func (f *FailFinalExpiryTooSoon) Error() string <span class="cov0" title="0">{
        return f.Code().String()
}</span>

// NewFinalExpiryTooSoon creates new instance of the FailFinalExpiryTooSoon.
func NewFinalExpiryTooSoon() *FailFinalExpiryTooSoon <span class="cov0" title="0">{
        return &amp;FailFinalExpiryTooSoon{}
}</span>

// FailInvalidOnionVersion is returned if the onion version byte is unknown.
//
// NOTE: May be returned only by intermediate nodes.
type FailInvalidOnionVersion struct {
        // OnionSHA256 hash of the onion blob which haven't been proceeded.
        OnionSHA256 [sha256.Size]byte
}

// Returns a human readable string describing the target FailureMessage.
//
// NOTE: Implements the error interface.
func (f *FailInvalidOnionVersion) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("InvalidOnionVersion(onion_sha=%x)", f.OnionSHA256[:])
}</span>

// NewInvalidOnionVersion creates new instance of the FailInvalidOnionVersion.
func NewInvalidOnionVersion(onion []byte) *FailInvalidOnionVersion <span class="cov0" title="0">{
        return &amp;FailInvalidOnionVersion{OnionSHA256: sha256.Sum256(onion)}
}</span>

// Code returns the failure unique code.
//
// NOTE: Part of the FailureMessage interface.
func (f *FailInvalidOnionVersion) Code() FailCode <span class="cov0" title="0">{
        return CodeInvalidOnionVersion
}</span>

// Decode decodes the failure from bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailInvalidOnionVersion) Decode(r io.Reader, pver uint32) error <span class="cov0" title="0">{
        return ReadElement(r, f.OnionSHA256[:])
}</span>

// Encode writes the failure in bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailInvalidOnionVersion) Encode(w *bytes.Buffer, pver uint32) error <span class="cov0" title="0">{
        return WriteBytes(w, f.OnionSHA256[:])
}</span>

// FailInvalidOnionHmac is return if the onion HMAC is incorrect.
//
// NOTE: May only be returned by intermediate nodes.
type FailInvalidOnionHmac struct {
        // OnionSHA256 hash of the onion blob which haven't been proceeded.
        OnionSHA256 [sha256.Size]byte
}

// NewInvalidOnionHmac creates new instance of the FailInvalidOnionHmac.
func NewInvalidOnionHmac(onion []byte) *FailInvalidOnionHmac <span class="cov0" title="0">{
        return &amp;FailInvalidOnionHmac{OnionSHA256: sha256.Sum256(onion)}
}</span>

// Code returns the failure unique code.
//
// NOTE: Part of the FailureMessage interface.
func (f *FailInvalidOnionHmac) Code() FailCode <span class="cov0" title="0">{
        return CodeInvalidOnionHmac
}</span>

// Decode decodes the failure from bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailInvalidOnionHmac) Decode(r io.Reader, pver uint32) error <span class="cov0" title="0">{
        return ReadElement(r, f.OnionSHA256[:])
}</span>

// Encode writes the failure in bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailInvalidOnionHmac) Encode(w *bytes.Buffer, pver uint32) error <span class="cov0" title="0">{
        return WriteBytes(w, f.OnionSHA256[:])
}</span>

// Returns a human readable string describing the target FailureMessage.
//
// NOTE: Implements the error interface.
func (f *FailInvalidOnionHmac) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("InvalidOnionHMAC(onion_sha=%x)", f.OnionSHA256[:])
}</span>

// FailInvalidOnionKey is return if the ephemeral key in the onion is
// unparsable.
//
// NOTE: May only be returned by intermediate nodes.
type FailInvalidOnionKey struct {
        // OnionSHA256 hash of the onion blob which haven't been proceeded.
        OnionSHA256 [sha256.Size]byte
}

// NewInvalidOnionKey creates new instance of the FailInvalidOnionKey.
func NewInvalidOnionKey(onion []byte) *FailInvalidOnionKey <span class="cov0" title="0">{
        return &amp;FailInvalidOnionKey{OnionSHA256: sha256.Sum256(onion)}
}</span>

// Code returns the failure unique code.
//
// NOTE: Part of the FailureMessage interface.
func (f *FailInvalidOnionKey) Code() FailCode <span class="cov0" title="0">{
        return CodeInvalidOnionKey
}</span>

// Decode decodes the failure from bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailInvalidOnionKey) Decode(r io.Reader, pver uint32) error <span class="cov0" title="0">{
        return ReadElement(r, f.OnionSHA256[:])
}</span>

// Encode writes the failure in bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailInvalidOnionKey) Encode(w *bytes.Buffer, pver uint32) error <span class="cov0" title="0">{
        return WriteBytes(w, f.OnionSHA256[:])
}</span>

// Returns a human readable string describing the target FailureMessage.
//
// NOTE: Implements the error interface.
func (f *FailInvalidOnionKey) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("InvalidOnionKey(onion_sha=%x)", f.OnionSHA256[:])
}</span>

// parseChannelUpdateCompatibilityMode will attempt to parse a channel updated
// encoded into an onion error payload in two ways. First, we'll try the
// compatibility oriented version wherein we'll _skip_ the length prefixing on
// the channel update message. Older versions of c-lighting do this so we'll
// attempt to parse these messages in order to retain compatibility. If we're
// unable to pull out a fully valid version, then we'll fall back to the
// regular parsing mechanism which includes the length prefix an NO type byte.
func parseChannelUpdateCompatibilityMode(reader io.Reader, length uint16,
        chanUpdate *ChannelUpdate1, pver uint32) error <span class="cov0" title="0">{

        // Instantiate a LimitReader because there may be additional data
        // present after the channel update. Without limiting the stream, the
        // additional data would be interpreted as channel update tlv data.
        limitReader := io.LimitReader(reader, int64(length))

        r := bufio.NewReader(limitReader)

        // We'll peek out two bytes from the buffer without advancing the
        // buffer so we can decide how to parse the remainder of it.
        maybeTypeBytes, err := r.Peek(2)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Some nodes well prefix an additional set of bytes in front of their
        // channel updates. These bytes will _almost_ always be 258 or the type
        // of the ChannelUpdate message.
        <span class="cov0" title="0">typeInt := binary.BigEndian.Uint16(maybeTypeBytes)
        if typeInt == MsgChannelUpdate </span><span class="cov0" title="0">{
                // At this point it's likely the case that this is a channel
                // update message with its type prefixed, so we'll snip off the
                // first two bytes and parse it as normal.
                var throwAwayTypeBytes [2]byte
                _, err := r.Read(throwAwayTypeBytes[:])
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // At this pint, we've either decided to keep the entire thing, or snip
        // off the first two bytes. In either case, we can just read it as
        // normal.
        <span class="cov0" title="0">return chanUpdate.Decode(r, pver)</span>
}

// FailTemporaryChannelFailure is if an otherwise unspecified transient error
// occurs for the outgoing channel (eg. channel capacity reached, too many
// in-flight htlcs)
//
// NOTE: May only be returned by intermediate nodes.
type FailTemporaryChannelFailure struct {
        // Update is used to update information about state of the channel
        // which caused the failure.
        //
        // NOTE: This field is optional.
        Update *ChannelUpdate1
}

// NewTemporaryChannelFailure creates new instance of the FailTemporaryChannelFailure.
func NewTemporaryChannelFailure(
        update *ChannelUpdate1) *FailTemporaryChannelFailure <span class="cov0" title="0">{

        return &amp;FailTemporaryChannelFailure{Update: update}
}</span>

// Code returns the failure unique code.
//
// NOTE: Part of the FailureMessage interface.
func (f *FailTemporaryChannelFailure) Code() FailCode <span class="cov0" title="0">{
        return CodeTemporaryChannelFailure
}</span>

// Returns a human readable string describing the target FailureMessage.
//
// NOTE: Implements the error interface.
func (f *FailTemporaryChannelFailure) Error() string <span class="cov0" title="0">{
        if f.Update == nil </span><span class="cov0" title="0">{
                return f.Code().String()
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("TemporaryChannelFailure(update=%v)",
                spew.Sdump(f.Update))</span>
}

// Decode decodes the failure from bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailTemporaryChannelFailure) Decode(r io.Reader, pver uint32) error <span class="cov0" title="0">{
        var length uint16
        err := ReadElement(r, &amp;length)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if length != 0 </span><span class="cov0" title="0">{
                f.Update = &amp;ChannelUpdate1{}

                return parseChannelUpdateCompatibilityMode(
                        r, length, f.Update, pver,
                )
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Encode writes the failure in bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailTemporaryChannelFailure) Encode(w *bytes.Buffer,
        pver uint32) error <span class="cov0" title="0">{

        if f.Update != nil </span><span class="cov0" title="0">{
                return writeOnionErrorChanUpdate(w, f.Update, pver)
        }</span>

        // Write zero length to indicate no channel_update is present.
        <span class="cov0" title="0">return WriteUint16(w, 0)</span>
}

// FailAmountBelowMinimum is returned if the HTLC does not reach the current
// minimum amount, we tell them the amount of the incoming HTLC and the current
// channel setting for the outgoing channel.
//
// NOTE: May only be returned by the intermediate nodes in the path.
type FailAmountBelowMinimum struct {
        // HtlcMsat is the wrong amount of the incoming HTLC.
        HtlcMsat MilliSatoshi

        // Update is used to update information about state of the channel
        // which caused the failure.
        Update ChannelUpdate1
}

// NewAmountBelowMinimum creates new instance of the FailAmountBelowMinimum.
func NewAmountBelowMinimum(htlcMsat MilliSatoshi,
        update ChannelUpdate1) *FailAmountBelowMinimum <span class="cov0" title="0">{

        return &amp;FailAmountBelowMinimum{
                HtlcMsat: htlcMsat,
                Update:   update,
        }
}</span>

// Code returns the failure unique code.
//
// NOTE: Part of the FailureMessage interface.
func (f *FailAmountBelowMinimum) Code() FailCode <span class="cov0" title="0">{
        return CodeAmountBelowMinimum
}</span>

// Returns a human readable string describing the target FailureMessage.
//
// NOTE: Implements the error interface.
func (f *FailAmountBelowMinimum) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("AmountBelowMinimum(amt=%v, update=%v", f.HtlcMsat,
                spew.Sdump(f.Update))
}</span>

// Decode decodes the failure from bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailAmountBelowMinimum) Decode(r io.Reader, pver uint32) error <span class="cov0" title="0">{
        if err := ReadElement(r, &amp;f.HtlcMsat); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var length uint16
        if err := ReadElement(r, &amp;length); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">f.Update = ChannelUpdate1{}

        return parseChannelUpdateCompatibilityMode(
                r, length, &amp;f.Update, pver,
        )</span>
}

// Encode writes the failure in bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailAmountBelowMinimum) Encode(w *bytes.Buffer, pver uint32) error <span class="cov0" title="0">{
        if err := WriteMilliSatoshi(w, f.HtlcMsat); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return writeOnionErrorChanUpdate(w, &amp;f.Update, pver)</span>
}

// FailFeeInsufficient is returned if the HTLC does not pay sufficient fee, we
// tell them the amount of the incoming HTLC and the current channel setting
// for the outgoing channel.
//
// NOTE: May only be returned by intermediate nodes.
type FailFeeInsufficient struct {
        // HtlcMsat is the wrong amount of the incoming HTLC.
        HtlcMsat MilliSatoshi

        // Update is used to update information about state of the channel
        // which caused the failure.
        Update ChannelUpdate1
}

// NewFeeInsufficient creates new instance of the FailFeeInsufficient.
func NewFeeInsufficient(htlcMsat MilliSatoshi,
        update ChannelUpdate1) *FailFeeInsufficient <span class="cov0" title="0">{
        return &amp;FailFeeInsufficient{
                HtlcMsat: htlcMsat,
                Update:   update,
        }
}</span>

// Code returns the failure unique code.
//
// NOTE: Part of the FailureMessage interface.
func (f *FailFeeInsufficient) Code() FailCode <span class="cov0" title="0">{
        return CodeFeeInsufficient
}</span>

// Returns a human readable string describing the target FailureMessage.
//
// NOTE: Implements the error interface.
func (f *FailFeeInsufficient) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("FeeInsufficient(htlc_amt==%v, update=%v", f.HtlcMsat,
                spew.Sdump(f.Update))
}</span>

// Decode decodes the failure from bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailFeeInsufficient) Decode(r io.Reader, pver uint32) error <span class="cov0" title="0">{
        if err := ReadElement(r, &amp;f.HtlcMsat); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var length uint16
        if err := ReadElement(r, &amp;length); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">f.Update = ChannelUpdate1{}

        return parseChannelUpdateCompatibilityMode(
                r, length, &amp;f.Update, pver,
        )</span>
}

// Encode writes the failure in bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailFeeInsufficient) Encode(w *bytes.Buffer, pver uint32) error <span class="cov0" title="0">{
        if err := WriteMilliSatoshi(w, f.HtlcMsat); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return writeOnionErrorChanUpdate(w, &amp;f.Update, pver)</span>
}

// FailIncorrectCltvExpiry is returned if outgoing cltv value does not match
// the update add htlc's cltv expiry minus cltv expiry delta for the outgoing
// channel, we tell them the cltv expiry and the current channel setting for
// the outgoing channel.
//
// NOTE: May only be returned by intermediate nodes.
type FailIncorrectCltvExpiry struct {
        // CltvExpiry is the wrong absolute timeout in blocks, after which
        // outgoing HTLC expires.
        CltvExpiry uint32

        // Update is used to update information about state of the channel
        // which caused the failure.
        Update ChannelUpdate1
}

// NewIncorrectCltvExpiry creates new instance of the FailIncorrectCltvExpiry.
func NewIncorrectCltvExpiry(cltvExpiry uint32,
        update ChannelUpdate1) *FailIncorrectCltvExpiry <span class="cov0" title="0">{

        return &amp;FailIncorrectCltvExpiry{
                CltvExpiry: cltvExpiry,
                Update:     update,
        }
}</span>

// Code returns the failure unique code.
//
// NOTE: Part of the FailureMessage interface.
func (f *FailIncorrectCltvExpiry) Code() FailCode <span class="cov0" title="0">{
        return CodeIncorrectCltvExpiry
}</span>

func (f *FailIncorrectCltvExpiry) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("IncorrectCltvExpiry(expiry=%v, update=%v",
                f.CltvExpiry, spew.Sdump(f.Update))
}</span>

// Decode decodes the failure from bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailIncorrectCltvExpiry) Decode(r io.Reader, pver uint32) error <span class="cov0" title="0">{
        if err := ReadElement(r, &amp;f.CltvExpiry); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var length uint16
        if err := ReadElement(r, &amp;length); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">f.Update = ChannelUpdate1{}

        return parseChannelUpdateCompatibilityMode(
                r, length, &amp;f.Update, pver,
        )</span>
}

// Encode writes the failure in bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailIncorrectCltvExpiry) Encode(w *bytes.Buffer, pver uint32) error <span class="cov0" title="0">{
        if err := WriteUint32(w, f.CltvExpiry); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return writeOnionErrorChanUpdate(w, &amp;f.Update, pver)</span>
}

// FailExpiryTooSoon is returned if the ctlv-expiry is too near, we tell them
// the current channel setting for the outgoing channel.
//
// NOTE: May only be returned by intermediate nodes.
type FailExpiryTooSoon struct {
        // Update is used to update information about state of the channel
        // which caused the failure.
        Update ChannelUpdate1
}

// NewExpiryTooSoon creates new instance of the FailExpiryTooSoon.
func NewExpiryTooSoon(update ChannelUpdate1) *FailExpiryTooSoon <span class="cov0" title="0">{
        return &amp;FailExpiryTooSoon{
                Update: update,
        }
}</span>

// Code returns the failure unique code.
//
// NOTE: Part of the FailureMessage interface.
func (f *FailExpiryTooSoon) Code() FailCode <span class="cov0" title="0">{
        return CodeExpiryTooSoon
}</span>

// Returns a human readable string describing the target FailureMessage.
//
// NOTE: Implements the error interface.
func (f *FailExpiryTooSoon) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("ExpiryTooSoon(update=%v", spew.Sdump(f.Update))
}</span>

// Decode decodes the failure from l stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailExpiryTooSoon) Decode(r io.Reader, pver uint32) error <span class="cov0" title="0">{
        var length uint16
        if err := ReadElement(r, &amp;length); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">f.Update = ChannelUpdate1{}

        return parseChannelUpdateCompatibilityMode(
                r, length, &amp;f.Update, pver,
        )</span>
}

// Encode writes the failure in bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailExpiryTooSoon) Encode(w *bytes.Buffer, pver uint32) error <span class="cov0" title="0">{
        return writeOnionErrorChanUpdate(w, &amp;f.Update, pver)
}</span>

// FailChannelDisabled is returned if the channel is disabled, we tell them the
// current channel setting for the outgoing channel.
//
// NOTE: May only be returned by intermediate nodes.
type FailChannelDisabled struct {
        // Flags least-significant bit must be set to 0 if the creating node
        // corresponds to the first node in the previously sent channel
        // announcement and 1 otherwise.
        Flags uint16

        // Update is used to update information about state of the channel
        // which caused the failure.
        Update ChannelUpdate1
}

// NewChannelDisabled creates new instance of the FailChannelDisabled.
func NewChannelDisabled(flags uint16,
        update ChannelUpdate1) *FailChannelDisabled <span class="cov0" title="0">{

        return &amp;FailChannelDisabled{
                Flags:  flags,
                Update: update,
        }
}</span>

// Code returns the failure unique code.
//
// NOTE: Part of the FailureMessage interface.
func (f *FailChannelDisabled) Code() FailCode <span class="cov0" title="0">{
        return CodeChannelDisabled
}</span>

// Returns a human readable string describing the target FailureMessage.
//
// NOTE: Implements the error interface.
func (f *FailChannelDisabled) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("ChannelDisabled(flags=%v, update=%v", f.Flags,
                spew.Sdump(f.Update))
}</span>

// Decode decodes the failure from bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailChannelDisabled) Decode(r io.Reader, pver uint32) error <span class="cov0" title="0">{
        if err := ReadElement(r, &amp;f.Flags); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var length uint16
        if err := ReadElement(r, &amp;length); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">f.Update = ChannelUpdate1{}

        return parseChannelUpdateCompatibilityMode(
                r, length, &amp;f.Update, pver,
        )</span>
}

// Encode writes the failure in bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailChannelDisabled) Encode(w *bytes.Buffer, pver uint32) error <span class="cov0" title="0">{
        if err := WriteUint16(w, f.Flags); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return writeOnionErrorChanUpdate(w, &amp;f.Update, pver)</span>
}

// FailFinalIncorrectCltvExpiry is returned if the outgoing_cltv_value does not
// match the ctlv_expiry of the HTLC at the final hop.
//
// NOTE: might be returned by final node only.
type FailFinalIncorrectCltvExpiry struct {
        // CltvExpiry is the wrong absolute timeout in blocks, after which
        // outgoing HTLC expires.
        CltvExpiry uint32
}

// Returns a human readable string describing the target FailureMessage.
//
// NOTE: Implements the error interface.
func (f *FailFinalIncorrectCltvExpiry) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("FinalIncorrectCltvExpiry(expiry=%v)", f.CltvExpiry)
}</span>

// NewFinalIncorrectCltvExpiry creates new instance of the
// FailFinalIncorrectCltvExpiry.
func NewFinalIncorrectCltvExpiry(cltvExpiry uint32) *FailFinalIncorrectCltvExpiry <span class="cov0" title="0">{
        return &amp;FailFinalIncorrectCltvExpiry{
                CltvExpiry: cltvExpiry,
        }
}</span>

// Code returns the failure unique code.
//
// NOTE: Part of the FailureMessage interface.
func (f *FailFinalIncorrectCltvExpiry) Code() FailCode <span class="cov0" title="0">{
        return CodeFinalIncorrectCltvExpiry
}</span>

// Decode decodes the failure from bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailFinalIncorrectCltvExpiry) Decode(r io.Reader, pver uint32) error <span class="cov0" title="0">{
        return ReadElement(r, &amp;f.CltvExpiry)
}</span>

// Encode writes the failure in bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailFinalIncorrectCltvExpiry) Encode(w *bytes.Buffer,
        pver uint32) error <span class="cov0" title="0">{

        return WriteUint32(w, f.CltvExpiry)
}</span>

// FailFinalIncorrectHtlcAmount is returned if the amt_to_forward is higher
// than incoming_htlc_amt of the HTLC at the final hop.
//
// NOTE: May only be returned by the final node.
type FailFinalIncorrectHtlcAmount struct {
        // IncomingHTLCAmount is the wrong forwarded htlc amount.
        IncomingHTLCAmount MilliSatoshi
}

// Returns a human readable string describing the target FailureMessage.
//
// NOTE: Implements the error interface.
func (f *FailFinalIncorrectHtlcAmount) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("FinalIncorrectHtlcAmount(amt=%v)",
                f.IncomingHTLCAmount)
}</span>

// NewFinalIncorrectHtlcAmount creates new instance of the
// FailFinalIncorrectHtlcAmount.
func NewFinalIncorrectHtlcAmount(amount MilliSatoshi) *FailFinalIncorrectHtlcAmount <span class="cov0" title="0">{
        return &amp;FailFinalIncorrectHtlcAmount{
                IncomingHTLCAmount: amount,
        }
}</span>

// Code returns the failure unique code.
//
// NOTE: Part of the FailureMessage interface.
func (f *FailFinalIncorrectHtlcAmount) Code() FailCode <span class="cov0" title="0">{
        return CodeFinalIncorrectHtlcAmount
}</span>

// Decode decodes the failure from bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailFinalIncorrectHtlcAmount) Decode(r io.Reader, pver uint32) error <span class="cov0" title="0">{
        return ReadElement(r, &amp;f.IncomingHTLCAmount)
}</span>

// Encode writes the failure in bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailFinalIncorrectHtlcAmount) Encode(w *bytes.Buffer,
        pver uint32) error <span class="cov0" title="0">{

        return WriteMilliSatoshi(w, f.IncomingHTLCAmount)
}</span>

// FailExpiryTooFar is returned if the CLTV expiry in the HTLC is too far in the
// future.
//
// NOTE: May be returned by any node in the payment route.
type FailExpiryTooFar struct{}

// Code returns the failure unique code.
//
// NOTE: Part of the FailureMessage interface.
func (f *FailExpiryTooFar) Code() FailCode <span class="cov0" title="0">{
        return CodeExpiryTooFar
}</span>

// Returns a human readable string describing the target FailureMessage.
//
// NOTE: Implements the error interface.
func (f *FailExpiryTooFar) Error() string <span class="cov0" title="0">{
        return f.Code().String()
}</span>

// InvalidOnionPayload is returned if the hop could not process the TLV payload
// enclosed in the onion.
type InvalidOnionPayload struct {
        // Type is the TLV type that caused the specific failure.
        Type uint64

        // Offset is the byte offset within the payload where the failure
        // occurred.
        Offset uint16
}

// NewInvalidOnionPayload initializes a new InvalidOnionPayload failure.
func NewInvalidOnionPayload(typ uint64, offset uint16) *InvalidOnionPayload <span class="cov0" title="0">{
        return &amp;InvalidOnionPayload{
                Type:   typ,
                Offset: offset,
        }
}</span>

// Code returns the failure unique code.
//
// NOTE: Part of the FailureMessage interface.
func (f *InvalidOnionPayload) Code() FailCode <span class="cov0" title="0">{
        return CodeInvalidOnionPayload
}</span>

// Returns a human readable string describing the target FailureMessage.
//
// NOTE: Implements the error interface.
func (f *InvalidOnionPayload) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("%v(type=%v, offset=%d)",
                f.Code(), f.Type, f.Offset)
}</span>

// Decode decodes the failure from bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *InvalidOnionPayload) Decode(r io.Reader, pver uint32) error <span class="cov0" title="0">{
        var buf [8]byte
        typ, err := tlv.ReadVarInt(r, &amp;buf)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">f.Type = typ

        return ReadElements(r, &amp;f.Offset)</span>
}

// Encode writes the failure in bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *InvalidOnionPayload) Encode(w *bytes.Buffer, pver uint32) error <span class="cov0" title="0">{
        var buf [8]byte
        if err := tlv.WriteVarInt(w, f.Type, &amp;buf); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return WriteUint16(w, f.Offset)</span>
}

// FailMPPTimeout is returned if the complete amount for a multi part payment
// was not received within a reasonable time.
//
// NOTE: May only be returned by the final node in the path.
type FailMPPTimeout struct{}

// Code returns the failure unique code.
//
// NOTE: Part of the FailureMessage interface.
func (f *FailMPPTimeout) Code() FailCode <span class="cov0" title="0">{
        return CodeMPPTimeout
}</span>

// Returns a human readable string describing the target FailureMessage.
//
// NOTE: Implements the error interface.
func (f *FailMPPTimeout) Error() string <span class="cov0" title="0">{
        return f.Code().String()
}</span>

// FailInvalidBlinding is returned if there has been a route blinding related
// error.
type FailInvalidBlinding struct {
        OnionSHA256 [sha256.Size]byte
}

// Code returns the failure unique code.
//
// NOTE: Part of the FailureMessage interface.
func (f *FailInvalidBlinding) Code() FailCode <span class="cov0" title="0">{
        return CodeInvalidBlinding
}</span>

// Returns a human readable string describing the target FailureMessage.
//
// NOTE: Implements the error interface.
func (f *FailInvalidBlinding) Error() string <span class="cov0" title="0">{
        return f.Code().String()
}</span>

// Decode decodes the failure from bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailInvalidBlinding) Decode(r io.Reader, _ uint32) error <span class="cov0" title="0">{
        return ReadElement(r, f.OnionSHA256[:])
}</span>

// Encode writes the failure in bytes stream.
//
// NOTE: Part of the Serializable interface.
func (f *FailInvalidBlinding) Encode(w *bytes.Buffer, _ uint32) error <span class="cov0" title="0">{
        return WriteBytes(w, f.OnionSHA256[:])
}</span>

// NewInvalidBlinding creates new instance of FailInvalidBlinding.
func NewInvalidBlinding(
        onion fn.Option[[OnionPacketSize]byte]) *FailInvalidBlinding <span class="cov0" title="0">{
        // The spec allows empty onion hashes for invalid blinding, so we only
        // include our onion hash if it's provided.
        if onion.IsNone() </span><span class="cov0" title="0">{
                return &amp;FailInvalidBlinding{}
        }</span>

        <span class="cov0" title="0">shaSum := fn.MapOptionZ(onion, func(o [OnionPacketSize]byte) [32]byte </span><span class="cov0" title="0">{
                return sha256.Sum256(o[:])
        }</span>)

        <span class="cov0" title="0">return &amp;FailInvalidBlinding{OnionSHA256: shaSum}</span>
}

// DecodeFailure decodes, validates, and parses the lnwire onion failure, for
// the provided protocol version.
func DecodeFailure(r io.Reader, pver uint32) (FailureMessage, error) <span class="cov0" title="0">{
        // First, we'll parse out the encapsulated failure message itself. This
        // is a 2 byte length followed by the payload itself.
        var failureLength uint16
        if err := ReadElement(r, &amp;failureLength); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to read failure len: %w", err)
        }</span>

        <span class="cov0" title="0">failureData := make([]byte, failureLength)
        if _, err := io.ReadFull(r, failureData); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to full read payload of "+
                        "%v: %w", failureLength, err)
        }</span>

        // Read the padding.
        <span class="cov0" title="0">var padLength uint16
        if err := ReadElement(r, &amp;padLength); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to read pad len: %w", err)
        }</span>

        <span class="cov0" title="0">if _, err := io.CopyN(io.Discard, r, int64(padLength)); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to read padding %w", err)
        }</span>

        // Verify that we are at the end of the stream now.
        <span class="cov0" title="0">scratch := make([]byte, 1)
        _, err := r.Read(scratch)
        if err != io.EOF </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unexpected failure bytes")
        }</span>

        // Check the total length. Convert to 32 bits to prevent overflow.
        <span class="cov0" title="0">totalLength := uint32(padLength) + uint32(failureLength)
        if totalLength &lt; FailureMessageLength </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failure message too short: "+
                        "msg=%v, pad=%v, total=%v",
                        failureLength, padLength, totalLength)
        }</span>

        // Decode the failure message.
        <span class="cov0" title="0">dataReader := bytes.NewReader(failureData)

        return DecodeFailureMessage(dataReader, pver)</span>
}

// DecodeFailureMessage decodes just the failure message, ignoring any padding
// that may be present at the end.
func DecodeFailureMessage(r io.Reader, pver uint32) (FailureMessage, error) <span class="cov0" title="0">{
        // Once we have the failure data, we can obtain the failure code from
        // the first two bytes of the buffer.
        var codeBytes [2]byte
        if _, err := io.ReadFull(r, codeBytes[:]); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to read failure code: %w", err)
        }</span>
        <span class="cov0" title="0">failCode := FailCode(binary.BigEndian.Uint16(codeBytes[:]))

        // Create the empty failure by given code and populate the failure with
        // additional data if needed.
        failure, err := makeEmptyOnionError(failCode)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to make empty error: %w", err)
        }</span>

        // Finally, if this failure has a payload, then we'll read that now as
        // well.
        <span class="cov0" title="0">switch f := failure.(type) </span>{
        case Serializable:<span class="cov0" title="0">
                if err := f.Decode(r, pver); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unable to decode error "+
                                "update (type=%T): %v", failure, err)
                }</span>
        }

        <span class="cov0" title="0">return failure, nil</span>
}

// EncodeFailure encodes, including the necessary onion failure header
// information.
func EncodeFailure(w *bytes.Buffer, failure FailureMessage, pver uint32) error <span class="cov0" title="0">{
        var failureMessageBuffer bytes.Buffer

        err := EncodeFailureMessage(&amp;failureMessageBuffer, failure, pver)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // The combined size of this message must be below the max allowed
        // failure message length.
        <span class="cov0" title="0">failureMessage := failureMessageBuffer.Bytes()
        if len(failureMessage) &gt; FailureMessageLength </span><span class="cov0" title="0">{
                return fmt.Errorf("failure message exceed max "+
                        "available size: %v", len(failureMessage))
        }</span>

        // Finally, we'll add some padding in order to ensure that all failure
        // messages are fixed size.
        <span class="cov0" title="0">pad := make([]byte, FailureMessageLength-len(failureMessage))

        if err := WriteUint16(w, uint16(len(failureMessage))); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteBytes(w, failureMessage); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := WriteUint16(w, uint16(len(pad))); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return WriteBytes(w, pad)</span>
}

// EncodeFailureMessage encodes just the failure message without adding a length
// and padding the message for the onion protocol.
func EncodeFailureMessage(w *bytes.Buffer,
        failure FailureMessage, pver uint32) error <span class="cov0" title="0">{

        // First, we'll write out the error code itself into the failure
        // buffer.
        var codeBytes [2]byte
        code := uint16(failure.Code())
        binary.BigEndian.PutUint16(codeBytes[:], code)
        _, err := w.Write(codeBytes[:])
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Next, some message have an additional message payload, if this is
        // one of those types, then we'll also encode the error payload as
        // well.
        <span class="cov0" title="0">switch failure := failure.(type) </span>{
        case Serializable:<span class="cov0" title="0">
                if err := failure.Encode(w, pver); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// makeEmptyOnionError creates a new empty onion error  of the proper concrete
// type based on the passed failure code.
func makeEmptyOnionError(code FailCode) (FailureMessage, error) <span class="cov0" title="0">{
        switch code </span>{
        case CodeInvalidRealm:<span class="cov0" title="0">
                return &amp;FailInvalidRealm{}, nil</span>

        case CodeTemporaryNodeFailure:<span class="cov0" title="0">
                return &amp;FailTemporaryNodeFailure{}, nil</span>

        case CodePermanentNodeFailure:<span class="cov0" title="0">
                return &amp;FailPermanentNodeFailure{}, nil</span>

        case CodeRequiredNodeFeatureMissing:<span class="cov0" title="0">
                return &amp;FailRequiredNodeFeatureMissing{}, nil</span>

        case CodePermanentChannelFailure:<span class="cov0" title="0">
                return &amp;FailPermanentChannelFailure{}, nil</span>

        case CodeRequiredChannelFeatureMissing:<span class="cov0" title="0">
                return &amp;FailRequiredChannelFeatureMissing{}, nil</span>

        case CodeUnknownNextPeer:<span class="cov0" title="0">
                return &amp;FailUnknownNextPeer{}, nil</span>

        case CodeIncorrectOrUnknownPaymentDetails:<span class="cov0" title="0">
                return &amp;FailIncorrectDetails{}, nil</span>

        case CodeIncorrectPaymentAmount:<span class="cov0" title="0">
                return &amp;FailIncorrectPaymentAmount{}, nil</span>

        case CodeFinalExpiryTooSoon:<span class="cov0" title="0">
                return &amp;FailFinalExpiryTooSoon{}, nil</span>

        case CodeInvalidOnionVersion:<span class="cov0" title="0">
                return &amp;FailInvalidOnionVersion{}, nil</span>

        case CodeInvalidOnionHmac:<span class="cov0" title="0">
                return &amp;FailInvalidOnionHmac{}, nil</span>

        case CodeInvalidOnionKey:<span class="cov0" title="0">
                return &amp;FailInvalidOnionKey{}, nil</span>

        case CodeTemporaryChannelFailure:<span class="cov0" title="0">
                return &amp;FailTemporaryChannelFailure{}, nil</span>

        case CodeAmountBelowMinimum:<span class="cov0" title="0">
                return &amp;FailAmountBelowMinimum{}, nil</span>

        case CodeFeeInsufficient:<span class="cov0" title="0">
                return &amp;FailFeeInsufficient{}, nil</span>

        case CodeIncorrectCltvExpiry:<span class="cov0" title="0">
                return &amp;FailIncorrectCltvExpiry{}, nil</span>

        case CodeExpiryTooSoon:<span class="cov0" title="0">
                return &amp;FailExpiryTooSoon{}, nil</span>

        case CodeChannelDisabled:<span class="cov0" title="0">
                return &amp;FailChannelDisabled{}, nil</span>

        case CodeFinalIncorrectCltvExpiry:<span class="cov0" title="0">
                return &amp;FailFinalIncorrectCltvExpiry{}, nil</span>

        case CodeFinalIncorrectHtlcAmount:<span class="cov0" title="0">
                return &amp;FailFinalIncorrectHtlcAmount{}, nil</span>

        case CodeExpiryTooFar:<span class="cov0" title="0">
                return &amp;FailExpiryTooFar{}, nil</span>

        case CodeInvalidOnionPayload:<span class="cov0" title="0">
                return &amp;InvalidOnionPayload{}, nil</span>

        case CodeMPPTimeout:<span class="cov0" title="0">
                return &amp;FailMPPTimeout{}, nil</span>

        case CodeInvalidBlinding:<span class="cov0" title="0">
                return &amp;FailInvalidBlinding{}, nil</span>

        default:<span class="cov0" title="0">
                return nil, errors.Errorf("unknown error code: %v", code)</span>
        }
}

// writeOnionErrorChanUpdate writes out a ChannelUpdate using the onion error
// format. The format is that we first write out the true serialized length of
// the channel update, followed by the serialized channel update itself.
func writeOnionErrorChanUpdate(w *bytes.Buffer, chanUpdate *ChannelUpdate1,
        pver uint32) error <span class="cov0" title="0">{

        // First, we encode the channel update in a temporary buffer in order
        // to get the exact serialized size.
        var b bytes.Buffer
        updateLen, err := WriteMessage(&amp;b, chanUpdate, pver)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Now that we know the size, we can write the length out in the main
        // writer.
        <span class="cov0" title="0">if err := WriteUint16(w, uint16(updateLen)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // With the length written, we'll then write out the serialized channel
        // update.
        <span class="cov0" title="0">if _, err := w.Write(b.Bytes()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file86" style="display: none">package lnwire

import (
        "encoding/hex"
        "net"
)

// OpaqueAddrs is used to store the address bytes for address types that are
// unknown to us.
type OpaqueAddrs struct {
        Payload []byte
}

// A compile-time assertion to ensure that OpaqueAddrs meets the net.Addr
// interface.
var _ net.Addr = (*OpaqueAddrs)(nil)

// String returns a human-readable string describing the target OpaqueAddrs.
// Since this is an unknown address (and could even be multiple addresses), we
// just return the hex string of the payload.
//
// This part of the net.Addr interface.
func (o *OpaqueAddrs) String() string <span class="cov0" title="0">{
        return hex.EncodeToString(o.Payload)
}</span>

// Network returns the name of the network this address is bound to. Since this
// is an unknown address, we don't know the network and so just return a string
// indicating this.
//
// This part of the net.Addr interface.
func (o *OpaqueAddrs) Network() string <span class="cov0" title="0">{
        return "unknown network for unrecognized address type"
}</span>
</pre>
		
		<pre class="file" id="file87" style="display: none">package lnwire

import (
        "bytes"
        "io"

        "github.com/btcsuite/btcd/btcec/v2"
        "github.com/btcsuite/btcd/btcutil"
        "github.com/btcsuite/btcd/chaincfg/chainhash"
        "github.com/lightningnetwork/lnd/tlv"
)

// FundingFlag represents the possible bit mask values for the ChannelFlags
// field within the OpenChannel struct.
type FundingFlag uint8

const (
        // FFAnnounceChannel is a FundingFlag that when set, indicates the
        // initiator of a funding flow wishes to announce the channel to the
        // greater network.
        FFAnnounceChannel FundingFlag = 1 &lt;&lt; iota
)

// OpenChannel is the message Alice sends to Bob if we should like to create a
// channel with Bob where she's the sole provider of funds to the channel.
// Single funder channels simplify the initial funding workflow, are supported
// by nodes backed by SPV Bitcoin clients, and have a simpler security models
// than dual funded channels.
type OpenChannel struct {
        // ChainHash is the target chain that the initiator wishes to open a
        // channel within.
        ChainHash chainhash.Hash

        // PendingChannelID serves to uniquely identify the future channel
        // created by the initiated single funder workflow.
        PendingChannelID [32]byte

        // FundingAmount is the amount of satoshis that the initiator of the
        // channel wishes to use as the total capacity of the channel. The
        // initial balance of the funding will be this value minus the push
        // amount (if set).
        FundingAmount btcutil.Amount

        // PushAmount is the value that the initiating party wishes to "push"
        // to the responding as part of the first commitment state. If the
        // responder accepts, then this will be their initial balance.
        PushAmount MilliSatoshi

        // DustLimit is the specific dust limit the sender of this message
        // would like enforced on their version of the commitment transaction.
        // Any output below this value will be "trimmed" from the commitment
        // transaction, with the amount of the HTLC going to dust.
        DustLimit btcutil.Amount

        // MaxValueInFlight represents the maximum amount of coins that can be
        // pending within the channel at any given time. If the amount of funds
        // in limbo exceeds this amount, then the channel will be failed.
        MaxValueInFlight MilliSatoshi

        // ChannelReserve is the amount of BTC that the receiving party MUST
        // maintain a balance above at all times. This is a safety mechanism to
        // ensure that both sides always have skin in the game during the
        // channel's lifetime.
        ChannelReserve btcutil.Amount

        // HtlcMinimum is the smallest HTLC that the sender of this message
        // will accept.
        HtlcMinimum MilliSatoshi

        // FeePerKiloWeight is the initial fee rate that the initiator suggests
        // for both commitment transaction. This value is expressed in sat per
        // kilo-weight.
        //
        // TODO(halseth): make SatPerKWeight when fee estimation is in own
        // package. Currently this will cause an import cycle.
        FeePerKiloWeight uint32

        // CsvDelay is the number of blocks to use for the relative time lock
        // in the pay-to-self output of both commitment transactions.
        CsvDelay uint16

        // MaxAcceptedHTLCs is the total number of incoming HTLC's that the
        // sender of this channel will accept.
        MaxAcceptedHTLCs uint16

        // FundingKey is the key that should be used on behalf of the sender
        // within the 2-of-2 multi-sig output that it contained within the
        // funding transaction.
        FundingKey *btcec.PublicKey

        // RevocationPoint is the base revocation point for the sending party.
        // Any commitment transaction belonging to the receiver of this message
        // should use this key and their per-commitment point to derive the
        // revocation key for the commitment transaction.
        RevocationPoint *btcec.PublicKey

        // PaymentPoint is the base payment point for the sending party. This
        // key should be combined with the per commitment point for a
        // particular commitment state in order to create the key that should
        // be used in any output that pays directly to the sending party, and
        // also within the HTLC covenant transactions.
        PaymentPoint *btcec.PublicKey

        // DelayedPaymentPoint is the delay point for the sending party. This
        // key should be combined with the per commitment point to derive the
        // keys that are used in outputs of the sender's commitment transaction
        // where they claim funds.
        DelayedPaymentPoint *btcec.PublicKey

        // HtlcPoint is the base point used to derive the set of keys for this
        // party that will be used within the HTLC public key scripts. This
        // value is combined with the receiver's revocation base point in order
        // to derive the keys that are used within HTLC scripts.
        HtlcPoint *btcec.PublicKey

        // FirstCommitmentPoint is the first commitment point for the sending
        // party. This value should be combined with the receiver's revocation
        // base point in order to derive the revocation keys that are placed
        // within the commitment transaction of the sender.
        FirstCommitmentPoint *btcec.PublicKey

        // ChannelFlags is a bit-field which allows the initiator of the
        // channel to specify further behavior surrounding the channel.
        // Currently, the least significant bit of this bit field indicates the
        // initiator of the channel wishes to advertise this channel publicly.
        ChannelFlags FundingFlag

        // UpfrontShutdownScript is the script to which the channel funds should
        // be paid when mutually closing the channel. This field is optional, and
        // and has a length prefix, so a zero will be written if it is not set
        // and its length followed by the script will be written if it is set.
        UpfrontShutdownScript DeliveryAddress

        // ChannelType is the explicit channel type the initiator wishes to
        // open.
        ChannelType *ChannelType

        // LeaseExpiry represents the absolute expiration height of a channel
        // lease. This is a custom TLV record that will only apply when a leased
        // channel is being opened using the script enforced lease commitment
        // type.
        LeaseExpiry *LeaseExpiry

        // LocalNonce is an optional field that transmits the
        // local/verification nonce for a party. This nonce will be used to
        // verify the very first commitment transaction signature.  This will
        // only be populated if the simple taproot channels type was
        // negotiated.
        LocalNonce OptMusig2NonceTLV

        // ExtraData is the set of data that was appended to this message to
        // fill out the full maximum transport message size. These fields can
        // be used to specify optional data such as custom TLV fields.
        //
        // NOTE: Since the upfront shutdown script MUST be present (though can
        // be zero-length) if any TLV data is available, the script will be
        // extracted and removed from this blob when decoding. ExtraData will
        // contain all TLV records _except_ the DeliveryAddress record in that
        // case.
        ExtraData ExtraOpaqueData
}

// A compile time check to ensure OpenChannel implements the lnwire.Message
// interface.
var _ Message = (*OpenChannel)(nil)

// A compile time check to ensure OpenChannel implements the
// lnwire.SizeableMessage interface.
var _ SizeableMessage = (*OpenChannel)(nil)

// Encode serializes the target OpenChannel into the passed io.Writer
// implementation. Serialization will observe the rules defined by the passed
// protocol version.
func (o *OpenChannel) Encode(w *bytes.Buffer, pver uint32) error <span class="cov0" title="0">{
        recordProducers := []tlv.RecordProducer{&amp;o.UpfrontShutdownScript}
        if o.ChannelType != nil </span><span class="cov0" title="0">{
                recordProducers = append(recordProducers, o.ChannelType)
        }</span>
        <span class="cov0" title="0">if o.LeaseExpiry != nil </span><span class="cov0" title="0">{
                recordProducers = append(recordProducers, o.LeaseExpiry)
        }</span>
        <span class="cov0" title="0">o.LocalNonce.WhenSome(func(localNonce Musig2NonceTLV) </span><span class="cov0" title="0">{
                recordProducers = append(recordProducers, &amp;localNonce)
        }</span>)
        <span class="cov0" title="0">err := EncodeMessageExtraData(&amp;o.ExtraData, recordProducers...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteBytes(w, o.ChainHash[:]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteBytes(w, o.PendingChannelID[:]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteSatoshi(w, o.FundingAmount); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteMilliSatoshi(w, o.PushAmount); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteSatoshi(w, o.DustLimit); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteMilliSatoshi(w, o.MaxValueInFlight); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteSatoshi(w, o.ChannelReserve); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteMilliSatoshi(w, o.HtlcMinimum); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteUint32(w, o.FeePerKiloWeight); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteUint16(w, o.CsvDelay); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteUint16(w, o.MaxAcceptedHTLCs); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WritePublicKey(w, o.FundingKey); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WritePublicKey(w, o.RevocationPoint); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WritePublicKey(w, o.PaymentPoint); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WritePublicKey(w, o.DelayedPaymentPoint); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WritePublicKey(w, o.HtlcPoint); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WritePublicKey(w, o.FirstCommitmentPoint); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteFundingFlag(w, o.ChannelFlags); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return WriteBytes(w, o.ExtraData)</span>
}

// Decode deserializes the serialized OpenChannel stored in the passed
// io.Reader into the target OpenChannel using the deserialization rules
// defined by the passed protocol version.
//
// This is part of the lnwire.Message interface.
func (o *OpenChannel) Decode(r io.Reader, pver uint32) error <span class="cov0" title="0">{
        // Read all the mandatory fields in the open message.
        err := ReadElements(r,
                o.ChainHash[:],
                o.PendingChannelID[:],
                &amp;o.FundingAmount,
                &amp;o.PushAmount,
                &amp;o.DustLimit,
                &amp;o.MaxValueInFlight,
                &amp;o.ChannelReserve,
                &amp;o.HtlcMinimum,
                &amp;o.FeePerKiloWeight,
                &amp;o.CsvDelay,
                &amp;o.MaxAcceptedHTLCs,
                &amp;o.FundingKey,
                &amp;o.RevocationPoint,
                &amp;o.PaymentPoint,
                &amp;o.DelayedPaymentPoint,
                &amp;o.HtlcPoint,
                &amp;o.FirstCommitmentPoint,
                &amp;o.ChannelFlags,
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // For backwards compatibility, the optional extra data blob for
        // OpenChannel must contain an entry for the upfront shutdown script.
        // We'll read it out and attempt to parse it.
        <span class="cov0" title="0">var tlvRecords ExtraOpaqueData
        if err := ReadElements(r, &amp;tlvRecords); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Next we'll parse out the set of known records, keeping the raw tlv
        // bytes untouched to ensure we don't drop any bytes erroneously.
        <span class="cov0" title="0">var (
                chanType    ChannelType
                leaseExpiry LeaseExpiry
                localNonce  = o.LocalNonce.Zero()
        )
        typeMap, err := tlvRecords.ExtractRecords(
                &amp;o.UpfrontShutdownScript, &amp;chanType, &amp;leaseExpiry,
                &amp;localNonce,
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Set the corresponding TLV types if they were included in the stream.
        <span class="cov0" title="0">if val, ok := typeMap[ChannelTypeRecordType]; ok &amp;&amp; val == nil </span><span class="cov0" title="0">{
                o.ChannelType = &amp;chanType
        }</span>
        <span class="cov0" title="0">if val, ok := typeMap[LeaseExpiryRecordType]; ok &amp;&amp; val == nil </span><span class="cov0" title="0">{
                o.LeaseExpiry = &amp;leaseExpiry
        }</span>
        <span class="cov0" title="0">if val, ok := typeMap[o.LocalNonce.TlvType()]; ok &amp;&amp; val == nil </span><span class="cov0" title="0">{
                o.LocalNonce = tlv.SomeRecordT(localNonce)
        }</span>

        <span class="cov0" title="0">o.ExtraData = tlvRecords

        return nil</span>
}

// MsgType returns the MessageType code which uniquely identifies this message
// as an OpenChannel on the wire.
//
// This is part of the lnwire.Message interface.
func (o *OpenChannel) MsgType() MessageType <span class="cov0" title="0">{
        return MsgOpenChannel
}</span>

// SerializedSize returns the serialized size of the message in bytes.
//
// This is part of the lnwire.SizeableMessage interface.
func (o *OpenChannel) SerializedSize() (uint32, error) <span class="cov0" title="0">{
        return MessageSerializedSize(o)
}</span>
</pre>
		
		<pre class="file" id="file88" style="display: none">package lnwire

import (
        "io"

        "github.com/btcsuite/btcd/btcec/v2"
        "github.com/btcsuite/btcd/btcec/v2/schnorr/musig2"
        "github.com/lightningnetwork/lnd/tlv"
)

const (
        // PartialSigLen is the length of a musig2 partial signature.
        PartialSigLen = 32
)

type (
        // PartialSigType is the type of the tlv record for a musig2
        // partial signature. This is an _even_ type, which means it's required
        // if included.
        PartialSigType = tlv.TlvType6

        // PartialSigTLV is a tlv record for a musig2 partial signature.
        PartialSigTLV = tlv.RecordT[PartialSigType, PartialSig]

        // OptPartialSigTLV is a tlv record for a musig2 partial signature.
        // This is an optional record type.
        OptPartialSigTLV = tlv.OptionalRecordT[PartialSigType, PartialSig]
)

// PartialSig is the base partial sig type. This only encodes the 32-byte
// partial signature. This is used for the co-op close flow, as both sides have
// already exchanged nonces, so they can send just the partial signature.
type PartialSig struct {
        // Sig is the 32-byte musig2 partial signature.
        Sig btcec.ModNScalar
}

// NewPartialSig creates a new partial sig.
func NewPartialSig(sig btcec.ModNScalar) PartialSig <span class="cov0" title="0">{
        return PartialSig{
                Sig: sig,
        }
}</span>

// Record returns the tlv record for the partial sig.
func (p *PartialSig) Record() tlv.Record <span class="cov0" title="0">{
        return tlv.MakeStaticRecord(
                (PartialSigType)(nil).TypeVal(), p, PartialSigLen,
                partialSigTypeEncoder, partialSigTypeDecoder,
        )
}</span>

// partialSigTypeEncoder encodes a 32-byte musig2 partial signature as a TLV
// value.
func partialSigTypeEncoder(w io.Writer, val interface{}, buf *[8]byte) error <span class="cov0" title="0">{
        if v, ok := val.(*PartialSig); ok </span><span class="cov0" title="0">{
                sigBytes := v.Sig.Bytes()

                return tlv.EBytes32(w, &amp;sigBytes, buf)
        }</span>

        <span class="cov0" title="0">return tlv.NewTypeForEncodingErr(val, "lnwire.PartialSig")</span>
}

// Encode writes the encoded version of this message to the passed io.Writer.
func (p *PartialSig) Encode(w io.Writer) error <span class="cov0" title="0">{
        return partialSigTypeEncoder(w, p, nil)
}</span>

// partialSigTypeDecoder decodes a 32-byte musig2 extended partial signature.
func partialSigTypeDecoder(r io.Reader, val interface{}, buf *[8]byte,
        l uint64) error <span class="cov0" title="0">{

        if v, ok := val.(*PartialSig); ok &amp;&amp; l == PartialSigLen </span><span class="cov0" title="0">{
                var sBytes [32]byte
                err := tlv.DBytes32(r, &amp;sBytes, buf, PartialSigLen)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">var s btcec.ModNScalar
                s.SetBytes(&amp;sBytes)

                *v = PartialSig{
                        Sig: s,
                }

                return nil</span>
        }

        <span class="cov0" title="0">return tlv.NewTypeForDecodingErr(val, "lnwire.PartialSig", l,
                PartialSigLen)</span>
}

// Decode reads the encoded version of this message from the passed io.Reader.
func (p *PartialSig) Decode(r io.Reader) error <span class="cov0" title="0">{
        return partialSigTypeDecoder(r, p, nil, PartialSigLen)
}</span>

// SomePartialSig is a helper function that returns an otional PartialSig.
func SomePartialSig(sig PartialSig) OptPartialSigTLV <span class="cov0" title="0">{
        return tlv.SomeRecordT(tlv.NewRecordT[PartialSigType, PartialSig](sig))
}</span>

const (
        // PartialSigWithNonceLen is the length of a serialized
        // PartialSigWithNonce. The sig is encoded as the 32 byte S value
        // followed by the 66 nonce value.
        PartialSigWithNonceLen = 98
)

type (
        // PartialSigWithNonceType is the type of the tlv record for a musig2
        // partial signature with nonce. This is an _even_ type, which means
        // it's required if included.
        PartialSigWithNonceType = tlv.TlvType2

        // PartialSigWithNonceTLV is a tlv record for a musig2 partial
        // signature.
        PartialSigWithNonceTLV = tlv.RecordT[
                PartialSigWithNonceType, PartialSigWithNonce,
        ]

        // OptPartialSigWithNonceTLV is a tlv record for a musig2 partial
        // signature.  This is an optional record type.
        OptPartialSigWithNonceTLV = tlv.OptionalRecordT[
                PartialSigWithNonceType, PartialSigWithNonce,
        ]
)

// PartialSigWithNonce is a partial signature with the nonce that was used to
// generate the signature. This is used for funding as well as the commitment
// transaction update dance. By sending the nonce only with the signature, we
// enable the sender to generate their nonce just before they create their
// signature. Signers can use this trait to mix in additional contextual data
// such as the commitment txn itself into their nonce generation function.
//
// The final signature is 98 bytes: 32 bytes for the S value, and 66 bytes for
// the public nonce (two compressed points).
type PartialSigWithNonce struct {
        PartialSig

        // Nonce is the 66-byte musig2 nonce.
        Nonce Musig2Nonce
}

// NewPartialSigWithNonce creates a new partial sig with nonce.
func NewPartialSigWithNonce(nonce [musig2.PubNonceSize]byte,
        sig btcec.ModNScalar) *PartialSigWithNonce <span class="cov0" title="0">{

        return &amp;PartialSigWithNonce{
                Nonce:      nonce,
                PartialSig: NewPartialSig(sig),
        }
}</span>

// Record returns the tlv record for the partial sig with nonce.
func (p *PartialSigWithNonce) Record() tlv.Record <span class="cov0" title="0">{
        return tlv.MakeStaticRecord(
                (PartialSigWithNonceType)(nil).TypeVal(), p,
                PartialSigWithNonceLen, partialSigWithNonceTypeEncoder,
                partialSigWithNonceTypeDecoder,
        )
}</span>

// partialSigWithNonceTypeEncoder encodes 98-byte musig2 extended partial
// signature as: s {32} || nonce {66}.
func partialSigWithNonceTypeEncoder(w io.Writer, val interface{},
        _ *[8]byte) error <span class="cov0" title="0">{

        if v, ok := val.(*PartialSigWithNonce); ok </span><span class="cov0" title="0">{
                sigBytes := v.Sig.Bytes()
                if _, err := w.Write(sigBytes[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if _, err := w.Write(v.Nonce[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">return tlv.NewTypeForEncodingErr(val, "lnwire.PartialSigWithNonce")</span>
}

// Encode writes the encoded version of this message to the passed io.Writer.
func (p *PartialSigWithNonce) Encode(w io.Writer) error <span class="cov0" title="0">{
        return partialSigWithNonceTypeEncoder(w, p, nil)
}</span>

// partialSigWithNonceTypeDecoder decodes a 98-byte musig2 extended partial
// signature.
func partialSigWithNonceTypeDecoder(r io.Reader, val interface{}, buf *[8]byte,
        l uint64) error <span class="cov0" title="0">{

        if v, ok := val.(*PartialSigWithNonce); ok &amp;&amp;
                l == PartialSigWithNonceLen </span><span class="cov0" title="0">{

                var sBytes [32]byte
                err := tlv.DBytes32(r, &amp;sBytes, buf, PartialSigLen)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">var s btcec.ModNScalar
                s.SetBytes(&amp;sBytes)

                var nonce [66]byte
                if _, err := io.ReadFull(r, nonce[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">*v = PartialSigWithNonce{
                        PartialSig: NewPartialSig(s),
                        Nonce:      nonce,
                }

                return nil</span>
        }

        <span class="cov0" title="0">return tlv.NewTypeForDecodingErr(val, "lnwire.PartialSigWithNonce", l,
                PartialSigWithNonceLen)</span>
}

// Decode reads the encoded version of this message from the passed io.Reader.
func (p *PartialSigWithNonce) Decode(r io.Reader) error <span class="cov0" title="0">{
        return partialSigWithNonceTypeDecoder(
                r, p, nil, PartialSigWithNonceLen,
        )
}</span>

// MaybePartialSigWithNonce is a helper function that returns an optional
// PartialSigWithNonceTLV.
func MaybePartialSigWithNonce(sig *PartialSigWithNonce,
) OptPartialSigWithNonceTLV <span class="cov0" title="0">{

        if sig == nil </span><span class="cov0" title="0">{
                var none OptPartialSigWithNonceTLV
                return none
        }</span>

        <span class="cov0" title="0">return tlv.SomeRecordT(
                tlv.NewRecordT[PartialSigWithNonceType, PartialSigWithNonce](
                        *sig,
                ),
        )</span>
}
</pre>
		
		<pre class="file" id="file89" style="display: none">package lnwire

import (
        "bytes"
        "io"
)

// PingPayload is a set of opaque bytes used to pad out a ping message.
type PingPayload []byte

// Ping defines a message which is sent by peers periodically to determine if
// the connection is still valid. Each ping message carries the number of bytes
// to pad the pong response with, and also a number of bytes to be ignored at
// the end of the ping message (which is padding).
type Ping struct {
        // NumPongBytes is the number of bytes the pong response to this
        // message should carry.
        NumPongBytes uint16

        // PaddingBytes is a set of opaque bytes used to pad out this ping
        // message. Using this field in conjunction to the one above, it's
        // possible for node to generate fake cover traffic.
        PaddingBytes PingPayload
}

// NewPing returns a new Ping message.
func NewPing(numBytes uint16) *Ping <span class="cov0" title="0">{
        return &amp;Ping{
                NumPongBytes: numBytes,
        }
}</span>

// A compile time check to ensure Ping implements the lnwire.Message interface.
var _ Message = (*Ping)(nil)

// A compile time check to ensure Ping implements the lnwire.SizeableMessage
// interface.
var _ SizeableMessage = (*Ping)(nil)

// Decode deserializes a serialized Ping message stored in the passed io.Reader
// observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (p *Ping) Decode(r io.Reader, pver uint32) error <span class="cov0" title="0">{
        err := ReadElements(r, &amp;p.NumPongBytes, &amp;p.PaddingBytes)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if p.NumPongBytes &gt; MaxPongBytes </span><span class="cov0" title="0">{
                return ErrMaxPongBytesExceeded
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Encode serializes the target Ping into the passed io.Writer observing the
// protocol version specified.
//
// This is part of the lnwire.Message interface.
func (p *Ping) Encode(w *bytes.Buffer, pver uint32) error <span class="cov0" title="0">{
        if err := WriteUint16(w, p.NumPongBytes); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return WritePingPayload(w, p.PaddingBytes)</span>
}

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (p *Ping) MsgType() MessageType <span class="cov0" title="0">{
        return MsgPing
}</span>

// SerializedSize returns the serialized size of the message in bytes.
//
// This is part of the lnwire.SizeableMessage interface.
func (p *Ping) SerializedSize() (uint32, error) <span class="cov0" title="0">{
        return MessageSerializedSize(p)
}</span>
</pre>
		
		<pre class="file" id="file90" style="display: none">package lnwire

import (
        "bytes"
        "fmt"
        "io"
)

// MaxPongBytes is the maximum number of extra bytes a pong can be requested to
// send. The type of the message (19) takes 2 bytes, the length field takes up
// 2 bytes, leaving 65531 bytes.
const MaxPongBytes = 65531

// ErrMaxPongBytesExceeded indicates that the NumPongBytes field from the ping
// message has exceeded MaxPongBytes.
var ErrMaxPongBytesExceeded = fmt.Errorf("pong bytes exceeded")

// PongPayload is a set of opaque bytes sent in response to a ping message.
type PongPayload []byte

// Pong defines a message which is the direct response to a received Ping
// message. A Pong reply indicates that a connection is still active. The Pong
// reply to a Ping message should contain the nonce carried in the original
// Pong message.
type Pong struct {
        // PongBytes is a set of opaque bytes that corresponds to the
        // NumPongBytes defined in the ping message that this pong is
        // replying to.
        PongBytes PongPayload
}

// NewPong returns a new Pong message.
func NewPong(pongBytes []byte) *Pong <span class="cov0" title="0">{
        return &amp;Pong{
                PongBytes: pongBytes,
        }
}</span>

// A compile time check to ensure Pong implements the lnwire.Message interface.
var _ Message = (*Pong)(nil)

// A compile time check to ensure Pong implements the lnwire.SizeableMessage
// interface.
var _ SizeableMessage = (*Pong)(nil)

// Decode deserializes a serialized Pong message stored in the passed io.Reader
// observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (p *Pong) Decode(r io.Reader, pver uint32) error <span class="cov0" title="0">{
        return ReadElements(r,
                &amp;p.PongBytes,
        )
}</span>

// Encode serializes the target Pong into the passed io.Writer observing the
// protocol version specified.
//
// This is part of the lnwire.Message interface.
func (p *Pong) Encode(w *bytes.Buffer, pver uint32) error <span class="cov0" title="0">{
        return WritePongPayload(w, p.PongBytes)
}</span>

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (p *Pong) MsgType() MessageType <span class="cov0" title="0">{
        return MsgPong
}</span>

// SerializedSize returns the serialized size of the message in bytes.
//
// This is part of the lnwire.SizeableMessage interface.
func (p *Pong) SerializedSize() (uint32, error) <span class="cov0" title="0">{
        return MessageSerializedSize(p)
}</span>
</pre>
		
		<pre class="file" id="file91" style="display: none">package lnwire

import (
        "bytes"
        "io"
        "math"

        "github.com/btcsuite/btcd/chaincfg/chainhash"
        "github.com/lightningnetwork/lnd/tlv"
)

// QueryChannelRange is a message sent by a node in order to query the
// receiving node of the set of open channel they know of with short channel
// ID's after the specified block height, capped at the number of blocks beyond
// that block height. This will be used by nodes upon initial connect to
// synchronize their views of the network.
type QueryChannelRange struct {
        // ChainHash denotes the target chain that we're trying to synchronize
        // channel graph state for.
        ChainHash chainhash.Hash

        // FirstBlockHeight is the first block in the query range. The
        // responder should send all new short channel IDs from this block
        // until this block plus the specified number of blocks.
        FirstBlockHeight uint32

        // NumBlocks is the number of blocks beyond the first block that short
        // channel ID's should be sent for.
        NumBlocks uint32

        // QueryOptions is an optional feature bit vector that can be used to
        // specify additional query options.
        QueryOptions *QueryOptions

        // ExtraData is the set of data that was appended to this message to
        // fill out the full maximum transport message size. These fields can
        // be used to specify optional data such as custom TLV fields.
        ExtraData ExtraOpaqueData
}

// NewQueryChannelRange creates a new empty QueryChannelRange message.
func NewQueryChannelRange() *QueryChannelRange <span class="cov0" title="0">{
        return &amp;QueryChannelRange{
                ExtraData: make([]byte, 0),
        }
}</span>

// A compile time check to ensure QueryChannelRange implements the
// lnwire.Message interface.
var _ Message = (*QueryChannelRange)(nil)

// A compile time check to ensure QueryChannelRange implements the
// lnwire.SizeableMessage interface.
var _ SizeableMessage = (*QueryChannelRange)(nil)

// Decode deserializes a serialized QueryChannelRange message stored in the
// passed io.Reader observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (q *QueryChannelRange) Decode(r io.Reader, _ uint32) error <span class="cov0" title="0">{
        err := ReadElements(
                r, q.ChainHash[:], &amp;q.FirstBlockHeight, &amp;q.NumBlocks,
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var tlvRecords ExtraOpaqueData
        if err := ReadElements(r, &amp;tlvRecords); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var queryOptions QueryOptions
        typeMap, err := tlvRecords.ExtractRecords(&amp;queryOptions)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Set the corresponding TLV types if they were included in the stream.
        <span class="cov0" title="0">if val, ok := typeMap[QueryOptionsRecordType]; ok &amp;&amp; val == nil </span><span class="cov0" title="0">{
                q.QueryOptions = &amp;queryOptions
        }</span>

        <span class="cov0" title="0">if len(tlvRecords) != 0 </span><span class="cov0" title="0">{
                q.ExtraData = tlvRecords
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Encode serializes the target QueryChannelRange into the passed io.Writer
// observing the protocol version specified.
//
// This is part of the lnwire.Message interface.
func (q *QueryChannelRange) Encode(w *bytes.Buffer, _ uint32) error <span class="cov0" title="0">{
        if err := WriteBytes(w, q.ChainHash[:]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteUint32(w, q.FirstBlockHeight); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteUint32(w, q.NumBlocks); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">recordProducers := make([]tlv.RecordProducer, 0, 1)
        if q.QueryOptions != nil </span><span class="cov0" title="0">{
                recordProducers = append(recordProducers, q.QueryOptions)
        }</span>
        <span class="cov0" title="0">err := EncodeMessageExtraData(&amp;q.ExtraData, recordProducers...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return WriteBytes(w, q.ExtraData)</span>
}

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (q *QueryChannelRange) MsgType() MessageType <span class="cov0" title="0">{
        return MsgQueryChannelRange
}</span>

// SerializedSize returns the serialized size of the message in bytes.
//
// This is part of the lnwire.SizeableMessage interface.
func (q *QueryChannelRange) SerializedSize() (uint32, error) <span class="cov0" title="0">{
        msgCpy := *q
        return MessageSerializedSize(&amp;msgCpy)
}</span>

// LastBlockHeight returns the last block height covered by the range of a
// QueryChannelRange message.
func (q *QueryChannelRange) LastBlockHeight() uint32 <span class="cov0" title="0">{
        // Handle overflows by casting to uint64.
        lastBlockHeight := uint64(q.FirstBlockHeight) + uint64(q.NumBlocks) - 1
        if lastBlockHeight &gt; math.MaxUint32 </span><span class="cov0" title="0">{
                return math.MaxUint32
        }</span>
        <span class="cov0" title="0">return uint32(lastBlockHeight)</span>
}

// WithTimestamps returns true if the query has asked for timestamps too.
func (q *QueryChannelRange) WithTimestamps() bool <span class="cov0" title="0">{
        if q.QueryOptions == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">queryOpts := RawFeatureVector(*q.QueryOptions)

        return queryOpts.IsSet(QueryOptionTimestampBit)</span>
}
</pre>
		
		<pre class="file" id="file92" style="display: none">package lnwire

import (
        "io"

        "github.com/lightningnetwork/lnd/tlv"
)

const (
        // QueryOptionsRecordType is the TLV number of the query_options TLV
        // record in the query_channel_range message.
        QueryOptionsRecordType tlv.Type = 1

        // QueryOptionTimestampBit is the bit position in the query_option
        // feature bit vector which is used to indicate that timestamps are
        // desired in the reply_channel_range response.
        QueryOptionTimestampBit = 0
)

// QueryOptions is the type used to represent the query_options feature bit
// vector in the query_channel_range message.
type QueryOptions RawFeatureVector

// NewTimestampQueryOption is a helper constructor used to construct a
// QueryOption with the timestamp bit set.
func NewTimestampQueryOption() *QueryOptions <span class="cov0" title="0">{
        opt := QueryOptions(*NewRawFeatureVector(
                QueryOptionTimestampBit,
        ))

        return &amp;opt
}</span>

// featureBitLen calculates and returns the size of the resulting feature bit
// vector.
func (c *QueryOptions) featureBitLen() uint64 <span class="cov0" title="0">{
        fv := RawFeatureVector(*c)

        return uint64(fv.SerializeSize())
}</span>

// Record constructs a tlv.Record from the QueryOptions to be used in the
// query_channel_range message.
func (c *QueryOptions) Record() tlv.Record <span class="cov0" title="0">{
        return tlv.MakeDynamicRecord(
                QueryOptionsRecordType, c, c.featureBitLen, queryOptionsEncoder,
                queryOptionsDecoder,
        )
}</span>

// queryOptionsEncoder encodes the QueryOptions and writes it to the provided
// writer.
func queryOptionsEncoder(w io.Writer, val interface{}, _ *[8]byte) error <span class="cov0" title="0">{
        if v, ok := val.(*QueryOptions); ok </span><span class="cov0" title="0">{
                // Encode the feature bits as a byte slice without its length
                // prepended, as that's already taken care of by the TLV record.
                fv := RawFeatureVector(*v)
                return fv.encode(w, fv.SerializeSize(), 8)
        }</span>

        <span class="cov0" title="0">return tlv.NewTypeForEncodingErr(val, "lnwire.QueryOptions")</span>
}

// queryOptionsDecoder attempts to read a QueryOptions from the given reader.
func queryOptionsDecoder(r io.Reader, val interface{}, _ *[8]byte,
        l uint64) error <span class="cov0" title="0">{

        if v, ok := val.(*QueryOptions); ok </span><span class="cov0" title="0">{
                fv := NewRawFeatureVector()
                if err := fv.decode(r, int(l), 8); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">*v = QueryOptions(*fv)

                return nil</span>
        }

        <span class="cov0" title="0">return tlv.NewTypeForEncodingErr(val, "lnwire.QueryOptions")</span>
}
</pre>
		
		<pre class="file" id="file93" style="display: none">package lnwire

import (
        "bytes"
        "compress/zlib"
        "fmt"
        "io"
        "sort"
        "sync"

        "github.com/btcsuite/btcd/chaincfg/chainhash"
)

const (
        // maxZlibBufSize is the max number of bytes that we'll accept from a
        // zlib decoding instance. We do this in order to limit the total
        // amount of memory allocated during a decoding instance.
        maxZlibBufSize = 67413630
)

// ErrUnsortedSIDs is returned when decoding a QueryShortChannelID request whose
// items were not sorted.
type ErrUnsortedSIDs struct {
        prevSID ShortChannelID
        curSID  ShortChannelID
}

// Error returns a human-readable description of the error.
func (e ErrUnsortedSIDs) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("current sid: %v isn't greater than last sid: %v",
                e.curSID, e.prevSID)
}</span>

// zlibDecodeMtx is a package level mutex that we'll use in order to ensure
// that we'll only attempt a single zlib decoding instance at a time. This
// allows us to also further bound our memory usage.
var zlibDecodeMtx sync.Mutex

// ErrUnknownShortChanIDEncoding is a parametrized error that indicates that we
// came across an unknown short channel ID encoding, and therefore were unable
// to continue parsing.
func ErrUnknownShortChanIDEncoding(encoding QueryEncoding) error <span class="cov0" title="0">{
        return fmt.Errorf("unknown short chan id encoding: %v", encoding)
}</span>

// QueryShortChanIDs is a message that allows the sender to query a set of
// channel announcement and channel update messages that correspond to the set
// of encoded short channel ID's. The encoding of the short channel ID's is
// detailed in the query message ensuring that the receiver knows how to
// properly decode each encode short channel ID which may be encoded using a
// compression format. The receiver should respond with a series of channel
// announcement and channel updates, finally sending a ReplyShortChanIDsEnd
// message.
type QueryShortChanIDs struct {
        // ChainHash denotes the target chain that we're querying for the
        // channel ID's of.
        ChainHash chainhash.Hash

        // EncodingType is a signal to the receiver of the message that
        // indicates exactly how the set of short channel ID's that follow have
        // been encoded.
        EncodingType QueryEncoding

        // ShortChanIDs is a slice of decoded short channel ID's.
        ShortChanIDs []ShortChannelID

        // ExtraData is the set of data that was appended to this message to
        // fill out the full maximum transport message size. These fields can
        // be used to specify optional data such as custom TLV fields.
        ExtraData ExtraOpaqueData

        // noSort indicates whether or not to sort the short channel ids before
        // writing them out.
        //
        // NOTE: This should only be used during testing.
        noSort bool
}

// NewQueryShortChanIDs creates a new QueryShortChanIDs message.
func NewQueryShortChanIDs(h chainhash.Hash, e QueryEncoding,
        s []ShortChannelID) *QueryShortChanIDs <span class="cov0" title="0">{

        return &amp;QueryShortChanIDs{
                ChainHash:    h,
                EncodingType: e,
                ShortChanIDs: s,
        }
}</span>

// A compile time check to ensure QueryShortChanIDs implements the
// lnwire.Message interface.
var _ Message = (*QueryShortChanIDs)(nil)

// A compile time check to ensure QueryShortChanIDs implements the
// lnwire.SizeableMessage interface.
var _ SizeableMessage = (*QueryShortChanIDs)(nil)

// Decode deserializes a serialized QueryShortChanIDs message stored in the
// passed io.Reader observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (q *QueryShortChanIDs) Decode(r io.Reader, pver uint32) error <span class="cov0" title="0">{
        err := ReadElements(r, q.ChainHash[:])
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">q.EncodingType, q.ShortChanIDs, err = decodeShortChanIDs(r)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return q.ExtraData.Decode(r)</span>
}

// decodeShortChanIDs decodes a set of short channel ID's that have been
// encoded. The first byte of the body details how the short chan ID's were
// encoded. We'll use this type to govern exactly how we go about encoding the
// set of short channel ID's.
func decodeShortChanIDs(r io.Reader) (QueryEncoding, []ShortChannelID, error) <span class="cov0" title="0">{
        // First, we'll attempt to read the number of bytes in the body of the
        // set of encoded short channel ID's.
        var numBytesResp uint16
        err := ReadElements(r, &amp;numBytesResp)
        if err != nil </span><span class="cov0" title="0">{
                return 0, nil, err
        }</span>

        <span class="cov0" title="0">if numBytesResp == 0 </span><span class="cov0" title="0">{
                return 0, nil, nil
        }</span>

        <span class="cov0" title="0">queryBody := make([]byte, numBytesResp)
        if _, err := io.ReadFull(r, queryBody); err != nil </span><span class="cov0" title="0">{
                return 0, nil, err
        }</span>

        // The first byte is the encoding type, so we'll extract that so we can
        // continue our parsing.
        <span class="cov0" title="0">encodingType := QueryEncoding(queryBody[0])

        // Before continuing, we'll snip off the first byte of the query body
        // as that was just the encoding type.
        queryBody = queryBody[1:]

        // Otherwise, depending on the encoding type, we'll decode the encode
        // short channel ID's in a different manner.
        switch encodingType </span>{

        // In this encoding, we'll simply read a sort array of encoded short
        // channel ID's from the buffer.
        case EncodingSortedPlain:<span class="cov0" title="0">
                // If after extracting the encoding type, the number of
                // remaining bytes is not a whole multiple of the size of an
                // encoded short channel ID (8 bytes), then we'll return a
                // parsing error.
                if len(queryBody)%8 != 0 </span><span class="cov0" title="0">{
                        return 0, nil, fmt.Errorf("whole number of short "+
                                "chan ID's cannot be encoded in len=%v",
                                len(queryBody))
                }</span>

                // As each short channel ID is encoded as 8 bytes, we can
                // compute the number of bytes encoded based on the size of the
                // query body.
                <span class="cov0" title="0">numShortChanIDs := len(queryBody) / 8
                if numShortChanIDs == 0 </span><span class="cov0" title="0">{
                        return encodingType, nil, nil
                }</span>

                // Finally, we'll read out the exact number of short channel
                // ID's to conclude our parsing.
                <span class="cov0" title="0">shortChanIDs := make([]ShortChannelID, numShortChanIDs)
                bodyReader := bytes.NewReader(queryBody)
                var lastChanID ShortChannelID
                for i := 0; i &lt; numShortChanIDs; i++ </span><span class="cov0" title="0">{
                        if err := ReadElements(bodyReader, &amp;shortChanIDs[i]); err != nil </span><span class="cov0" title="0">{
                                return 0, nil, fmt.Errorf("unable to parse "+
                                        "short chan ID: %v", err)
                        }</span>

                        // We'll ensure that this short chan ID is greater than
                        // the last one. This is a requirement within the
                        // encoding, and if violated can aide us in detecting
                        // malicious payloads. This can only be true starting
                        // at the second chanID.
                        <span class="cov0" title="0">cid := shortChanIDs[i]
                        if i &gt; 0 &amp;&amp; cid.ToUint64() &lt;= lastChanID.ToUint64() </span><span class="cov0" title="0">{
                                return 0, nil, ErrUnsortedSIDs{lastChanID, cid}
                        }</span>
                        <span class="cov0" title="0">lastChanID = cid</span>
                }

                <span class="cov0" title="0">return encodingType, shortChanIDs, nil</span>

        // In this encoding, we'll use zlib to decode the compressed payload.
        // However, we'll pay attention to ensure that we don't open our selves
        // up to a memory exhaustion attack.
        case EncodingSortedZlib:<span class="cov0" title="0">
                // We'll obtain an ultimately release the zlib decode mutex.
                // This guards us against allocating too much memory to decode
                // each instance from concurrent peers.
                zlibDecodeMtx.Lock()
                defer zlibDecodeMtx.Unlock()

                // At this point, if there's no body remaining, then only the encoding
                // type was specified, meaning that there're no further bytes to be
                // parsed.
                if len(queryBody) == 0 </span><span class="cov0" title="0">{
                        return encodingType, nil, nil
                }</span>

                // Before we start to decode, we'll create a limit reader over
                // the current reader. This will ensure that we can control how
                // much memory we're allocating during the decoding process.
                <span class="cov0" title="0">limitedDecompressor, err := zlib.NewReader(&amp;io.LimitedReader{
                        R: bytes.NewReader(queryBody),
                        N: maxZlibBufSize,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return 0, nil, fmt.Errorf("unable to create zlib "+
                                "reader: %w", err)
                }</span>

                <span class="cov0" title="0">var (
                        shortChanIDs []ShortChannelID
                        lastChanID   ShortChannelID
                        i            int
                )
                for </span><span class="cov0" title="0">{
                        // We'll now attempt to read the next short channel ID
                        // encoded in the payload.
                        var cid ShortChannelID
                        err := ReadElements(limitedDecompressor, &amp;cid)

                        switch </span>{
                        // If we get an EOF error, then that either means we've
                        // read all that's contained in the buffer, or have hit
                        // our limit on the number of bytes we'll read. In
                        // either case, we'll return what we have so far.
                        case err == io.ErrUnexpectedEOF || err == io.EOF:<span class="cov0" title="0">
                                return encodingType, shortChanIDs, nil</span>

                        // Otherwise, we hit some other sort of error, possibly
                        // an invalid payload, so we'll exit early with the
                        // error.
                        case err != nil:<span class="cov0" title="0">
                                return 0, nil, fmt.Errorf("unable to "+
                                        "deflate next short chan "+
                                        "ID: %v", err)</span>
                        }

                        // We successfully read the next ID, so we'll collect
                        // that in the set of final ID's to return.
                        <span class="cov0" title="0">shortChanIDs = append(shortChanIDs, cid)

                        // Finally, we'll ensure that this short chan ID is
                        // greater than the last one. This is a requirement
                        // within the encoding, and if violated can aide us in
                        // detecting malicious payloads. This can only be true
                        // starting at the second chanID.
                        if i &gt; 0 &amp;&amp; cid.ToUint64() &lt;= lastChanID.ToUint64() </span><span class="cov0" title="0">{
                                return 0, nil, ErrUnsortedSIDs{lastChanID, cid}
                        }</span>

                        <span class="cov0" title="0">lastChanID = cid
                        i++</span>
                }

        default:<span class="cov0" title="0">
                // If we've been sent an encoding type that we don't know of,
                // then we'll return a parsing error as we can't continue if
                // we're unable to encode them.
                return 0, nil, ErrUnknownShortChanIDEncoding(encodingType)</span>
        }
}

// Encode serializes the target QueryShortChanIDs into the passed io.Writer
// observing the protocol version specified.
//
// This is part of the lnwire.Message interface.
func (q *QueryShortChanIDs) Encode(w *bytes.Buffer, pver uint32) error <span class="cov0" title="0">{
        // First, we'll write out the chain hash.
        if err := WriteBytes(w, q.ChainHash[:]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // For both of the current encoding types, the channel ID's are to be
        // sorted in place, so we'll do that now. The sorting is applied unless
        // we were specifically requested not to for testing purposes.
        <span class="cov0" title="0">if !q.noSort </span><span class="cov0" title="0">{
                sort.Slice(q.ShortChanIDs, func(i, j int) bool </span><span class="cov0" title="0">{
                        return q.ShortChanIDs[i].ToUint64() &lt;
                                q.ShortChanIDs[j].ToUint64()
                }</span>)
        }

        // Base on our encoding type, we'll write out the set of short channel
        // ID's.
        <span class="cov0" title="0">err := encodeShortChanIDs(w, q.EncodingType, q.ShortChanIDs)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return WriteBytes(w, q.ExtraData)</span>
}

// encodeShortChanIDs encodes the passed short channel ID's into the passed
// io.Writer, respecting the specified encoding type.
func encodeShortChanIDs(w *bytes.Buffer, encodingType QueryEncoding,
        shortChanIDs []ShortChannelID) error <span class="cov0" title="0">{

        switch encodingType </span>{

        // In this encoding, we'll simply write a sorted array of encoded short
        // channel ID's from the buffer.
        case EncodingSortedPlain:<span class="cov0" title="0">
                // First, we'll write out the number of bytes of the query
                // body. We add 1 as the response will have the encoding type
                // prepended to it.
                numBytesBody := uint16(len(shortChanIDs)*8) + 1
                if err := WriteUint16(w, numBytesBody); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // We'll then write out the encoding that that follows the
                // actual encoded short channel ID's.
                <span class="cov0" title="0">err := WriteQueryEncoding(w, encodingType)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Now that we know they're sorted, we can write out each short
                // channel ID to the buffer.
                <span class="cov0" title="0">for _, chanID := range shortChanIDs </span><span class="cov0" title="0">{
                        if err := WriteShortChannelID(w, chanID); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("unable to write short chan "+
                                        "ID: %v", err)
                        }</span>
                }

                <span class="cov0" title="0">return nil</span>

        // For this encoding we'll first write out a serialized version of all
        // the channel ID's into a buffer, then zlib encode that. The final
        // payload is what we'll write out to the passed io.Writer.
        //
        // TODO(roasbeef): assumes the caller knows the proper chunk size to
        // pass to avoid bin-packing here
        case EncodingSortedZlib:<span class="cov0" title="0">
                // If we don't have anything at all to write, then we'll write
                // an empty payload so we don't include things like the zlib
                // header when the remote party is expecting no actual short
                // channel IDs.
                var compressedPayload []byte
                if len(shortChanIDs) &gt; 0 </span><span class="cov0" title="0">{
                        // We'll make a new write buffer to hold the bytes of
                        // shortChanIDs.
                        var wb bytes.Buffer

                        // Next, we'll write out all the channel ID's directly
                        // into the zlib writer, which will do compressing on
                        // the fly.
                        for _, chanID := range shortChanIDs </span><span class="cov0" title="0">{
                                err := WriteShortChannelID(&amp;wb, chanID)
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf(
                                                "unable to write short chan "+
                                                        "ID: %v", err,
                                        )
                                }</span>
                        }

                        // With shortChanIDs written into wb, we'll create a
                        // zlib writer and write all the compressed bytes.
                        <span class="cov0" title="0">var zlibBuffer bytes.Buffer
                        zlibWriter := zlib.NewWriter(&amp;zlibBuffer)

                        if _, err := zlibWriter.Write(wb.Bytes()); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf(
                                        "unable to write compressed short chan"+
                                                "ID: %w", err)
                        }</span>

                        // Now that we've written all the elements, we'll
                        // ensure the compressed stream is written to the
                        // underlying buffer.
                        <span class="cov0" title="0">if err := zlibWriter.Close(); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("unable to finalize "+
                                        "compression: %v", err)
                        }</span>

                        <span class="cov0" title="0">compressedPayload = zlibBuffer.Bytes()</span>
                }

                // Now that we have all the items compressed, we can compute
                // what the total payload size will be. We add one to account
                // for the byte to encode the type.
                //
                // If we don't have any actual bytes to write, then we'll end
                // up emitting one byte for the length, followed by the
                // encoding type, and nothing more. The spec isn't 100% clear
                // in this area, but we do this as this is what most of the
                // other implementations do.
                <span class="cov0" title="0">numBytesBody := len(compressedPayload) + 1

                // Finally, we can write out the number of bytes, the
                // compression type, and finally the buffer itself.
                if err := WriteUint16(w, uint16(numBytesBody)); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">err := WriteQueryEncoding(w, encodingType)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">return WriteBytes(w, compressedPayload)</span>

        default:<span class="cov0" title="0">
                // If we're trying to encode with an encoding type that we
                // don't know of, then we'll return a parsing error as we can't
                // continue if we're unable to encode them.
                return ErrUnknownShortChanIDEncoding(encodingType)</span>
        }
}

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (q *QueryShortChanIDs) MsgType() MessageType <span class="cov0" title="0">{
        return MsgQueryShortChanIDs
}</span>

// SerializedSize returns the serialized size of the message in bytes.
//
// This is part of the lnwire.SizeableMessage interface.
func (q *QueryShortChanIDs) SerializedSize() (uint32, error) <span class="cov0" title="0">{
        return MessageSerializedSize(q)
}</span>
</pre>
		
		<pre class="file" id="file94" style="display: none">package lnwire

import (
        "bytes"
        "fmt"
        "io"
        "math"
        "sort"

        "github.com/btcsuite/btcd/chaincfg/chainhash"
        "github.com/lightningnetwork/lnd/tlv"
)

// ReplyChannelRange is the response to the QueryChannelRange message. It
// includes the original query, and the next streaming chunk of encoded short
// channel ID's as the response. We'll also include a byte that indicates if
// this is the last query in the message.
type ReplyChannelRange struct {
        // ChainHash denotes the target chain that we're trying to synchronize
        // channel graph state for.
        ChainHash chainhash.Hash

        // FirstBlockHeight is the first block in the query range. The
        // responder should send all new short channel IDs from this block
        // until this block plus the specified number of blocks.
        FirstBlockHeight uint32

        // NumBlocks is the number of blocks beyond the first block that short
        // channel ID's should be sent for.
        NumBlocks uint32

        // Complete denotes if this is the conclusion of the set of streaming
        // responses to the original query.
        Complete uint8

        // EncodingType is a signal to the receiver of the message that
        // indicates exactly how the set of short channel ID's that follow have
        // been encoded.
        EncodingType QueryEncoding

        // ShortChanIDs is a slice of decoded short channel ID's.
        ShortChanIDs []ShortChannelID

        // Timestamps is an optional set of timestamps corresponding to the
        // latest timestamps for the channel update messages corresponding to
        // those referenced in the ShortChanIDs list. If this field is used,
        // then the length must match the length of ShortChanIDs.
        Timestamps Timestamps

        // ExtraData is the set of data that was appended to this message to
        // fill out the full maximum transport message size. These fields can
        // be used to specify optional data such as custom TLV fields.
        ExtraData ExtraOpaqueData

        // noSort indicates whether or not to sort the short channel ids before
        // writing them out.
        //
        // NOTE: This should only be used for testing.
        noSort bool
}

// NewReplyChannelRange creates a new empty ReplyChannelRange message.
func NewReplyChannelRange() *ReplyChannelRange <span class="cov0" title="0">{
        return &amp;ReplyChannelRange{
                ExtraData: make([]byte, 0),
        }
}</span>

// A compile time check to ensure ReplyChannelRange implements the
// lnwire.Message interface.
var _ Message = (*ReplyChannelRange)(nil)

// A compile time check to ensure ReplyChannelRange implements the
// lnwire.SizeableMessage interface.
var _ SizeableMessage = (*ReplyChannelRange)(nil)

// Decode deserializes a serialized ReplyChannelRange message stored in the
// passed io.Reader observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (c *ReplyChannelRange) Decode(r io.Reader, pver uint32) error <span class="cov0" title="0">{
        err := ReadElements(r,
                c.ChainHash[:],
                &amp;c.FirstBlockHeight,
                &amp;c.NumBlocks,
                &amp;c.Complete,
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">c.EncodingType, c.ShortChanIDs, err = decodeShortChanIDs(r)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var tlvRecords ExtraOpaqueData
        if err := ReadElements(r, &amp;tlvRecords); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var timeStamps Timestamps
        typeMap, err := tlvRecords.ExtractRecords(&amp;timeStamps)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Set the corresponding TLV types if they were included in the stream.
        <span class="cov0" title="0">if val, ok := typeMap[TimestampsRecordType]; ok &amp;&amp; val == nil </span><span class="cov0" title="0">{
                c.Timestamps = timeStamps

                // Check that a timestamp was provided for each SCID.
                if len(c.Timestamps) != len(c.ShortChanIDs) </span><span class="cov0" title="0">{
                        return fmt.Errorf("number of timestamps does not " +
                                "match number of SCIDs")
                }</span>
        }

        <span class="cov0" title="0">if len(tlvRecords) != 0 </span><span class="cov0" title="0">{
                c.ExtraData = tlvRecords
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Encode serializes the target ReplyChannelRange into the passed io.Writer
// observing the protocol version specified.
//
// This is part of the lnwire.Message interface.
func (c *ReplyChannelRange) Encode(w *bytes.Buffer, pver uint32) error <span class="cov0" title="0">{
        if err := WriteBytes(w, c.ChainHash[:]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteUint32(w, c.FirstBlockHeight); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteUint32(w, c.NumBlocks); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteUint8(w, c.Complete); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // For both of the current encoding types, the channel ID's are to be
        // sorted in place, so we'll do that now. The sorting is applied unless
        // we were specifically requested not to for testing purposes.
        <span class="cov0" title="0">if !c.noSort </span><span class="cov0" title="0">{
                var scidPreSortIndex map[uint64]int
                if len(c.Timestamps) != 0 </span><span class="cov0" title="0">{
                        // Sanity check that a timestamp was provided for each
                        // SCID.
                        if len(c.Timestamps) != len(c.ShortChanIDs) </span><span class="cov0" title="0">{
                                return fmt.Errorf("must provide a timestamp " +
                                        "pair for each of the given SCIDs")
                        }</span>

                        // Create a map from SCID value to the original index of
                        // the SCID in the unsorted list.
                        <span class="cov0" title="0">scidPreSortIndex = make(
                                map[uint64]int, len(c.ShortChanIDs),
                        )
                        for i, scid := range c.ShortChanIDs </span><span class="cov0" title="0">{
                                scidPreSortIndex[scid.ToUint64()] = i
                        }</span>

                        // Sanity check that there were no duplicates in the
                        // SCID list.
                        <span class="cov0" title="0">if len(scidPreSortIndex) != len(c.ShortChanIDs) </span><span class="cov0" title="0">{
                                return fmt.Errorf("scid list should not " +
                                        "contain duplicates")
                        }</span>
                }

                // Now sort the SCIDs.
                <span class="cov0" title="0">sort.Slice(c.ShortChanIDs, func(i, j int) bool </span><span class="cov0" title="0">{
                        return c.ShortChanIDs[i].ToUint64() &lt;
                                c.ShortChanIDs[j].ToUint64()
                }</span>)

                <span class="cov0" title="0">if len(c.Timestamps) != 0 </span><span class="cov0" title="0">{
                        timestamps := make(Timestamps, len(c.Timestamps))

                        for i, scid := range c.ShortChanIDs </span><span class="cov0" title="0">{
                                timestamps[i] = []ChanUpdateTimestamps(
                                        c.Timestamps,
                                )[scidPreSortIndex[scid.ToUint64()]]
                        }</span>
                        <span class="cov0" title="0">c.Timestamps = timestamps</span>
                }
        }

        <span class="cov0" title="0">err := encodeShortChanIDs(w, c.EncodingType, c.ShortChanIDs)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">recordProducers := make([]tlv.RecordProducer, 0, 1)
        if len(c.Timestamps) != 0 </span><span class="cov0" title="0">{
                recordProducers = append(recordProducers, &amp;c.Timestamps)
        }</span>
        <span class="cov0" title="0">err = EncodeMessageExtraData(&amp;c.ExtraData, recordProducers...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return WriteBytes(w, c.ExtraData)</span>
}

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (c *ReplyChannelRange) MsgType() MessageType <span class="cov0" title="0">{
        return MsgReplyChannelRange
}</span>

// LastBlockHeight returns the last block height covered by the range of a
// QueryChannelRange message.
func (c *ReplyChannelRange) LastBlockHeight() uint32 <span class="cov0" title="0">{
        // Handle overflows by casting to uint64.
        lastBlockHeight := uint64(c.FirstBlockHeight) + uint64(c.NumBlocks) - 1
        if lastBlockHeight &gt; math.MaxUint32 </span><span class="cov0" title="0">{
                return math.MaxUint32
        }</span>
        <span class="cov0" title="0">return uint32(lastBlockHeight)</span>
}

// SerializedSize returns the serialized size of the message in bytes.
//
// This is part of the lnwire.SizeableMessage interface.
func (c *ReplyChannelRange) SerializedSize() (uint32, error) <span class="cov0" title="0">{
        return MessageSerializedSize(c)
}</span>
</pre>
		
		<pre class="file" id="file95" style="display: none">package lnwire

import (
        "bytes"
        "io"

        "github.com/btcsuite/btcd/chaincfg/chainhash"
)

// ReplyShortChanIDsEnd is a message that marks the end of a streaming message
// response to an initial QueryShortChanIDs message. This marks that the
// receiver of the original QueryShortChanIDs for the target chain has either
// sent all adequate responses it knows of, or doesn't know of any short chan
// ID's for the target chain.
type ReplyShortChanIDsEnd struct {
        // ChainHash denotes the target chain that we're respond to a short
        // chan ID query for.
        ChainHash chainhash.Hash

        // Complete will be set to 0 if we don't know of the chain that the
        // remote peer sent their query for. Otherwise, we'll set this to 1 in
        // order to indicate that we've sent all known responses for the prior
        // set of short chan ID's in the corresponding QueryShortChanIDs
        // message.
        Complete uint8

        // ExtraData is the set of data that was appended to this message to
        // fill out the full maximum transport message size. These fields can
        // be used to specify optional data such as custom TLV fields.
        ExtraData ExtraOpaqueData
}

// NewReplyShortChanIDsEnd creates a new empty ReplyShortChanIDsEnd message.
func NewReplyShortChanIDsEnd() *ReplyShortChanIDsEnd <span class="cov0" title="0">{
        return &amp;ReplyShortChanIDsEnd{}
}</span>

// A compile time check to ensure ReplyShortChanIDsEnd implements the
// lnwire.Message interface.
var _ Message = (*ReplyShortChanIDsEnd)(nil)

// A compile time check to ensure ReplyShortChanIDsEnd implements the
// lnwire.SizeableMessage interface.
var _ SizeableMessage = (*ReplyShortChanIDsEnd)(nil)

// Decode deserializes a serialized ReplyShortChanIDsEnd message stored in the
// passed io.Reader observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (c *ReplyShortChanIDsEnd) Decode(r io.Reader, pver uint32) error <span class="cov0" title="0">{
        return ReadElements(r,
                c.ChainHash[:],
                &amp;c.Complete,
                &amp;c.ExtraData,
        )
}</span>

// Encode serializes the target ReplyShortChanIDsEnd into the passed io.Writer
// observing the protocol version specified.
//
// This is part of the lnwire.Message interface.
func (c *ReplyShortChanIDsEnd) Encode(w *bytes.Buffer, pver uint32) error <span class="cov0" title="0">{
        if err := WriteBytes(w, c.ChainHash[:]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteUint8(w, c.Complete); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return WriteBytes(w, c.ExtraData)</span>
}

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (c *ReplyShortChanIDsEnd) MsgType() MessageType <span class="cov0" title="0">{
        return MsgReplyShortChanIDsEnd
}</span>

// SerializedSize returns the serialized size of the message in bytes.
//
// This is part of the lnwire.SizeableMessage interface.
func (c *ReplyShortChanIDsEnd) SerializedSize() (uint32, error) <span class="cov0" title="0">{
        return MessageSerializedSize(c)
}</span>
</pre>
		
		<pre class="file" id="file96" style="display: none">package lnwire

import (
        "bytes"
        "io"

        "github.com/btcsuite/btcd/btcec/v2"
        "github.com/lightningnetwork/lnd/tlv"
)

// RevokeAndAck is sent by either side once a CommitSig message has been
// received, and validated. This message serves to revoke the prior commitment
// transaction, which was the most up to date version until a CommitSig message
// referencing the specified ChannelPoint was received.  Additionally, this
// message also piggyback's the next revocation hash that Alice should use when
// constructing the Bob's version of the next commitment transaction (which
// would be done before sending a CommitSig message).  This piggybacking allows
// Alice to send the next CommitSig message modifying Bob's commitment
// transaction without first asking for a revocation hash initially.
type RevokeAndAck struct {
        // ChanID uniquely identifies to which currently active channel this
        // RevokeAndAck applies to.
        ChanID ChannelID

        // Revocation is the preimage to the revocation hash of the now prior
        // commitment transaction.
        Revocation [32]byte

        // NextRevocationKey is the next commitment point which should be used
        // for the next commitment transaction the remote peer creates for us.
        // This, in conjunction with revocation base point will be used to
        // create the proper revocation key used within the commitment
        // transaction.
        NextRevocationKey *btcec.PublicKey

        // LocalNonce is the next _local_ nonce for the sending party. This
        // allows the receiving party to propose a new commitment using their
        // remote nonce and the sender's local nonce.
        LocalNonce OptMusig2NonceTLV

        // ExtraData is the set of data that was appended to this message to
        // fill out the full maximum transport message size. These fields can
        // be used to specify optional data such as custom TLV fields.
        ExtraData ExtraOpaqueData
}

// NewRevokeAndAck creates a new RevokeAndAck message.
func NewRevokeAndAck() *RevokeAndAck <span class="cov0" title="0">{
        return &amp;RevokeAndAck{
                ExtraData: make([]byte, 0),
        }
}</span>

// A compile time check to ensure RevokeAndAck implements the lnwire.Message
// interface.
var _ Message = (*RevokeAndAck)(nil)

// A compile time check to ensure RevokeAndAck implements the
// lnwire.SizeableMessage interface.
var _ SizeableMessage = (*RevokeAndAck)(nil)

// Decode deserializes a serialized RevokeAndAck message stored in the
// passed io.Reader observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (c *RevokeAndAck) Decode(r io.Reader, pver uint32) error <span class="cov0" title="0">{
        err := ReadElements(r,
                &amp;c.ChanID,
                c.Revocation[:],
                &amp;c.NextRevocationKey,
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var tlvRecords ExtraOpaqueData
        if err := ReadElements(r, &amp;tlvRecords); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">localNonce := c.LocalNonce.Zero()
        typeMap, err := tlvRecords.ExtractRecords(&amp;localNonce)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Set the corresponding TLV types if they were included in the stream.
        <span class="cov0" title="0">if val, ok := typeMap[c.LocalNonce.TlvType()]; ok &amp;&amp; val == nil </span><span class="cov0" title="0">{
                c.LocalNonce = tlv.SomeRecordT(localNonce)
        }</span>

        <span class="cov0" title="0">if len(tlvRecords) != 0 </span><span class="cov0" title="0">{
                c.ExtraData = tlvRecords
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Encode serializes the target RevokeAndAck into the passed io.Writer
// observing the protocol version specified.
//
// This is part of the lnwire.Message interface.
func (c *RevokeAndAck) Encode(w *bytes.Buffer, pver uint32) error <span class="cov0" title="0">{
        recordProducers := make([]tlv.RecordProducer, 0, 1)
        c.LocalNonce.WhenSome(func(localNonce Musig2NonceTLV) </span><span class="cov0" title="0">{
                recordProducers = append(recordProducers, &amp;localNonce)
        }</span>)
        <span class="cov0" title="0">err := EncodeMessageExtraData(&amp;c.ExtraData, recordProducers...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteChannelID(w, c.ChanID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteBytes(w, c.Revocation[:]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WritePublicKey(w, c.NextRevocationKey); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return WriteBytes(w, c.ExtraData)</span>
}

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (c *RevokeAndAck) MsgType() MessageType <span class="cov0" title="0">{
        return MsgRevokeAndAck
}</span>

// TargetChanID returns the channel id of the link for which this message is
// intended.
//
// NOTE: Part of peer.LinkUpdater interface.
func (c *RevokeAndAck) TargetChanID() ChannelID <span class="cov0" title="0">{
        return c.ChanID
}</span>

// SerializedSize returns the serialized size of the message in bytes.
//
// This is part of the lnwire.SizeableMessage interface.
func (c *RevokeAndAck) SerializedSize() (uint32, error) <span class="cov0" title="0">{
        return MessageSerializedSize(c)
}</span>
</pre>
		
		<pre class="file" id="file97" style="display: none">package lnwire

import (
        "fmt"
        "io"

        "github.com/lightningnetwork/lnd/tlv"
)

const (
        // AliasScidRecordType is the type of the experimental record to denote
        // the alias being used in an option_scid_alias channel.
        AliasScidRecordType tlv.Type = 1
)

// ShortChannelID represents the set of data which is needed to retrieve all
// necessary data to validate the channel existence.
type ShortChannelID struct {
        // BlockHeight is the height of the block where funding transaction
        // located.
        //
        // NOTE: This field is limited to 3 bytes.
        BlockHeight uint32

        // TxIndex is a position of funding transaction within a block.
        //
        // NOTE: This field is limited to 3 bytes.
        TxIndex uint32

        // TxPosition indicating transaction output which pays to the channel.
        TxPosition uint16
}

// NewShortChanIDFromInt returns a new ShortChannelID which is the decoded
// version of the compact channel ID encoded within the uint64. The format of
// the compact channel ID is as follows: 3 bytes for the block height, 3 bytes
// for the transaction index, and 2 bytes for the output index.
func NewShortChanIDFromInt(chanID uint64) ShortChannelID <span class="cov0" title="0">{
        return ShortChannelID{
                BlockHeight: uint32(chanID &gt;&gt; 40),
                TxIndex:     uint32(chanID&gt;&gt;16) &amp; 0xFFFFFF,
                TxPosition:  uint16(chanID),
        }
}</span>

// ToUint64 converts the ShortChannelID into a compact format encoded within a
// uint64 (8 bytes).
func (c ShortChannelID) ToUint64() uint64 <span class="cov0" title="0">{
        // TODO(roasbeef): explicit error on overflow?
        return ((uint64(c.BlockHeight) &lt;&lt; 40) | (uint64(c.TxIndex) &lt;&lt; 16) |
                (uint64(c.TxPosition)))
}</span>

// String generates a human-readable representation of the channel ID.
func (c ShortChannelID) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("%d:%d:%d", c.BlockHeight, c.TxIndex, c.TxPosition)
}</span>

// AltString generates a human-readable representation of the channel ID
// with 'x' as a separator.
func (c ShortChannelID) AltString() string <span class="cov0" title="0">{
        return fmt.Sprintf("%dx%dx%d", c.BlockHeight, c.TxIndex, c.TxPosition)
}</span>

// Record returns a TLV record that can be used to encode/decode a
// ShortChannelID to/from a TLV stream.
func (c *ShortChannelID) Record() tlv.Record <span class="cov0" title="0">{
        return tlv.MakeStaticRecord(
                AliasScidRecordType, c, 8, EShortChannelID, DShortChannelID,
        )
}</span>

// IsDefault returns true if the ShortChannelID represents the zero value for
// its type.
func (c ShortChannelID) IsDefault() bool <span class="cov0" title="0">{
        return c == ShortChannelID{}
}</span>

// EShortChannelID is an encoder for ShortChannelID. It is exported so other
// packages can use the encoding scheme.
func EShortChannelID(w io.Writer, val interface{}, buf *[8]byte) error <span class="cov0" title="0">{
        if v, ok := val.(*ShortChannelID); ok </span><span class="cov0" title="0">{
                return tlv.EUint64T(w, v.ToUint64(), buf)
        }</span>
        <span class="cov0" title="0">return tlv.NewTypeForEncodingErr(val, "lnwire.ShortChannelID")</span>
}

// DShortChannelID is a decoder for ShortChannelID. It is exported so other
// packages can use the decoding scheme.
func DShortChannelID(r io.Reader, val interface{}, buf *[8]byte,
        l uint64) error <span class="cov0" title="0">{

        if v, ok := val.(*ShortChannelID); ok </span><span class="cov0" title="0">{
                var scid uint64
                err := tlv.DUint64(r, &amp;scid, buf, 8)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">*v = NewShortChanIDFromInt(scid)
                return nil</span>
        }
        <span class="cov0" title="0">return tlv.NewTypeForDecodingErr(val, "lnwire.ShortChannelID", l, 8)</span>
}
</pre>
		
		<pre class="file" id="file98" style="display: none">package lnwire

import (
        "bytes"
        "io"

        "github.com/lightningnetwork/lnd/tlv"
)

type (
        // ShutdownNonceType is the type of the shutdown nonce TLV record.
        ShutdownNonceType = tlv.TlvType8

        // ShutdownNonceTLV is the TLV record that contains the shutdown nonce.
        ShutdownNonceTLV = tlv.OptionalRecordT[ShutdownNonceType, Musig2Nonce]
)

// SomeShutdownNonce returns a ShutdownNonceTLV with the given nonce.
func SomeShutdownNonce(nonce Musig2Nonce) ShutdownNonceTLV <span class="cov0" title="0">{
        return tlv.SomeRecordT(
                tlv.NewRecordT[ShutdownNonceType, Musig2Nonce](nonce),
        )
}</span>

// Shutdown is sent by either side in order to initiate the cooperative closure
// of a channel. This message is sparse as both sides implicitly have the
// information necessary to construct a transaction that will send the settled
// funds of both parties to the final delivery addresses negotiated during the
// funding workflow.
type Shutdown struct {
        // ChannelID serves to identify which channel is to be closed.
        ChannelID ChannelID

        // Address is the script to which the channel funds will be paid.
        Address DeliveryAddress

        // ShutdownNonce is the nonce the sender will use to sign the first
        // co-op sign offer.
        ShutdownNonce ShutdownNonceTLV

        // CustomRecords maps TLV types to byte slices, storing arbitrary data
        // intended for inclusion in the ExtraData field of the Shutdown
        // message.
        CustomRecords CustomRecords

        // ExtraData is the set of data that was appended to this message to
        // fill out the full maximum transport message size. These fields can
        // be used to specify optional data such as custom TLV fields.
        ExtraData ExtraOpaqueData
}

// NewShutdown creates a new Shutdown message.
func NewShutdown(cid ChannelID, addr DeliveryAddress) *Shutdown <span class="cov0" title="0">{
        return &amp;Shutdown{
                ChannelID: cid,
                Address:   addr,
        }
}</span>

// A compile-time check to ensure Shutdown implements the lnwire.Message
// interface.
var _ Message = (*Shutdown)(nil)

// A compile-time check to ensure Shutdown implements the lnwire.SizeableMessage
// interface.
var _ SizeableMessage = (*Shutdown)(nil)

// Decode deserializes a serialized Shutdown from the passed io.Reader,
// observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (s *Shutdown) Decode(r io.Reader, pver uint32) error <span class="cov0" title="0">{
        err := ReadElements(r, &amp;s.ChannelID, &amp;s.Address)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var tlvRecords ExtraOpaqueData
        if err := ReadElements(r, &amp;tlvRecords); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Extract TLV records from the extra data field.
        <span class="cov0" title="0">musigNonce := s.ShutdownNonce.Zero()

        customRecords, parsed, extraData, err := ParseAndExtractCustomRecords(
                tlvRecords, &amp;musigNonce,
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Assign the parsed records back to the message.
        <span class="cov0" title="0">if _, ok := parsed[musigNonce.TlvType()]; ok </span><span class="cov0" title="0">{
                s.ShutdownNonce = tlv.SomeRecordT(musigNonce)
        }</span>

        <span class="cov0" title="0">s.CustomRecords = customRecords
        s.ExtraData = extraData

        return nil</span>
}

// Encode serializes the target Shutdown into the passed io.Writer observing
// the protocol version specified.
//
// This is part of the lnwire.Message interface.
func (s *Shutdown) Encode(w *bytes.Buffer, pver uint32) error <span class="cov0" title="0">{
        if err := WriteChannelID(w, s.ChannelID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteDeliveryAddress(w, s.Address); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Only include nonce in extra data if present.
        <span class="cov0" title="0">var records []tlv.RecordProducer
        s.ShutdownNonce.WhenSome(
                func(nonce tlv.RecordT[ShutdownNonceType, Musig2Nonce]) </span><span class="cov0" title="0">{
                        records = append(records, &amp;nonce)
                }</span>,
        )

        <span class="cov0" title="0">extraData, err := MergeAndEncode(records, s.ExtraData, s.CustomRecords)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return WriteBytes(w, extraData)</span>
}

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (s *Shutdown) MsgType() MessageType <span class="cov0" title="0">{
        return MsgShutdown
}</span>

// SerializedSize returns the serialized size of the message in bytes.
//
// This is part of the lnwire.SizeableMessage interface.
func (s *Shutdown) SerializedSize() (uint32, error) <span class="cov0" title="0">{
        return MessageSerializedSize(s)
}</span>
</pre>
		
		<pre class="file" id="file99" style="display: none">package lnwire

import (
        "errors"
        "fmt"

        "github.com/btcsuite/btcd/btcec/v2/ecdsa"
        "github.com/btcsuite/btcd/btcec/v2/schnorr"
        "github.com/lightningnetwork/lnd/input"
        "github.com/lightningnetwork/lnd/tlv"
)

var (
        errSigTooShort = errors.New("malformed signature: too short")
        errBadLength   = errors.New("malformed signature: bad length")
        errBadRLength  = errors.New("malformed signature: bogus R length")
        errBadSLength  = errors.New("malformed signature: bogus S length")
        errRTooLong    = errors.New("R is over 32 bytes long without padding")
        errSTooLong    = errors.New("S is over 32 bytes long without padding")
)

// sigType represents the type of signature that is carried within the Sig.
// Today this can either be an ECDSA sig or a schnorr sig. Both of these can
// fit cleanly into 64 bytes.
type sigType uint

const (
        // sigTypeECDSA represents an ECDSA signature.
        sigTypeECDSA sigType = iota

        // sigTypeSchnorr represents a schnorr signature.
        sigTypeSchnorr
)

// Sig is a fixed-sized ECDSA signature or 64-byte schnorr signature. For the
// ECDSA sig, unlike Bitcoin, we use fixed sized signatures on the wire,
// instead of DER encoded signatures. This type provides several methods to
// convert to/from a regular Bitcoin DER encoded signature (raw bytes and
// *ecdsa.Signature).
type Sig struct {
        bytes [64]byte

        sigType sigType
}

// ForceSchnorr forces the signature to be interpreted as a schnorr signature.
// This is useful when reading an HTLC sig off the wire for a taproot channel.
// In this case, in order to obtain an input.Signature, we need to know that
// the sig is a schnorr sig.
func (s *Sig) ForceSchnorr() <span class="cov0" title="0">{
        s.sigType = sigTypeSchnorr
}</span>

// RawBytes returns the raw bytes of signature.
func (s *Sig) RawBytes() []byte <span class="cov0" title="0">{
        return s.bytes[:]
}</span>

// Copy copies the signature into a new Sig instance.
func (s *Sig) Copy() Sig <span class="cov0" title="0">{
        var sCopy Sig
        copy(sCopy.bytes[:], s.bytes[:])
        sCopy.sigType = s.sigType

        return sCopy
}</span>

// Record returns a Record that can be used to encode or decode the backing
// object.
//
// This returns a record that serializes the sig as a 64-byte fixed size
// signature.
func (s *Sig) Record() tlv.Record <span class="cov0" title="0">{
        // We set a type here as zero as it isn't needed when used as a
        // RecordT.
        return tlv.MakePrimitiveRecord(0, &amp;s.bytes)
}</span>

// NewSigFromWireECDSA returns a Sig instance based on an ECDSA signature
// that's already in the 64-byte format we expect.
func NewSigFromWireECDSA(sig []byte) (Sig, error) <span class="cov0" title="0">{
        if len(sig) != 64 </span><span class="cov0" title="0">{
                return Sig{}, fmt.Errorf("%w: %v bytes", errSigTooShort,
                        len(sig))
        }</span>

        <span class="cov0" title="0">var s Sig
        copy(s.bytes[:], sig)

        return s, nil</span>
}

// NewSigFromECDSARawSignature returns a Sig from a Bitcoin raw signature
// encoded in the canonical DER encoding.
func NewSigFromECDSARawSignature(sig []byte) (Sig, error) <span class="cov0" title="0">{
        var b [64]byte

        // Check the total length is above the minimal.
        if len(sig) &lt; ecdsa.MinSigLen </span><span class="cov0" title="0">{
                return Sig{}, errSigTooShort
        }</span>

        // The DER representation is laid out as:
        //   0x30 &lt;length&gt; 0x02 &lt;length r&gt; r 0x02 &lt;length s&gt; s
        // which means the length of R is the 4th byte and the length of S is
        // the second byte after R ends. 0x02 signifies a length-prefixed,
        // zero-padded, big-endian bigint. 0x30 signifies a DER signature.
        // See the Serialize() method for ecdsa.Signature for details.

        // Reading &lt;length&gt;, remaining: [0x02 &lt;length r&gt; r 0x02 &lt;length s&gt; s]
        <span class="cov0" title="0">sigLen := int(sig[1])

        // siglen should be less than the entire message and greater than
        // the minimal message size.
        if sigLen+2 &gt; len(sig) || sigLen+2 &lt; ecdsa.MinSigLen </span><span class="cov0" title="0">{
                return Sig{}, errBadLength
        }</span>

        // Reading &lt;length r&gt;, remaining: [r 0x02 &lt;length s&gt; s]
        <span class="cov0" title="0">rLen := int(sig[3])

        // rLen must be positive and must be able to fit in other elements.
        // Assuming s is one byte, then we have 0x30, &lt;length&gt;, 0x20,
        // &lt;length r&gt;, 0x20, &lt;length s&gt;, s, a total of 7 bytes.
        if rLen &lt;= 0 || rLen+7 &gt; len(sig) </span><span class="cov0" title="0">{
                return Sig{}, errBadRLength
        }</span>

        // Reading &lt;length s&gt;, remaining: [s]
        <span class="cov0" title="0">sLen := int(sig[5+rLen])

        // S should be the rest of the string.
        // sLen must be positive and must be able to fit in other elements.
        // We know r is rLen bytes, and we have 0x30, &lt;length&gt;, 0x20,
        // &lt;length r&gt;, 0x20, &lt;length s&gt;, a total of rLen+6 bytes.
        if sLen &lt;= 0 || sLen+rLen+6 &gt; len(sig) </span><span class="cov0" title="0">{
                return Sig{}, errBadSLength
        }</span>

        // Check to make sure R and S can both fit into their intended buffers.
        // We check S first because these code blocks decrement sLen and rLen
        // in the case of a 33-byte 0-padded integer returned from Serialize()
        // and rLen is used in calculating array indices for S. We can track
        // this with additional variables, but it's more efficient to just
        // check S first.
        <span class="cov0" title="0">if sLen &gt; 32 </span><span class="cov0" title="0">{
                if (sLen &gt; 33) || (sig[6+rLen] != 0x00) </span><span class="cov0" title="0">{
                        return Sig{}, errSTooLong
                }</span>
                <span class="cov0" title="0">sLen--
                copy(b[64-sLen:], sig[7+rLen:])</span>
        } else<span class="cov0" title="0"> {
                copy(b[64-sLen:], sig[6+rLen:])
        }</span>

        // Do the same for R as we did for S
        <span class="cov0" title="0">if rLen &gt; 32 </span><span class="cov0" title="0">{
                if (rLen &gt; 33) || (sig[4] != 0x00) </span><span class="cov0" title="0">{
                        return Sig{}, errRTooLong
                }</span>
                <span class="cov0" title="0">rLen--
                copy(b[32-rLen:], sig[5:5+rLen])</span>
        } else<span class="cov0" title="0"> {
                copy(b[32-rLen:], sig[4:4+rLen])
        }</span>

        <span class="cov0" title="0">return Sig{
                bytes:   b,
                sigType: sigTypeECDSA,
        }, nil</span>
}

// NewSigFromSchnorrRawSignature converts a raw schnorr signature into an
// lnwire.Sig.
func NewSigFromSchnorrRawSignature(sig []byte) (Sig, error) <span class="cov0" title="0">{
        var s Sig
        copy(s.bytes[:], sig)
        s.sigType = sigTypeSchnorr

        return s, nil
}</span>

// NewSigFromSignature creates a new signature as used on the wire, from an
// existing ecdsa.Signature or schnorr.Signature.
func NewSigFromSignature(e input.Signature) (Sig, error) <span class="cov0" title="0">{
        if e == nil </span><span class="cov0" title="0">{
                return Sig{}, fmt.Errorf("cannot decode empty signature")
        }</span>

        // Nil is still a valid interface, apparently. So we need a more
        // explicit check here.
        <span class="cov0" title="0">if ecsig, ok := e.(*ecdsa.Signature); ok &amp;&amp; ecsig == nil </span><span class="cov0" title="0">{
                return Sig{}, fmt.Errorf("cannot decode empty signature")
        }</span>

        <span class="cov0" title="0">switch ecSig := e.(type) </span>{
        // If this is a schnorr signature, then we can just pack it as normal,
        // since the default encoding is already 64 bytes.
        case *schnorr.Signature:<span class="cov0" title="0">
                return NewSigFromSchnorrRawSignature(e.Serialize())</span>

        // For ECDSA signatures, we'll need to do a bit more work to map the
        // signature into a compact 64 byte form.
        case *ecdsa.Signature:<span class="cov0" title="0">
                // Serialize the signature with all the checks that entails.
                return NewSigFromECDSARawSignature(e.Serialize())</span>

        default:<span class="cov0" title="0">
                return Sig{}, fmt.Errorf("unknown wire sig type: %T", ecSig)</span>
        }
}

// ToSignature converts the fixed-sized signature to a input.Signature which
// can be used for signature validation checks.
func (s *Sig) ToSignature() (input.Signature, error) <span class="cov0" title="0">{
        switch s.sigType </span>{
        case sigTypeSchnorr:<span class="cov0" title="0">
                return schnorr.ParseSignature(s.bytes[:])</span>

        case sigTypeECDSA:<span class="cov0" title="0">
                // Parse the signature with strict checks.
                sigBytes := s.ToSignatureBytes()
                sig, err := ecdsa.ParseDERSignature(sigBytes)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">return sig, nil</span>

        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unknown sig type: %v", s.sigType)</span>
        }
}

// ToSignatureBytes serializes the target fixed-sized signature into the
// encoding of the primary domain for the signature. For ECDSA signatures, this
// is the raw bytes of a DER encoding.
func (s *Sig) ToSignatureBytes() []byte <span class="cov0" title="0">{
        switch s.sigType </span>{
        // For ECDSA signatures, we'll convert to DER encoding.
        case sigTypeECDSA:<span class="cov0" title="0">
                // Extract canonically-padded bigint representations from buffer
                r := extractCanonicalPadding(s.bytes[0:32])
                s := extractCanonicalPadding(s.bytes[32:64])
                rLen := uint8(len(r))
                sLen := uint8(len(s))

                // Create a canonical serialized signature. DER format is:
                // 0x30 &lt;length&gt; 0x02 &lt;length r&gt; r 0x02 &lt;length s&gt; s
                sigBytes := make([]byte, 6+rLen+sLen)
                sigBytes[0] = 0x30            // DER signature magic value
                sigBytes[1] = 4 + rLen + sLen // Length of rest of signature
                sigBytes[2] = 0x02            // Big integer magic value
                sigBytes[3] = rLen            // Length of R
                sigBytes[rLen+4] = 0x02       // Big integer magic value
                sigBytes[rLen+5] = sLen       // Length of S
                copy(sigBytes[4:], r)         // Copy R
                copy(sigBytes[rLen+6:], s)    // Copy S

                return sigBytes</span>

        // For schnorr signatures, we can use the same internal 64 bytes.
        case sigTypeSchnorr:<span class="cov0" title="0">
                // We'll make a copy of the signature so we don't return a
                // reference into the raw slice.
                var sig [64]byte
                copy(sig[:], s.bytes[:])
                return sig[:]</span>

        default:<span class="cov0" title="0">
                // TODO(roasbeef): can only be called via public methods so
                // never reachable?
                panic("sig type not set")</span>
        }
}

// extractCanonicalPadding is a utility function to extract the canonical
// padding of a big-endian integer from the wire encoding (a 0-padded
// big-endian integer) such that it passes btcec.canonicalPadding test.
func extractCanonicalPadding(b []byte) []byte <span class="cov0" title="0">{
        for i := 0; i &lt; len(b); i++ </span><span class="cov0" title="0">{
                // Found first non-zero byte.
                if b[i] &gt; 0 </span><span class="cov0" title="0">{
                        // If the MSB is set, we need zero padding.
                        if b[i]&amp;0x80 == 0x80 </span><span class="cov0" title="0">{
                                return append([]byte{0x00}, b[i:]...)
                        }</span>
                        <span class="cov0" title="0">return b[i:]</span>
                }
        }
        <span class="cov0" title="0">return []byte{0x00}</span>
}
</pre>
		
		<pre class="file" id="file100" style="display: none">package lnwire

import (
        "bytes"
        "io"
)

// Stfu is a message that is sent to lock the channel state prior to some other
// interactive protocol where channel updates need to be paused.
type Stfu struct {
        // ChanID identifies which channel needs to be frozen.
        ChanID ChannelID

        // Initiator is a byte that identifies whether we are the initiator of
        // this process.
        Initiator bool

        // ExtraData is the set of data that was appended to this message to
        // fill out the full maximum transport message size. These fields can
        // be used to specify optional data such as custom TLV fields.
        ExtraData ExtraOpaqueData
}

// A compile time check to ensure Stfu implements the lnwire.Message interface.
var _ Message = (*Stfu)(nil)

// A compile time check to ensure Stfu implements the lnwire.SizeableMessage
// interface.
var _ SizeableMessage = (*Stfu)(nil)

// Encode serializes the target Stfu into the passed io.Writer.
// Serialization will observe the rules defined by the passed protocol version.
//
// This is a part of the lnwire.Message interface.
func (s *Stfu) Encode(w *bytes.Buffer, _ uint32) error <span class="cov0" title="0">{
        if err := WriteChannelID(w, s.ChanID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteBool(w, s.Initiator); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return WriteBytes(w, s.ExtraData)</span>
}

// Decode deserializes the serialized Stfu stored in the passed io.Reader
// into the target Stfu using the deserialization rules defined by the
// passed protocol version.
//
// This is a part of the lnwire.Message interface.
func (s *Stfu) Decode(r io.Reader, _ uint32) error <span class="cov0" title="0">{
        if err := ReadElements(
                r, &amp;s.ChanID, &amp;s.Initiator, &amp;s.ExtraData,
        ); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // This is required to pass the fuzz test round trip equality check.
        <span class="cov0" title="0">if len(s.ExtraData) == 0 </span><span class="cov0" title="0">{
                s.ExtraData = nil
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// MsgType returns the MessageType code which uniquely identifies this message
// as a Stfu on the wire.
//
// This is part of the lnwire.Message interface.
func (s *Stfu) MsgType() MessageType <span class="cov0" title="0">{
        return MsgStfu
}</span>

// SerializedSize returns the serialized size of the message in bytes.
//
// This is part of the lnwire.SizeableMessage interface.
func (s *Stfu) SerializedSize() (uint32, error) <span class="cov0" title="0">{
        return MessageSerializedSize(s)
}</span>

// A compile time check to ensure Stfu implements the
// lnwire.LinkUpdater interface.
var _ LinkUpdater = (*Stfu)(nil)

// TargetChanID returns the channel id of the link for which this message is
// intended.
//
// NOTE: Part of peer.LinkUpdater interface.
func (s *Stfu) TargetChanID() ChannelID <span class="cov0" title="0">{
        return s.ChanID
}</span>
</pre>
		
		<pre class="file" id="file101" style="display: none">package lnwire

import (
        "bytes"
        "fmt"
        "image/color"
        "math"

        "github.com/btcsuite/btcd/btcec/v2"
        "github.com/btcsuite/btcd/btcutil"
        "github.com/btcsuite/btcd/chaincfg/chainhash"
        "github.com/lightningnetwork/lnd/fn/v2"
        "github.com/lightningnetwork/lnd/lnwallet/chainfee"
        "github.com/lightningnetwork/lnd/tlv"
        "pgregory.net/rapid"
)

// TestMessage is an interface that extends the base Message interface with a
// method to populate the message with random testing data.
type TestMessage interface {
        Message

        // RandTestMessage populates the message with random data suitable for
        // testing. It uses the rapid testing framework to generate random
        // values.
        RandTestMessage(t *rapid.T) Message
}

// A compile time check to ensure AcceptChannel implements the TestMessage
// interface.
var _ TestMessage = (*AcceptChannel)(nil)

// RandTestMessage populates the message with random data suitable for testing.
// It uses the rapid testing framework to generate random values.
//
// This is part of the TestMessage interface.
func (a *AcceptChannel) RandTestMessage(t *rapid.T) Message <span class="cov0" title="0">{
        var pendingChanID [32]byte
        pendingChanIDBytes := rapid.SliceOfN(rapid.Byte(), 32, 32).Draw(
                t, "pendingChanID",
        )
        copy(pendingChanID[:], pendingChanIDBytes)

        var channelType *ChannelType
        includeChannelType := rapid.Bool().Draw(t, "includeChannelType")
        includeLeaseExpiry := rapid.Bool().Draw(t, "includeLeaseExpiry")
        includeLocalNonce := rapid.Bool().Draw(t, "includeLocalNonce")

        if includeChannelType </span><span class="cov0" title="0">{
                channelType = RandChannelType(t)
        }</span>

        <span class="cov0" title="0">var leaseExpiry *LeaseExpiry
        if includeLeaseExpiry </span><span class="cov0" title="0">{
                leaseExpiry = RandLeaseExpiry(t)
        }</span>

        <span class="cov0" title="0">var localNonce OptMusig2NonceTLV
        if includeLocalNonce </span><span class="cov0" title="0">{
                nonce := RandMusig2Nonce(t)
                localNonce = tlv.SomeRecordT(
                        tlv.NewRecordT[NonceRecordTypeT, Musig2Nonce](nonce),
                )
        }</span>

        <span class="cov0" title="0">return &amp;AcceptChannel{
                PendingChannelID: pendingChanID,
                DustLimit: btcutil.Amount(
                        rapid.IntRange(100, 1000).Draw(t, "dustLimit"),
                ),
                MaxValueInFlight: MilliSatoshi(
                        rapid.IntRange(10000, 1000000).Draw(
                                t, "maxValueInFlight",
                        ),
                ),
                ChannelReserve: btcutil.Amount(
                        rapid.IntRange(1000, 10000).Draw(t, "channelReserve"),
                ),
                HtlcMinimum: MilliSatoshi(
                        rapid.IntRange(1, 1000).Draw(t, "htlcMinimum"),
                ),
                MinAcceptDepth: uint32(
                        rapid.IntRange(1, 10).Draw(t, "minAcceptDepth"),
                ),
                CsvDelay: uint16(
                        rapid.IntRange(144, 1000).Draw(t, "csvDelay"),
                ),
                MaxAcceptedHTLCs: uint16(
                        rapid.IntRange(10, 500).Draw(t, "maxAcceptedHTLCs"),
                ),
                FundingKey:            RandPubKey(t),
                RevocationPoint:       RandPubKey(t),
                PaymentPoint:          RandPubKey(t),
                DelayedPaymentPoint:   RandPubKey(t),
                HtlcPoint:             RandPubKey(t),
                FirstCommitmentPoint:  RandPubKey(t),
                UpfrontShutdownScript: RandDeliveryAddress(t),
                ChannelType:           channelType,
                LeaseExpiry:           leaseExpiry,
                LocalNonce:            localNonce,
                ExtraData:             RandExtraOpaqueData(t, nil),
        }</span>
}

// A compile time check to ensure AnnounceSignatures1 implements the
// lnwire.TestMessage interface.
var _ TestMessage = (*AnnounceSignatures1)(nil)

// RandTestMessage populates the message with random data suitable for testing.
// It uses the rapid testing framework to generate random values.
//
// This is part of the TestMessage interface.
func (a *AnnounceSignatures1) RandTestMessage(t *rapid.T) Message <span class="cov0" title="0">{
        return &amp;AnnounceSignatures1{
                ChannelID:        RandChannelID(t),
                ShortChannelID:   RandShortChannelID(t),
                NodeSignature:    RandSignature(t),
                BitcoinSignature: RandSignature(t),
                ExtraOpaqueData:  RandExtraOpaqueData(t, nil),
        }
}</span>

// A compile time check to ensure AnnounceSignatures2 implements the
// lnwire.TestMessage interface.
var _ TestMessage = (*AnnounceSignatures2)(nil)

// RandTestMessage populates the message with random data suitable for testing.
// It uses the rapid testing framework to generate random values.
//
// This is part of the TestMessage interface.
func (a *AnnounceSignatures2) RandTestMessage(t *rapid.T) Message <span class="cov0" title="0">{
        return &amp;AnnounceSignatures2{
                ChannelID:        RandChannelID(t),
                ShortChannelID:   RandShortChannelID(t),
                PartialSignature: *RandPartialSig(t),
                ExtraOpaqueData:  RandExtraOpaqueData(t, nil),
        }
}</span>

// A compile time check to ensure ChannelAnnouncement1 implements the
// TestMessage interface.
var _ TestMessage = (*ChannelAnnouncement1)(nil)

// RandTestMessage populates the message with random data suitable for testing.
// It uses the rapid testing framework to generate random values.
//
// This is part of the TestMessage interface.
func (a *ChannelAnnouncement1) RandTestMessage(t *rapid.T) Message <span class="cov0" title="0">{
        // Generate Node IDs and Bitcoin keys (compressed public keys)
        node1PubKey := RandPubKey(t)
        node2PubKey := RandPubKey(t)
        bitcoin1PubKey := RandPubKey(t)
        bitcoin2PubKey := RandPubKey(t)

        // Convert to byte arrays
        var nodeID1, nodeID2, bitcoinKey1, bitcoinKey2 [33]byte
        copy(nodeID1[:], node1PubKey.SerializeCompressed())
        copy(nodeID2[:], node2PubKey.SerializeCompressed())
        copy(bitcoinKey1[:], bitcoin1PubKey.SerializeCompressed())
        copy(bitcoinKey2[:], bitcoin2PubKey.SerializeCompressed())

        // Ensure nodeID1 is numerically less than nodeID2
        // This is a requirement stated in the field description
        if bytes.Compare(nodeID1[:], nodeID2[:]) &gt; 0 </span><span class="cov0" title="0">{
                nodeID1, nodeID2 = nodeID2, nodeID1
        }</span>

        // Generate chain hash
        <span class="cov0" title="0">chainHash := RandChainHash(t)
        var hash chainhash.Hash
        copy(hash[:], chainHash[:])

        return &amp;ChannelAnnouncement1{
                NodeSig1:        RandSignature(t),
                NodeSig2:        RandSignature(t),
                BitcoinSig1:     RandSignature(t),
                BitcoinSig2:     RandSignature(t),
                Features:        RandFeatureVector(t),
                ChainHash:       hash,
                ShortChannelID:  RandShortChannelID(t),
                NodeID1:         nodeID1,
                NodeID2:         nodeID2,
                BitcoinKey1:     bitcoinKey1,
                BitcoinKey2:     bitcoinKey2,
                ExtraOpaqueData: RandExtraOpaqueData(t, nil),
        }</span>
}

// A compile time check to ensure ChannelAnnouncement2 implements the
// lnwire.TestMessage interface.
var _ TestMessage = (*ChannelAnnouncement2)(nil)

// RandTestMessage populates the message with random data suitable for testing.
// It uses the rapid testing framework to generate random values.
//
// This is part of the TestMessage interface.
func (c *ChannelAnnouncement2) RandTestMessage(t *rapid.T) Message <span class="cov0" title="0">{
        features := RandFeatureVector(t)
        shortChanID := RandShortChannelID(t)
        capacity := uint64(rapid.IntRange(1, 16777215).Draw(t, "capacity"))

        var nodeID1, nodeID2 [33]byte
        copy(nodeID1[:], RandPubKey(t).SerializeCompressed())
        copy(nodeID2[:], RandPubKey(t).SerializeCompressed())

        // Make sure nodeID1 is numerically less than nodeID2 (as per spec).
        if bytes.Compare(nodeID1[:], nodeID2[:]) &gt; 0 </span><span class="cov0" title="0">{
                nodeID1, nodeID2 = nodeID2, nodeID1
        }</span>

        <span class="cov0" title="0">chainHash := RandChainHash(t)
        var chainHashObj chainhash.Hash
        copy(chainHashObj[:], chainHash[:])

        msg := &amp;ChannelAnnouncement2{
                Signature: RandSignature(t),
                ChainHash: tlv.NewPrimitiveRecord[tlv.TlvType0, chainhash.Hash](
                        chainHashObj,
                ),
                Features: tlv.NewRecordT[tlv.TlvType2, RawFeatureVector](
                        *features,
                ),
                ShortChannelID: tlv.NewRecordT[tlv.TlvType4, ShortChannelID](
                        shortChanID,
                ),
                Capacity: tlv.NewPrimitiveRecord[tlv.TlvType6, uint64](
                        capacity,
                ),
                NodeID1: tlv.NewPrimitiveRecord[tlv.TlvType8, [33]byte](
                        nodeID1,
                ),
                NodeID2: tlv.NewPrimitiveRecord[tlv.TlvType10, [33]byte](
                        nodeID2,
                ),
                ExtraOpaqueData: RandExtraOpaqueData(t, nil),
        }

        msg.Signature.ForceSchnorr()

        // Randomly include optional fields
        if rapid.Bool().Draw(t, "includeBitcoinKey1") </span><span class="cov0" title="0">{
                var bitcoinKey1 [33]byte
                copy(bitcoinKey1[:], RandPubKey(t).SerializeCompressed())
                msg.BitcoinKey1 = tlv.SomeRecordT(
                        tlv.NewPrimitiveRecord[tlv.TlvType12, [33]byte](
                                bitcoinKey1,
                        ),
                )
        }</span>

        <span class="cov0" title="0">if rapid.Bool().Draw(t, "includeBitcoinKey2") </span><span class="cov0" title="0">{
                var bitcoinKey2 [33]byte
                copy(bitcoinKey2[:], RandPubKey(t).SerializeCompressed())
                msg.BitcoinKey2 = tlv.SomeRecordT(
                        tlv.NewPrimitiveRecord[tlv.TlvType14, [33]byte](
                                bitcoinKey2,
                        ),
                )
        }</span>

        <span class="cov0" title="0">if rapid.Bool().Draw(t, "includeMerkleRootHash") </span><span class="cov0" title="0">{
                hash := RandSHA256Hash(t)
                var merkleRootHash [32]byte
                copy(merkleRootHash[:], hash[:])
                msg.MerkleRootHash = tlv.SomeRecordT(
                        tlv.NewPrimitiveRecord[tlv.TlvType16, [32]byte](
                                merkleRootHash,
                        ),
                )
        }</span>

        <span class="cov0" title="0">return msg</span>
}

// A compile time check to ensure ChannelReady implements the lnwire.TestMessage
// interface.
var _ TestMessage = (*ChannelReady)(nil)

// RandTestMessage populates the message with random data suitable for testing.
// It uses the rapid testing framework to generate random values.
//
// This is part of the TestMessage interface.
func (c *ChannelReady) RandTestMessage(t *rapid.T) Message <span class="cov0" title="0">{
        msg := &amp;ChannelReady{
                ChanID:                 RandChannelID(t),
                NextPerCommitmentPoint: RandPubKey(t),
                ExtraData:              RandExtraOpaqueData(t, nil),
        }

        includeAliasScid := rapid.Bool().Draw(t, "includeAliasScid")
        includeNextLocalNonce := rapid.Bool().Draw(t, "includeNextLocalNonce")
        includeAnnouncementNodeNonce := rapid.Bool().Draw(
                t, "includeAnnouncementNodeNonce",
        )
        includeAnnouncementBitcoinNonce := rapid.Bool().Draw(
                t, "includeAnnouncementBitcoinNonce",
        )

        if includeAliasScid </span><span class="cov0" title="0">{
                scid := RandShortChannelID(t)
                msg.AliasScid = &amp;scid
        }</span>

        <span class="cov0" title="0">if includeNextLocalNonce </span><span class="cov0" title="0">{
                nonce := RandMusig2Nonce(t)
                msg.NextLocalNonce = SomeMusig2Nonce(nonce)
        }</span>

        <span class="cov0" title="0">if includeAnnouncementNodeNonce </span><span class="cov0" title="0">{
                nonce := RandMusig2Nonce(t)
                msg.AnnouncementNodeNonce = tlv.SomeRecordT(
                        tlv.NewRecordT[tlv.TlvType0, Musig2Nonce](nonce),
                )
        }</span>

        <span class="cov0" title="0">if includeAnnouncementBitcoinNonce </span><span class="cov0" title="0">{
                nonce := RandMusig2Nonce(t)
                msg.AnnouncementBitcoinNonce = tlv.SomeRecordT(
                        tlv.NewRecordT[tlv.TlvType2, Musig2Nonce](nonce),
                )
        }</span>

        <span class="cov0" title="0">return msg</span>
}

// A compile time check to ensure ChannelReestablish implements the
// lnwire.TestMessage interface.
var _ TestMessage = (*ChannelReestablish)(nil)

// RandTestMessage populates the message with random data suitable for testing.
// It uses the rapid testing framework to generate random values.
//
// This is part of the TestMessage interface.
func (a *ChannelReestablish) RandTestMessage(t *rapid.T) Message <span class="cov0" title="0">{
        msg := &amp;ChannelReestablish{
                ChanID: RandChannelID(t),
                NextLocalCommitHeight: rapid.Uint64().Draw(
                        t, "nextLocalCommitHeight",
                ),
                RemoteCommitTailHeight: rapid.Uint64().Draw(
                        t, "remoteCommitTailHeight",
                ),
                LastRemoteCommitSecret:    RandPaymentPreimage(t),
                LocalUnrevokedCommitPoint: RandPubKey(t),
                ExtraData:                 RandExtraOpaqueData(t, nil),
        }

        // Randomly decide whether to include optional fields
        includeLocalNonce := rapid.Bool().Draw(t, "includeLocalNonce")
        includeDynHeight := rapid.Bool().Draw(t, "includeDynHeight")

        if includeLocalNonce </span><span class="cov0" title="0">{
                nonce := RandMusig2Nonce(t)
                msg.LocalNonce = SomeMusig2Nonce(nonce)
        }</span>

        <span class="cov0" title="0">if includeDynHeight </span><span class="cov0" title="0">{
                height := DynHeight(rapid.Uint64().Draw(t, "dynHeight"))
                msg.DynHeight = fn.Some(height)
        }</span>

        <span class="cov0" title="0">return msg</span>
}

// A compile time check to ensure ChannelUpdate1 implements the TestMessage
// interface.
var _ TestMessage = (*ChannelUpdate1)(nil)

// RandTestMessage populates the message with random data suitable for testing.
// It uses the rapid testing framework to generate random values.
//
// This is part of the TestMessage interface.
func (a *ChannelUpdate1) RandTestMessage(t *rapid.T) Message <span class="cov0" title="0">{
        // Generate random message flags
        // Randomly decide whether to include max HTLC field
        includeMaxHtlc := rapid.Bool().Draw(t, "includeMaxHtlc")
        var msgFlags ChanUpdateMsgFlags
        if includeMaxHtlc </span><span class="cov0" title="0">{
                msgFlags |= ChanUpdateRequiredMaxHtlc
        }</span>

        // Generate random channel flags
        // Randomly decide direction (node1 or node2)
        <span class="cov0" title="0">isNode2 := rapid.Bool().Draw(t, "isNode2")
        var chanFlags ChanUpdateChanFlags
        if isNode2 </span><span class="cov0" title="0">{
                chanFlags |= ChanUpdateDirection
        }</span>

        // Randomly decide if channel is disabled
        <span class="cov0" title="0">isDisabled := rapid.Bool().Draw(t, "isDisabled")
        if isDisabled </span><span class="cov0" title="0">{
                chanFlags |= ChanUpdateDisabled
        }</span>

        // Generate chain hash
        <span class="cov0" title="0">chainHash := RandChainHash(t)
        var hash chainhash.Hash
        copy(hash[:], chainHash[:])

        // Generate other random fields
        maxHtlc := MilliSatoshi(rapid.Uint64().Draw(t, "maxHtlc"))

        // If max HTLC flag is not set, we need to zero the value
        if !includeMaxHtlc </span><span class="cov0" title="0">{
                maxHtlc = 0
        }</span>

        <span class="cov0" title="0">return &amp;ChannelUpdate1{
                Signature:      RandSignature(t),
                ChainHash:      hash,
                ShortChannelID: RandShortChannelID(t),
                Timestamp: uint32(rapid.IntRange(0, 0x7FFFFFFF).Draw(
                        t, "timestamp"),
                ),
                MessageFlags: msgFlags,
                ChannelFlags: chanFlags,
                TimeLockDelta: uint16(rapid.IntRange(0, 65535).Draw(
                        t, "timelockDelta"),
                ),
                HtlcMinimumMsat: MilliSatoshi(rapid.Uint64().Draw(
                        t, "htlcMinimum"),
                ),
                BaseFee: uint32(rapid.IntRange(0, 0x7FFFFFFF).Draw(
                        t, "baseFee"),
                ),
                FeeRate: uint32(rapid.IntRange(0, 0x7FFFFFFF).Draw(
                        t, "feeRate"),
                ),
                HtlcMaximumMsat: maxHtlc,
                ExtraOpaqueData: RandExtraOpaqueData(t, nil),
        }</span>
}

// A compile time check to ensure ChannelUpdate2 implements the
// lnwire.TestMessage interface.
var _ TestMessage = (*ChannelUpdate2)(nil)

// RandTestMessage populates the message with random data suitable for testing.
// It uses the rapid testing framework to generate random values.
//
// This is part of the TestMessage interface.
func (c *ChannelUpdate2) RandTestMessage(t *rapid.T) Message <span class="cov0" title="0">{
        shortChanID := RandShortChannelID(t)
        blockHeight := uint32(rapid.IntRange(0, 1000000).Draw(t, "blockHeight"))

        var disabledFlags ChanUpdateDisableFlags
        if rapid.Bool().Draw(t, "disableIncoming") </span><span class="cov0" title="0">{
                disabledFlags |= ChanUpdateDisableIncoming
        }</span>
        <span class="cov0" title="0">if rapid.Bool().Draw(t, "disableOutgoing") </span><span class="cov0" title="0">{
                disabledFlags |= ChanUpdateDisableOutgoing
        }</span>

        <span class="cov0" title="0">cltvExpiryDelta := uint16(rapid.IntRange(10, 200).Draw(
                t, "cltvExpiryDelta"),
        )

        htlcMinMsat := MilliSatoshi(rapid.IntRange(1, 10000).Draw(
                t, "htlcMinMsat"),
        )
        htlcMaxMsat := MilliSatoshi(rapid.IntRange(10000, 100000000).Draw(
                t, "htlcMaxMsat"),
        )
        feeBaseMsat := uint32(rapid.IntRange(0, 10000).Draw(t, "feeBaseMsat"))
        feeProportionalMillionths := uint32(rapid.IntRange(0, 10000).Draw(
                t, "feeProportionalMillionths"),
        )

        chainHash := RandChainHash(t)
        var chainHashObj chainhash.Hash
        copy(chainHashObj[:], chainHash[:])

        //nolint:ll
        msg := &amp;ChannelUpdate2{
                Signature: RandSignature(t),
                ChainHash: tlv.NewPrimitiveRecord[tlv.TlvType0, chainhash.Hash](
                        chainHashObj,
                ),
                ShortChannelID: tlv.NewRecordT[tlv.TlvType2, ShortChannelID](
                        shortChanID,
                ),
                BlockHeight: tlv.NewPrimitiveRecord[tlv.TlvType4, uint32](
                        blockHeight,
                ),
                DisabledFlags: tlv.NewPrimitiveRecord[tlv.TlvType6, ChanUpdateDisableFlags]( //nolint:ll
                        disabledFlags,
                ),
                CLTVExpiryDelta: tlv.NewPrimitiveRecord[tlv.TlvType10, uint16](
                        cltvExpiryDelta,
                ),
                HTLCMinimumMsat: tlv.NewPrimitiveRecord[tlv.TlvType12, MilliSatoshi](
                        htlcMinMsat,
                ),
                HTLCMaximumMsat: tlv.NewPrimitiveRecord[tlv.TlvType14, MilliSatoshi](
                        htlcMaxMsat,
                ),
                FeeBaseMsat: tlv.NewPrimitiveRecord[tlv.TlvType16, uint32](
                        feeBaseMsat,
                ),
                FeeProportionalMillionths: tlv.NewPrimitiveRecord[tlv.TlvType18, uint32](
                        feeProportionalMillionths,
                ),
                ExtraOpaqueData: RandExtraOpaqueData(t, nil),
        }

        msg.Signature.ForceSchnorr()

        if rapid.Bool().Draw(t, "isSecondPeer") </span><span class="cov0" title="0">{
                msg.SecondPeer = tlv.SomeRecordT(
                        tlv.RecordT[tlv.TlvType8, TrueBoolean]{},
                )
        }</span>

        <span class="cov0" title="0">return msg</span>
}

// A compile time check to ensure ClosingComplete implements the
// lnwire.TestMessage interface.
var _ TestMessage = (*ClosingComplete)(nil)

// RandTestMessage populates the message with random data suitable for testing.
// It uses the rapid testing framework to generate random values.
//
// This is part of the TestMessage interface.
func (c *ClosingComplete) RandTestMessage(t *rapid.T) Message <span class="cov0" title="0">{
        msg := &amp;ClosingComplete{
                ChannelID: RandChannelID(t),
                FeeSatoshis: btcutil.Amount(rapid.Int64Range(0, 1000000).Draw(
                        t, "feeSatoshis"),
                ),
                LockTime: rapid.Uint32Range(0, 0xffffffff).Draw(
                        t, "lockTime",
                ),
                CloseeScript: RandDeliveryAddress(t),
                CloserScript: RandDeliveryAddress(t),
                ExtraData:    RandExtraOpaqueData(t, nil),
        }

        includeCloserNoClosee := rapid.Bool().Draw(t, "includeCloserNoClosee")
        includeNoCloserClosee := rapid.Bool().Draw(t, "includeNoCloserClosee")
        includeCloserAndClosee := rapid.Bool().Draw(t, "includeCloserAndClosee")

        // Ensure at least one signature is present.
        if !includeCloserNoClosee &amp;&amp; !includeNoCloserClosee &amp;&amp;
                !includeCloserAndClosee </span><span class="cov0" title="0">{

                // If all are false, enable at least one randomly.
                choice := rapid.IntRange(0, 2).Draw(t, "sigChoice")
                switch choice </span>{
                case 0:<span class="cov0" title="0">
                        includeCloserNoClosee = true</span>
                case 1:<span class="cov0" title="0">
                        includeNoCloserClosee = true</span>
                case 2:<span class="cov0" title="0">
                        includeCloserAndClosee = true</span>
                }
        }

        <span class="cov0" title="0">if includeCloserNoClosee </span><span class="cov0" title="0">{
                sig := RandSignature(t)
                msg.CloserNoClosee = tlv.SomeRecordT(
                        tlv.NewRecordT[tlv.TlvType1, Sig](sig),
                )
        }</span>

        <span class="cov0" title="0">if includeNoCloserClosee </span><span class="cov0" title="0">{
                sig := RandSignature(t)
                msg.NoCloserClosee = tlv.SomeRecordT(
                        tlv.NewRecordT[tlv.TlvType2, Sig](sig),
                )
        }</span>

        <span class="cov0" title="0">if includeCloserAndClosee </span><span class="cov0" title="0">{
                sig := RandSignature(t)
                msg.CloserAndClosee = tlv.SomeRecordT(
                        tlv.NewRecordT[tlv.TlvType3, Sig](sig),
                )
        }</span>

        <span class="cov0" title="0">return msg</span>
}

// A compile time check to ensure ClosingSig implements the lnwire.TestMessage
// interface.
var _ TestMessage = (*ClosingSig)(nil)

// RandTestMessage populates the message with random data suitable for testing.
// It uses the rapid testing framework to generate random values.
//
// This is part of the TestMessage interface.
func (c *ClosingSig) RandTestMessage(t *rapid.T) Message <span class="cov0" title="0">{
        msg := &amp;ClosingSig{
                ChannelID:    RandChannelID(t),
                CloseeScript: RandDeliveryAddress(t),
                CloserScript: RandDeliveryAddress(t),
                ExtraData:    RandExtraOpaqueData(t, nil),
        }

        includeCloserNoClosee := rapid.Bool().Draw(t, "includeCloserNoClosee")
        includeNoCloserClosee := rapid.Bool().Draw(t, "includeNoCloserClosee")
        includeCloserAndClosee := rapid.Bool().Draw(t, "includeCloserAndClosee")

        // Ensure at least one signature is present.
        if !includeCloserNoClosee &amp;&amp; !includeNoCloserClosee &amp;&amp;
                !includeCloserAndClosee </span><span class="cov0" title="0">{

                // If all are false, enable at least one randomly.
                choice := rapid.IntRange(0, 2).Draw(t, "sigChoice")
                switch choice </span>{
                case 0:<span class="cov0" title="0">
                        includeCloserNoClosee = true</span>
                case 1:<span class="cov0" title="0">
                        includeNoCloserClosee = true</span>
                case 2:<span class="cov0" title="0">
                        includeCloserAndClosee = true</span>
                }
        }

        <span class="cov0" title="0">if includeCloserNoClosee </span><span class="cov0" title="0">{
                sig := RandSignature(t)
                msg.CloserNoClosee = tlv.SomeRecordT(
                        tlv.NewRecordT[tlv.TlvType1, Sig](sig),
                )
        }</span>

        <span class="cov0" title="0">if includeNoCloserClosee </span><span class="cov0" title="0">{
                sig := RandSignature(t)
                msg.NoCloserClosee = tlv.SomeRecordT(
                        tlv.NewRecordT[tlv.TlvType2, Sig](sig),
                )
        }</span>

        <span class="cov0" title="0">if includeCloserAndClosee </span><span class="cov0" title="0">{
                sig := RandSignature(t)
                msg.CloserAndClosee = tlv.SomeRecordT(
                        tlv.NewRecordT[tlv.TlvType3, Sig](sig),
                )
        }</span>

        <span class="cov0" title="0">return msg</span>
}

// A compile time check to ensure ClosingSigned implements the
// lnwire.TestMessage interface.
var _ TestMessage = (*ClosingSigned)(nil)

// RandTestMessage populates the message with random data suitable for testing.
// It uses the rapid testing framework to generate random values.
//
// This is part of the TestMessage interface.
func (c *ClosingSigned) RandTestMessage(t *rapid.T) Message <span class="cov0" title="0">{
        // Generate a random boolean to decide whether to include CommitSig or
        // PartialSig Since they're mutually exclusive, when one is populated,
        // the other must be blank.
        usePartialSig := rapid.Bool().Draw(t, "usePartialSig")

        msg := &amp;ClosingSigned{
                ChannelID: RandChannelID(t),
                FeeSatoshis: btcutil.Amount(
                        rapid.Int64Range(0, 1000000).Draw(t, "feeSatoshis"),
                ),
                ExtraData: RandExtraOpaqueData(t, nil),
        }

        if usePartialSig </span><span class="cov0" title="0">{
                sigBytes := rapid.SliceOfN(rapid.Byte(), 32, 32).Draw(
                        t, "sigScalar",
                )
                var s btcec.ModNScalar
                _ = s.SetByteSlice(sigBytes)

                msg.PartialSig = SomePartialSig(NewPartialSig(s))
                msg.Signature = Sig{}
        }</span> else<span class="cov0" title="0"> {
                msg.Signature = RandSignature(t)
        }</span>

        <span class="cov0" title="0">return msg</span>
}

// A compile time check to ensure CommitSig implements the lnwire.TestMessage
// interface.
var _ TestMessage = (*CommitSig)(nil)

// RandTestMessage populates the message with random data suitable for testing.
// It uses the rapid testing framework to generate random values.
//
// This is part of the TestMessage interface.
func (c *CommitSig) RandTestMessage(t *rapid.T) Message <span class="cov0" title="0">{
        cr, _ := RandCustomRecords(t, nil, true)
        sig := &amp;CommitSig{
                ChanID:        RandChannelID(t),
                CommitSig:     RandSignature(t),
                CustomRecords: cr,
        }

        numHtlcSigs := rapid.IntRange(0, 20).Draw(t, "numHtlcSigs")
        htlcSigs := make([]Sig, numHtlcSigs)
        for i := 0; i &lt; numHtlcSigs; i++ </span><span class="cov0" title="0">{
                htlcSigs[i] = RandSignature(t)
        }</span>

        <span class="cov0" title="0">if len(htlcSigs) &gt; 0 </span><span class="cov0" title="0">{
                sig.HtlcSigs = htlcSigs
        }</span>

        <span class="cov0" title="0">includePartialSig := rapid.Bool().Draw(t, "includePartialSig")
        if includePartialSig </span><span class="cov0" title="0">{
                sigWithNonce := RandPartialSigWithNonce(t)
                sig.PartialSig = MaybePartialSigWithNonce(sigWithNonce)
        }</span>

        <span class="cov0" title="0">return sig</span>
}

// A compile time check to ensure Custom implements the lnwire.TestMessage
// interface.
var _ TestMessage = (*Custom)(nil)

// RandTestMessage populates the message with random data suitable for testing.
// It uses the rapid testing framework to generate random values.
//
// This is part of the TestMessage interface.
func (c *Custom) RandTestMessage(t *rapid.T) Message <span class="cov0" title="0">{
        msgType := MessageType(
                rapid.IntRange(int(CustomTypeStart), 65535).Draw(
                        t, "customMsgType",
                ),
        )

        dataLen := rapid.IntRange(0, 1000).Draw(t, "customDataLength")
        data := rapid.SliceOfN(rapid.Byte(), dataLen, dataLen).Draw(
                t, "customData",
        )

        msg, err := NewCustom(msgType, data)
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Error creating custom message: %v", err))</span>
        }

        <span class="cov0" title="0">return msg</span>
}

// A compile time check to ensure DynAck implements the lnwire.TestMessage
// interface.
var _ TestMessage = (*DynAck)(nil)

// RandTestMessage populates the message with random data suitable for testing.
// It uses the rapid testing framework to generate random values.
//
// This is part of the TestMessage interface.
func (da *DynAck) RandTestMessage(t *rapid.T) Message <span class="cov0" title="0">{
        msg := &amp;DynAck{
                ChanID:    RandChannelID(t),
                ExtraData: RandExtraOpaqueData(t, nil),
        }

        includeLocalNonce := rapid.Bool().Draw(t, "includeLocalNonce")

        if includeLocalNonce </span><span class="cov0" title="0">{
                msg.LocalNonce = fn.Some(RandMusig2Nonce(t))
        }</span>

        <span class="cov0" title="0">return msg</span>
}

// A compile time check to ensure DynPropose implements the lnwire.TestMessage
// interface.
var _ TestMessage = (*DynPropose)(nil)

// RandTestMessage populates the message with random data suitable for testing.
// It uses the rapid testing framework to generate random values.
//
// This is part of the TestMessage interface.
func (dp *DynPropose) RandTestMessage(t *rapid.T) Message <span class="cov0" title="0">{
        msg := &amp;DynPropose{
                ChanID:    RandChannelID(t),
                Initiator: rapid.Bool().Draw(t, "initiator"),
                ExtraData: RandExtraOpaqueData(t, nil),
        }

        // Randomly decide which optional fields to include
        includeDustLimit := rapid.Bool().Draw(t, "includeDustLimit")
        includeMaxValueInFlight := rapid.Bool().Draw(
                t, "includeMaxValueInFlight",
        )
        includeChannelReserve := rapid.Bool().Draw(t, "includeChannelReserve")
        includeCsvDelay := rapid.Bool().Draw(t, "includeCsvDelay")
        includeMaxAcceptedHTLCs := rapid.Bool().Draw(
                t, "includeMaxAcceptedHTLCs",
        )
        includeFundingKey := rapid.Bool().Draw(t, "includeFundingKey")
        includeChannelType := rapid.Bool().Draw(t, "includeChannelType")
        includeKickoffFeerate := rapid.Bool().Draw(t, "includeKickoffFeerate")

        // Generate random values for each included field
        if includeDustLimit </span><span class="cov0" title="0">{
                dl := btcutil.Amount(rapid.Uint32().Draw(t, "dustLimit"))
                msg.DustLimit = fn.Some(dl)
        }</span>

        <span class="cov0" title="0">if includeMaxValueInFlight </span><span class="cov0" title="0">{
                mvif := MilliSatoshi(rapid.Uint64().Draw(t, "maxValueInFlight"))
                msg.MaxValueInFlight = fn.Some(mvif)
        }</span>

        <span class="cov0" title="0">if includeChannelReserve </span><span class="cov0" title="0">{
                cr := btcutil.Amount(rapid.Uint32().Draw(t, "channelReserve"))
                msg.ChannelReserve = fn.Some(cr)
        }</span>

        <span class="cov0" title="0">if includeCsvDelay </span><span class="cov0" title="0">{
                cd := rapid.Uint16().Draw(t, "csvDelay")
                msg.CsvDelay = fn.Some(cd)
        }</span>

        <span class="cov0" title="0">if includeMaxAcceptedHTLCs </span><span class="cov0" title="0">{
                mah := rapid.Uint16().Draw(t, "maxAcceptedHTLCs")
                msg.MaxAcceptedHTLCs = fn.Some(mah)
        }</span>

        <span class="cov0" title="0">if includeFundingKey </span><span class="cov0" title="0">{
                msg.FundingKey = fn.Some(*RandPubKey(t))
        }</span>

        <span class="cov0" title="0">if includeChannelType </span><span class="cov0" title="0">{
                msg.ChannelType = fn.Some(*RandChannelType(t))
        }</span>

        <span class="cov0" title="0">if includeKickoffFeerate </span><span class="cov0" title="0">{
                kf := chainfee.SatPerKWeight(rapid.Uint32().Draw(
                        t, "kickoffFeerate"),
                )
                msg.KickoffFeerate = fn.Some(kf)
        }</span>

        <span class="cov0" title="0">return msg</span>
}

// A compile time check to ensure DynReject implements the lnwire.TestMessage
// interface.
var _ TestMessage = (*DynReject)(nil)

// RandTestMessage populates the message with random data suitable for testing.
// It uses the rapid testing framework to generate random values.
//
// This is part of the TestMessage interface.
func (dr *DynReject) RandTestMessage(t *rapid.T) Message <span class="cov0" title="0">{
        featureVec := NewRawFeatureVector()

        numFeatures := rapid.IntRange(0, 8).Draw(t, "numRejections")
        for i := 0; i &lt; numFeatures; i++ </span><span class="cov0" title="0">{
                bit := FeatureBit(
                        rapid.IntRange(0, 31).Draw(
                                t, fmt.Sprintf("rejectionBit-%d", i),
                        ),
                )
                featureVec.Set(bit)
        }</span>

        <span class="cov0" title="0">var extraData ExtraOpaqueData
        randData := RandExtraOpaqueData(t, nil)
        if len(randData) &gt; 0 </span><span class="cov0" title="0">{
                extraData = randData
        }</span>

        <span class="cov0" title="0">return &amp;DynReject{
                ChanID:           RandChannelID(t),
                UpdateRejections: *featureVec,
                ExtraData:        extraData,
        }</span>
}

// A compile time check to ensure FundingCreated implements the TestMessage
// interface.
var _ TestMessage = (*FundingCreated)(nil)

// RandTestMessage populates the message with random data suitable for testing.
// It uses the rapid testing framework to generate random values.
//
// This is part of the TestMessage interface.
func (f *FundingCreated) RandTestMessage(t *rapid.T) Message <span class="cov0" title="0">{
        var pendingChanID [32]byte
        pendingChanIDBytes := rapid.SliceOfN(rapid.Byte(), 32, 32).Draw(
                t, "pendingChanID",
        )
        copy(pendingChanID[:], pendingChanIDBytes)

        includePartialSig := rapid.Bool().Draw(t, "includePartialSig")
        var partialSig OptPartialSigWithNonceTLV
        var commitSig Sig

        if includePartialSig </span><span class="cov0" title="0">{
                sigWithNonce := RandPartialSigWithNonce(t)
                partialSig = MaybePartialSigWithNonce(sigWithNonce)

                // When using partial sig, CommitSig should be empty/blank.
                commitSig = Sig{}
        }</span> else<span class="cov0" title="0"> {
                commitSig = RandSignature(t)
        }</span>

        <span class="cov0" title="0">return &amp;FundingCreated{
                PendingChannelID: pendingChanID,
                FundingPoint:     RandOutPoint(t),
                CommitSig:        commitSig,
                PartialSig:       partialSig,
                ExtraData:        RandExtraOpaqueData(t, nil),
        }</span>
}

// A compile time check to ensure FundingSigned implements the
// lnwire.TestMessage interface.
var _ TestMessage = (*FundingSigned)(nil)

// RandTestMessage populates the message with random data suitable for testing.
// It uses the rapid testing framework to generate random values.
//
// This is part of the TestMessage interface.
func (f *FundingSigned) RandTestMessage(t *rapid.T) Message <span class="cov0" title="0">{
        usePartialSig := rapid.Bool().Draw(t, "usePartialSig")

        msg := &amp;FundingSigned{
                ChanID:    RandChannelID(t),
                ExtraData: RandExtraOpaqueData(t, nil),
        }

        if usePartialSig </span><span class="cov0" title="0">{
                sigWithNonce := RandPartialSigWithNonce(t)
                msg.PartialSig = MaybePartialSigWithNonce(sigWithNonce)

                msg.CommitSig = Sig{}
        }</span> else<span class="cov0" title="0"> {
                msg.CommitSig = RandSignature(t)
        }</span>

        <span class="cov0" title="0">return msg</span>
}

// A compile time check to ensure GossipTimestampRange implements the
// lnwire.TestMessage interface.
var _ TestMessage = (*GossipTimestampRange)(nil)

// RandTestMessage populates the message with random data suitable for testing.
// It uses the rapid testing framework to generate random values.
//
// This is part of the TestMessage interface.
func (g *GossipTimestampRange) RandTestMessage(t *rapid.T) Message <span class="cov0" title="0">{
        var chainHash chainhash.Hash
        hashBytes := rapid.SliceOfN(rapid.Byte(), 32, 32).Draw(t, "chainHash")
        copy(chainHash[:], hashBytes)

        msg := &amp;GossipTimestampRange{
                ChainHash:      chainHash,
                FirstTimestamp: rapid.Uint32().Draw(t, "firstTimestamp"),
                TimestampRange: rapid.Uint32().Draw(t, "timestampRange"),
                ExtraData:      RandExtraOpaqueData(t, nil),
        }

        includeFirstBlockHeight := rapid.Bool().Draw(
                t, "includeFirstBlockHeight",
        )
        includeBlockRange := rapid.Bool().Draw(t, "includeBlockRange")

        if includeFirstBlockHeight </span><span class="cov0" title="0">{
                height := rapid.Uint32().Draw(t, "firstBlockHeight")
                msg.FirstBlockHeight = tlv.SomeRecordT(
                        tlv.RecordT[tlv.TlvType2, uint32]{Val: height},
                )
        }</span>

        <span class="cov0" title="0">if includeBlockRange </span><span class="cov0" title="0">{
                blockRange := rapid.Uint32().Draw(t, "blockRange")
                msg.BlockRange = tlv.SomeRecordT(
                        tlv.RecordT[tlv.TlvType4, uint32]{Val: blockRange},
                )
        }</span>

        <span class="cov0" title="0">return msg</span>
}

// RandTestMessage populates the message with random data suitable for testing.
// It uses the rapid testing framework to generate random values.
//
// This is part of the TestMessage interface.
func (msg *Init) RandTestMessage(t *rapid.T) Message <span class="cov0" title="0">{
        global := NewRawFeatureVector()
        local := NewRawFeatureVector()

        numGlobalFeatures := rapid.IntRange(0, 20).Draw(t, "numGlobalFeatures")
        for i := 0; i &lt; numGlobalFeatures; i++ </span><span class="cov0" title="0">{
                bit := FeatureBit(
                        rapid.IntRange(0, 100).Draw(
                                t, fmt.Sprintf("globalFeatureBit%d", i),
                        ),
                )
                global.Set(bit)
        }</span>

        <span class="cov0" title="0">numLocalFeatures := rapid.IntRange(0, 20).Draw(t, "numLocalFeatures")
        for i := 0; i &lt; numLocalFeatures; i++ </span><span class="cov0" title="0">{
                bit := FeatureBit(
                        rapid.IntRange(0, 100).Draw(
                                t, fmt.Sprintf("localFeatureBit%d", i),
                        ),
                )
                local.Set(bit)
        }</span>

        <span class="cov0" title="0">return NewInitMessage(global, local)</span>
}

// A compile time check to ensure KickoffSig implements the lnwire.TestMessage
// interface.
var _ TestMessage = (*KickoffSig)(nil)

// RandTestMessage populates the message with random data suitable for testing.
// It uses the rapid testing framework to generate random values.
//
// This is part of the TestMessage interface.
func (ks *KickoffSig) RandTestMessage(t *rapid.T) Message <span class="cov0" title="0">{
        return &amp;KickoffSig{
                ChanID:    RandChannelID(t),
                Signature: RandSignature(t),
                ExtraData: RandExtraOpaqueData(t, nil),
        }
}</span>

// A compile time check to ensure NodeAnnouncement implements the
// lnwire.TestMessage interface.
var _ TestMessage = (*NodeAnnouncement)(nil)

// RandTestMessage populates the message with random data suitable for testing.
// It uses the rapid testing framework to generate random values.
//
// This is part of the TestMessage interface.
func (a *NodeAnnouncement) RandTestMessage(t *rapid.T) Message <span class="cov0" title="0">{
        // Generate random compressed public key for node ID
        pubKey := RandPubKey(t)
        var nodeID [33]byte
        copy(nodeID[:], pubKey.SerializeCompressed())

        // Generate random RGB color
        rgbColor := color.RGBA{
                R: uint8(rapid.IntRange(0, 255).Draw(t, "rgbR")),
                G: uint8(rapid.IntRange(0, 255).Draw(t, "rgbG")),
                B: uint8(rapid.IntRange(0, 255).Draw(t, "rgbB")),
        }

        return &amp;NodeAnnouncement{
                Signature: RandSignature(t),
                Features:  RandFeatureVector(t),
                Timestamp: uint32(rapid.IntRange(0, 0x7FFFFFFF).Draw(
                        t, "timestamp"),
                ),
                NodeID:          nodeID,
                RGBColor:        rgbColor,
                Alias:           RandNodeAlias(t),
                Addresses:       RandNetAddrs(t),
                ExtraOpaqueData: RandExtraOpaqueData(t, nil),
        }
}</span>

// A compile time check to ensure OpenChannel implements the TestMessage
// interface.
var _ TestMessage = (*OpenChannel)(nil)

// RandTestMessage populates the message with random data suitable for testing.
// It uses the rapid testing framework to generate random values.
//
// This is part of the TestMessage interface.
func (o *OpenChannel) RandTestMessage(t *rapid.T) Message <span class="cov0" title="0">{
        chainHash := RandChainHash(t)
        var hash chainhash.Hash
        copy(hash[:], chainHash[:])

        var pendingChanID [32]byte
        pendingChanIDBytes := rapid.SliceOfN(rapid.Byte(), 32, 32).Draw(
                t, "pendingChanID",
        )
        copy(pendingChanID[:], pendingChanIDBytes)

        includeChannelType := rapid.Bool().Draw(t, "includeChannelType")
        includeLeaseExpiry := rapid.Bool().Draw(t, "includeLeaseExpiry")
        includeLocalNonce := rapid.Bool().Draw(t, "includeLocalNonce")

        var channelFlags FundingFlag
        if rapid.Bool().Draw(t, "announceChannel") </span><span class="cov0" title="0">{
                channelFlags |= FFAnnounceChannel
        }</span>

        <span class="cov0" title="0">var localNonce OptMusig2NonceTLV
        if includeLocalNonce </span><span class="cov0" title="0">{
                nonce := RandMusig2Nonce(t)
                localNonce = tlv.SomeRecordT(
                        tlv.NewRecordT[NonceRecordTypeT, Musig2Nonce](nonce),
                )
        }</span>

        <span class="cov0" title="0">var channelType *ChannelType
        if includeChannelType </span><span class="cov0" title="0">{
                channelType = RandChannelType(t)
        }</span>

        <span class="cov0" title="0">var leaseExpiry *LeaseExpiry
        if includeLeaseExpiry </span><span class="cov0" title="0">{
                leaseExpiry = RandLeaseExpiry(t)
        }</span>

        <span class="cov0" title="0">return &amp;OpenChannel{
                ChainHash:        hash,
                PendingChannelID: pendingChanID,
                FundingAmount: btcutil.Amount(
                        rapid.IntRange(5000, 10000000).Draw(t, "fundingAmount"),
                ),
                PushAmount: MilliSatoshi(
                        rapid.IntRange(0, 1000000).Draw(t, "pushAmount"),
                ),
                DustLimit: btcutil.Amount(
                        rapid.IntRange(100, 1000).Draw(t, "dustLimit"),
                ),
                MaxValueInFlight: MilliSatoshi(
                        rapid.IntRange(10000, 1000000).Draw(
                                t, "maxValueInFlight",
                        ),
                ),
                ChannelReserve: btcutil.Amount(
                        rapid.IntRange(1000, 10000).Draw(t, "channelReserve"),
                ),
                HtlcMinimum: MilliSatoshi(
                        rapid.IntRange(1, 1000).Draw(t, "htlcMinimum"),
                ),
                FeePerKiloWeight: uint32(
                        rapid.IntRange(250, 10000).Draw(t, "feePerKw"),
                ),
                CsvDelay: uint16(
                        rapid.IntRange(144, 1000).Draw(t, "csvDelay"),
                ),
                MaxAcceptedHTLCs: uint16(
                        rapid.IntRange(10, 500).Draw(t, "maxAcceptedHTLCs"),
                ),
                FundingKey:            RandPubKey(t),
                RevocationPoint:       RandPubKey(t),
                PaymentPoint:          RandPubKey(t),
                DelayedPaymentPoint:   RandPubKey(t),
                HtlcPoint:             RandPubKey(t),
                FirstCommitmentPoint:  RandPubKey(t),
                ChannelFlags:          channelFlags,
                UpfrontShutdownScript: RandDeliveryAddress(t),
                ChannelType:           channelType,
                LeaseExpiry:           leaseExpiry,
                LocalNonce:            localNonce,
                ExtraData:             RandExtraOpaqueData(t, nil),
        }</span>
}

// A compile time check to ensure Ping implements the lnwire.TestMessage
// interface.
var _ TestMessage = (*Ping)(nil)

// RandTestMessage populates the message with random data suitable for testing.
// It uses the rapid testing framework to generate random values.
//
// This is part of the TestMessage interface.
func (p *Ping) RandTestMessage(t *rapid.T) Message <span class="cov0" title="0">{
        numPongBytes := uint16(rapid.IntRange(0, int(MaxPongBytes)).Draw(
                t, "numPongBytes"),
        )

        // Generate padding bytes (but keeping within allowed message size)
        // MaxMsgBody - 2 (for NumPongBytes) - 2 (for padding length)
        maxPaddingLen := MaxMsgBody - 4
        paddingLen := rapid.IntRange(0, maxPaddingLen).Draw(
                t, "paddingLen",
        )
        padding := make(PingPayload, paddingLen)

        // Fill padding with random bytes
        for i := 0; i &lt; paddingLen; i++ </span><span class="cov0" title="0">{
                padding[i] = byte(rapid.IntRange(0, 255).Draw(
                        t, fmt.Sprintf("paddingByte%d", i)),
                )
        }</span>

        <span class="cov0" title="0">return &amp;Ping{
                NumPongBytes: numPongBytes,
                PaddingBytes: padding,
        }</span>
}

// A compile time check to ensure Pong implements the lnwire.TestMessage
// interface.
var _ TestMessage = (*Pong)(nil)

// RandTestMessage populates the message with random data suitable for testing.
// It uses the rapid testing framework to generate random values.
//
// This is part of the TestMessage interface.
func (p *Pong) RandTestMessage(t *rapid.T) Message <span class="cov0" title="0">{
        payloadLen := rapid.IntRange(0, 1000).Draw(t, "pongPayloadLength")
        payload := rapid.SliceOfN(rapid.Byte(), payloadLen, payloadLen).Draw(
                t, "pongPayload",
        )

        return &amp;Pong{
                PongBytes: payload,
        }
}</span>

// A compile time check to ensure QueryChannelRange implements the
// lnwire.TestMessage interface.
var _ TestMessage = (*QueryChannelRange)(nil)

// RandTestMessage populates the message with random data suitable for testing.
// It uses the rapid testing framework to generate random values.
//
// This is part of the TestMessage interface.
func (q *QueryChannelRange) RandTestMessage(t *rapid.T) Message <span class="cov0" title="0">{
        msg := &amp;QueryChannelRange{
                FirstBlockHeight: uint32(rapid.IntRange(0, 1000000).Draw(
                        t, "firstBlockHeight"),
                ),
                NumBlocks: uint32(rapid.IntRange(1, 10000).Draw(
                        t, "numBlocks"),
                ),
                ExtraData: RandExtraOpaqueData(t, nil),
        }

        // Generate chain hash
        chainHash := RandChainHash(t)
        var chainHashObj chainhash.Hash
        copy(chainHashObj[:], chainHash[:])
        msg.ChainHash = chainHashObj

        // Randomly include QueryOptions
        if rapid.Bool().Draw(t, "includeQueryOptions") </span><span class="cov0" title="0">{
                queryOptions := &amp;QueryOptions{}
                *queryOptions = QueryOptions(*RandFeatureVector(t))
                msg.QueryOptions = queryOptions
        }</span>

        <span class="cov0" title="0">return msg</span>
}

// A compile time check to ensure QueryShortChanIDs implements the
// lnwire.TestMessage interface.
var _ TestMessage = (*QueryShortChanIDs)(nil)

// RandTestMessage populates the message with random data suitable for testing.
// It uses the rapid testing framework to generate random values.
//
// This is part of the TestMessage interface.
func (q *QueryShortChanIDs) RandTestMessage(t *rapid.T) Message <span class="cov0" title="0">{
        var chainHash chainhash.Hash
        hashBytes := rapid.SliceOfN(rapid.Byte(), 32, 32).Draw(t, "chainHash")
        copy(chainHash[:], hashBytes)

        encodingType := EncodingSortedPlain
        if rapid.Bool().Draw(t, "useZlibEncoding") </span><span class="cov0" title="0">{
                encodingType = EncodingSortedZlib
        }</span>

        <span class="cov0" title="0">msg := &amp;QueryShortChanIDs{
                ChainHash:    chainHash,
                EncodingType: encodingType,
                ExtraData:    RandExtraOpaqueData(t, nil),
                noSort:       false,
        }

        numIDs := rapid.IntRange(2, 20).Draw(t, "numShortChanIDs")

        // Generate sorted short channel IDs.
        shortChanIDs := make([]ShortChannelID, numIDs)
        for i := 0; i &lt; numIDs; i++ </span><span class="cov0" title="0">{
                shortChanIDs[i] = RandShortChannelID(t)

                // Ensure they're properly sorted.
                if i &gt; 0 &amp;&amp; shortChanIDs[i].ToUint64() &lt;=
                        shortChanIDs[i-1].ToUint64() </span><span class="cov0" title="0">{

                        // Ensure this ID is larger than the previous one.
                        shortChanIDs[i] = NewShortChanIDFromInt(
                                shortChanIDs[i-1].ToUint64() + 1,
                        )
                }</span>
        }

        <span class="cov0" title="0">msg.ShortChanIDs = shortChanIDs

        return msg</span>
}

// A compile time check to ensure ReplyChannelRange implements the
// lnwire.TestMessage interface.
var _ TestMessage = (*ReplyChannelRange)(nil)

// RandTestMessage populates the message with random data suitable for testing.
// It uses the rapid testing framework to generate random values.
//
// This is part of the TestMessage interface.
func (c *ReplyChannelRange) RandTestMessage(t *rapid.T) Message <span class="cov0" title="0">{
        msg := &amp;ReplyChannelRange{
                FirstBlockHeight: uint32(rapid.IntRange(0, 1000000).Draw(
                        t, "firstBlockHeight"),
                ),
                NumBlocks: uint32(rapid.IntRange(1, 10000).Draw(
                        t, "numBlocks"),
                ),
                Complete: uint8(rapid.IntRange(0, 1).Draw(t, "complete")),
                EncodingType: QueryEncoding(
                        rapid.IntRange(0, 1).Draw(t, "encodingType"),
                ),
                ExtraData: RandExtraOpaqueData(t, nil),
        }

        msg.ChainHash = RandChainHash(t)

        numShortChanIDs := rapid.IntRange(0, 20).Draw(t, "numShortChanIDs")
        if numShortChanIDs == 0 </span><span class="cov0" title="0">{
                return msg
        }</span>

        <span class="cov0" title="0">scidSet := fn.NewSet[ShortChannelID]()
        scids := make([]ShortChannelID, numShortChanIDs)
        for i := 0; i &lt; numShortChanIDs; i++ </span><span class="cov0" title="0">{
                scid := RandShortChannelID(t)
                for scidSet.Contains(scid) </span><span class="cov0" title="0">{
                        scid = RandShortChannelID(t)
                }</span>

                <span class="cov0" title="0">scids[i] = scid

                scidSet.Add(scid)</span>
        }

        // Make sure there're no duplicates.
        <span class="cov0" title="0">msg.ShortChanIDs = scids

        if rapid.Bool().Draw(t, "includeTimestamps") &amp;&amp; numShortChanIDs &gt; 0 </span><span class="cov0" title="0">{
                msg.Timestamps = make(Timestamps, numShortChanIDs)
                for i := 0; i &lt; numShortChanIDs; i++ </span><span class="cov0" title="0">{
                        msg.Timestamps[i] = ChanUpdateTimestamps{
                                Timestamp1: uint32(rapid.IntRange(0, math.MaxInt32).Draw(t, fmt.Sprintf("timestamp-1-%d", i))), //nolint:ll
                                Timestamp2: uint32(rapid.IntRange(0, math.MaxInt32).Draw(t, fmt.Sprintf("timestamp-2-%d", i))), //nolint:ll
                        }
                }</span>
        }

        <span class="cov0" title="0">return msg</span>
}

// A compile time check to ensure ReplyShortChanIDsEnd implements the
// lnwire.TestMessage interface.
var _ TestMessage = (*ReplyShortChanIDsEnd)(nil)

// RandTestMessage populates the message with random data suitable for testing.
// It uses the rapid testing framework to generate random values.
//
// This is part of the TestMessage interface.
func (c *ReplyShortChanIDsEnd) RandTestMessage(t *rapid.T) Message <span class="cov0" title="0">{
        var chainHash chainhash.Hash
        hashBytes := rapid.SliceOfN(rapid.Byte(), 32, 32).Draw(t, "chainHash")
        copy(chainHash[:], hashBytes)

        complete := uint8(rapid.IntRange(0, 1).Draw(t, "complete"))

        return &amp;ReplyShortChanIDsEnd{
                ChainHash: chainHash,
                Complete:  complete,
                ExtraData: RandExtraOpaqueData(t, nil),
        }
}</span>

// RandTestMessage returns a RevokeAndAck message populated with random data.
//
// This is part of the TestMessage interface.
func (c *RevokeAndAck) RandTestMessage(t *rapid.T) Message <span class="cov0" title="0">{
        msg := NewRevokeAndAck()

        var chanID ChannelID
        bytes := rapid.SliceOfN(rapid.Byte(), 32, 32).Draw(t, "channelID")
        copy(chanID[:], bytes)
        msg.ChanID = chanID

        revBytes := rapid.SliceOfN(rapid.Byte(), 32, 32).Draw(t, "revocation")
        copy(msg.Revocation[:], revBytes)

        msg.NextRevocationKey = RandPubKey(t)

        if rapid.Bool().Draw(t, "includeLocalNonce") </span><span class="cov0" title="0">{
                var nonce Musig2Nonce
                nonceBytes := rapid.SliceOfN(rapid.Byte(), 32, 32).Draw(
                        t, "nonce",
                )
                copy(nonce[:], nonceBytes)

                msg.LocalNonce = tlv.SomeRecordT(
                        tlv.NewRecordT[NonceRecordTypeT, Musig2Nonce](nonce),
                )
        }</span>

        <span class="cov0" title="0">return msg</span>
}

// A compile-time check to ensure Shutdown implements the lnwire.TestMessage
// interface.
var _ TestMessage = (*Shutdown)(nil)

// RandTestMessage populates the message with random data suitable for testing.
// It uses the rapid testing framework to generate random values.
//
// This is part of the TestMessage interface.
func (s *Shutdown) RandTestMessage(t *rapid.T) Message <span class="cov0" title="0">{
        // Generate random delivery address
        // First decide the address type (P2PKH, P2SH, P2WPKH, P2WSH, P2TR)
        addrType := rapid.IntRange(0, 4).Draw(t, "addrType")

        // Generate random address length based on type
        var addrLen int
        switch addrType </span>{
        // P2PKH
        case 0:<span class="cov0" title="0">
                addrLen = 25</span>
        // P2SH
        case 1:<span class="cov0" title="0">
                addrLen = 23</span>
        // P2WPKH
        case 2:<span class="cov0" title="0">
                addrLen = 22</span>
        // P2WSH
        case 3:<span class="cov0" title="0">
                addrLen = 34</span>
        // P2TR
        case 4:<span class="cov0" title="0">
                addrLen = 34</span>
        }

        <span class="cov0" title="0">addr := rapid.SliceOfN(rapid.Byte(), addrLen, addrLen).Draw(
                t, "address",
        )

        // Randomly decide whether to include a shutdown nonce
        includeNonce := rapid.Bool().Draw(t, "includeNonce")
        var shutdownNonce ShutdownNonceTLV

        if includeNonce </span><span class="cov0" title="0">{
                shutdownNonce = SomeShutdownNonce(RandMusig2Nonce(t))
        }</span>

        <span class="cov0" title="0">cr, _ := RandCustomRecords(t, nil, true)

        return &amp;Shutdown{
                ChannelID:     RandChannelID(t),
                Address:       addr,
                ShutdownNonce: shutdownNonce,
                CustomRecords: cr,
        }</span>
}

// A compile time check to ensure Stfu implements the lnwire.TestMessage
// interface.
var _ TestMessage = (*Stfu)(nil)

// RandTestMessage populates the message with random data suitable for testing.
// It uses the rapid testing framework to generate random values.
//
// This is part of the TestMessage interface.
func (s *Stfu) RandTestMessage(t *rapid.T) Message <span class="cov0" title="0">{
        m := &amp;Stfu{
                ChanID:    RandChannelID(t),
                Initiator: rapid.Bool().Draw(t, "initiator"),
        }

        extraData := RandExtraOpaqueData(t, nil)
        if len(extraData) &gt; 0 </span><span class="cov0" title="0">{
                m.ExtraData = extraData
        }</span>

        <span class="cov0" title="0">return m</span>
}

// A compile time check to ensure UpdateAddHTLC implements the
// lnwire.TestMessage interface.
var _ TestMessage = (*UpdateAddHTLC)(nil)

// RandTestMessage returns an UpdateAddHTLC message populated with random data.
//
// This is part of the TestMessage interface.
func (c *UpdateAddHTLC) RandTestMessage(t *rapid.T) Message <span class="cov0" title="0">{
        msg := &amp;UpdateAddHTLC{
                ChanID: RandChannelID(t),
                ID:     rapid.Uint64().Draw(t, "id"),
                Amount: MilliSatoshi(rapid.Uint64().Draw(t, "amount")),
                Expiry: rapid.Uint32().Draw(t, "expiry"),
        }

        hashBytes := rapid.SliceOfN(rapid.Byte(), 32, 32).Draw(t, "paymentHash")
        copy(msg.PaymentHash[:], hashBytes)

        onionBytes := rapid.SliceOfN(
                rapid.Byte(), OnionPacketSize, OnionPacketSize,
        ).Draw(t, "onionBlob")
        copy(msg.OnionBlob[:], onionBytes)

        numRecords := rapid.IntRange(0, 5).Draw(t, "numRecords")
        if numRecords &gt; 0 </span><span class="cov0" title="0">{
                msg.CustomRecords, _ = RandCustomRecords(t, nil, true)
        }</span>

        // 50/50 chance to add a blinding point
        <span class="cov0" title="0">if rapid.Bool().Draw(t, "includeBlindingPoint") </span><span class="cov0" title="0">{
                pubKey := RandPubKey(t)

                msg.BlindingPoint = tlv.SomeRecordT(
                        tlv.NewPrimitiveRecord[BlindingPointTlvType](pubKey),
                )
        }</span>

        <span class="cov0" title="0">return msg</span>
}

// A compile time check to ensure UpdateFailHTLC implements the TestMessage
// interface.
var _ TestMessage = (*UpdateFailHTLC)(nil)

// RandTestMessage populates the message with random data suitable for testing.
// It uses the rapid testing framework to generate random values.
//
// This is part of the TestMessage interface.
func (c *UpdateFailHTLC) RandTestMessage(t *rapid.T) Message <span class="cov0" title="0">{
        return &amp;UpdateFailHTLC{
                ChanID:    RandChannelID(t),
                ID:        rapid.Uint64().Draw(t, "id"),
                Reason:    RandOpaqueReason(t),
                ExtraData: RandExtraOpaqueData(t, nil),
        }
}</span>

// A compile time check to ensure UpdateFailMalformedHTLC implements the
// TestMessage interface.
var _ TestMessage = (*UpdateFailMalformedHTLC)(nil)

// RandTestMessage populates the message with random data suitable for testing.
// It uses the rapid testing framework to generate random values.
//
// This is part of the TestMessage interface.
func (c *UpdateFailMalformedHTLC) RandTestMessage(t *rapid.T) Message <span class="cov0" title="0">{
        return &amp;UpdateFailMalformedHTLC{
                ChanID:       RandChannelID(t),
                ID:           rapid.Uint64().Draw(t, "id"),
                ShaOnionBlob: RandSHA256Hash(t),
                FailureCode:  RandFailCode(t),
                ExtraData:    RandExtraOpaqueData(t, nil),
        }
}</span>

// A compile time check to ensure UpdateFee implements the TestMessage
// interface.
var _ TestMessage = (*UpdateFee)(nil)

// RandTestMessage populates the message with random data suitable for testing.
// It uses the rapid testing framework to generate random values.
//
// This is part of the TestMessage interface.
func (c *UpdateFee) RandTestMessage(t *rapid.T) Message <span class="cov0" title="0">{
        return &amp;UpdateFee{
                ChanID:    RandChannelID(t),
                FeePerKw:  uint32(rapid.IntRange(1, 10000).Draw(t, "feePerKw")),
                ExtraData: RandExtraOpaqueData(t, nil),
        }
}</span>

// A compile time check to ensure UpdateFulfillHTLC implements the TestMessage
// interface.
var _ TestMessage = (*UpdateFulfillHTLC)(nil)

// RandTestMessage populates the message with random data suitable for testing.
// It uses the rapid testing framework to generate random values.
//
// This is part of the TestMessage interface.
func (c *UpdateFulfillHTLC) RandTestMessage(t *rapid.T) Message <span class="cov0" title="0">{
        msg := &amp;UpdateFulfillHTLC{
                ChanID:          RandChannelID(t),
                ID:              rapid.Uint64().Draw(t, "id"),
                PaymentPreimage: RandPaymentPreimage(t),
        }

        cr, ignoreRecords := RandCustomRecords(t, nil, true)
        msg.CustomRecords = cr

        randData := RandExtraOpaqueData(t, ignoreRecords)
        if len(randData) &gt; 0 </span><span class="cov0" title="0">{
                msg.ExtraData = randData
        }</span>

        <span class="cov0" title="0">return msg</span>
}

// A compile time check to ensure Warning implements the lnwire.TestMessage
// interface.
var _ TestMessage = (*Warning)(nil)

// RandTestMessage populates the message with random data suitable for testing.
// It uses the rapid testing framework to generate random values.
//
// This is part of the TestMessage interface.
func (c *Warning) RandTestMessage(t *rapid.T) Message <span class="cov0" title="0">{
        msg := &amp;Warning{
                ChanID: RandChannelID(t),
        }

        useASCII := rapid.Bool().Draw(t, "useASCII")
        if useASCII </span><span class="cov0" title="0">{
                length := rapid.IntRange(1, 100).Draw(t, "warningDataLength")
                data := make([]byte, length)
                for i := 0; i &lt; length; i++ </span><span class="cov0" title="0">{
                        data[i] = byte(
                                rapid.IntRange(32, 126).Draw(
                                        t, fmt.Sprintf("warningDataByte-%d", i),
                                ),
                        )
                }</span>
                <span class="cov0" title="0">msg.Data = data</span>
        } else<span class="cov0" title="0"> {
                length := rapid.IntRange(1, 100).Draw(t, "warningDataLength")
                msg.Data = rapid.SliceOfN(rapid.Byte(), length, length).Draw(
                        t, "warningData",
                )
        }</span>

        <span class="cov0" title="0">return msg</span>
}

// A compile time check to ensure Error implements the lnwire.TestMessage
// interface.
var _ TestMessage = (*Error)(nil)

// RandTestMessage populates the message with random data suitable for testing.
// It uses the rapid testing framework to generate random values.
//
// This is part of the TestMessage interface.
func (c *Error) RandTestMessage(t *rapid.T) Message <span class="cov0" title="0">{
        msg := &amp;Error{
                ChanID: RandChannelID(t),
        }

        useASCII := rapid.Bool().Draw(t, "useASCII")
        if useASCII </span><span class="cov0" title="0">{
                length := rapid.IntRange(1, 100).Draw(t, "errorDataLength")
                data := make([]byte, length)
                for i := 0; i &lt; length; i++ </span><span class="cov0" title="0">{
                        data[i] = byte(
                                rapid.IntRange(32, 126).Draw(
                                        t, fmt.Sprintf("errorDataByte-%d", i),
                                ),
                        )
                }</span>
                <span class="cov0" title="0">msg.Data = data</span>
        } else<span class="cov0" title="0"> {
                // Generate random binary data
                length := rapid.IntRange(1, 100).Draw(t, "errorDataLength")
                msg.Data = rapid.SliceOfN(
                        rapid.Byte(), length, length,
                ).Draw(t, "errorData")
        }</span>

        <span class="cov0" title="0">return msg</span>
}
</pre>
		
		<pre class="file" id="file102" style="display: none">package lnwire

import (
        "crypto/sha256"
        "fmt"
        "net"

        "github.com/btcsuite/btcd/btcec/v2"
        "github.com/btcsuite/btcd/btcec/v2/ecdsa"
        "github.com/btcsuite/btcd/chaincfg/chainhash"
        "github.com/btcsuite/btcd/wire"
        "github.com/lightningnetwork/lnd/fn/v2"
        "github.com/stretchr/testify/require"
        "pgregory.net/rapid"
)

// RandChannelUpdate generates a random ChannelUpdate message using rapid's
// generators.
func RandPartialSig(t *rapid.T) *PartialSig <span class="cov0" title="0">{
        // Generate random private key bytes
        sigBytes := rapid.SliceOfN(rapid.Byte(), 32, 32).Draw(t, "privKeyBytes")

        var s btcec.ModNScalar
        s.SetByteSlice(sigBytes)

        return &amp;PartialSig{
                Sig: s,
        }
}</span>

// RandPartialSigWithNonce generates a random PartialSigWithNonce using rapid
// generators.
func RandPartialSigWithNonce(t *rapid.T) *PartialSigWithNonce <span class="cov0" title="0">{
        sigLen := rapid.IntRange(1, 65).Draw(t, "partialSigLen")
        sigBytes := rapid.SliceOfN(
                rapid.Byte(), sigLen, sigLen,
        ).Draw(t, "partialSig")

        sigScalar := new(btcec.ModNScalar)
        sigScalar.SetByteSlice(sigBytes)

        return NewPartialSigWithNonce(
                RandMusig2Nonce(t), *sigScalar,
        )
}</span>

// RandPubKey generates a random public key using rapid's generators.
func RandPubKey(t *rapid.T) *btcec.PublicKey <span class="cov0" title="0">{
        privKeyBytes := rapid.SliceOfN(rapid.Byte(), 32, 32).Draw(
                t, "privKeyBytes",
        )
        _, pub := btcec.PrivKeyFromBytes(privKeyBytes)

        return pub
}</span>

// RandChannelID generates a random channel ID.
func RandChannelID(t *rapid.T) ChannelID <span class="cov0" title="0">{
        var c ChannelID
        bytes := rapid.SliceOfN(rapid.Byte(), 32, 32).Draw(t, "channelID")
        copy(c[:], bytes)

        return c
}</span>

// RandShortChannelID generates a random short channel ID.
func RandShortChannelID(t *rapid.T) ShortChannelID <span class="cov0" title="0">{
        return NewShortChanIDFromInt(
                uint64(rapid.IntRange(1, 100000).Draw(t, "shortChanID")),
        )
}</span>

// RandFeatureVector generates a random feature vector.
func RandFeatureVector(t *rapid.T) *RawFeatureVector <span class="cov0" title="0">{
        featureVec := NewRawFeatureVector()

        // Add a random number of random feature bits
        numFeatures := rapid.IntRange(0, 20).Draw(t, "numFeatures")
        for i := 0; i &lt; numFeatures; i++ </span><span class="cov0" title="0">{
                bit := FeatureBit(rapid.IntRange(0, 100).Draw(
                        t, fmt.Sprintf("featureBit-%d", i)),
                )
                featureVec.Set(bit)
        }</span>

        <span class="cov0" title="0">return featureVec</span>
}

// RandSignature generates a signature for testing.
func RandSignature(t *rapid.T) Sig <span class="cov0" title="0">{
        testRScalar := new(btcec.ModNScalar)
        testSScalar := new(btcec.ModNScalar)

        // Generate random bytes for R and S
        rBytes := rapid.SliceOfN(rapid.Byte(), 32, 32).Draw(t, "rBytes")
        sBytes := rapid.SliceOfN(rapid.Byte(), 32, 32).Draw(t, "sBytes")
        _ = testRScalar.SetByteSlice(rBytes)
        _ = testSScalar.SetByteSlice(sBytes)

        testSig := ecdsa.NewSignature(testRScalar, testSScalar)

        sig, err := NewSigFromSignature(testSig)
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("unable to create signature: %v", err))</span>
        }

        <span class="cov0" title="0">return sig</span>
}

// RandPaymentHash generates a random payment hash.
func RandPaymentHash(t *rapid.T) [32]byte <span class="cov0" title="0">{
        var hash [32]byte
        bytes := rapid.SliceOfN(rapid.Byte(), 32, 32).Draw(t, "paymentHash")
        copy(hash[:], bytes)

        return hash
}</span>

// RandPaymentPreimage generates a random payment preimage.
func RandPaymentPreimage(t *rapid.T) [32]byte <span class="cov0" title="0">{
        var preimage [32]byte
        bytes := rapid.SliceOfN(rapid.Byte(), 32, 32).Draw(t, "preimage")
        copy(preimage[:], bytes)

        return preimage
}</span>

// RandChainHash generates a random chain hash.
func RandChainHash(t *rapid.T) chainhash.Hash <span class="cov0" title="0">{
        var hash [32]byte
        bytes := rapid.SliceOfN(rapid.Byte(), 32, 32).Draw(t, "chainHash")
        copy(hash[:], bytes)

        return hash
}</span>

// RandNodeAlias generates a random node alias.
func RandNodeAlias(t *rapid.T) NodeAlias <span class="cov0" title="0">{
        var alias NodeAlias
        aliasLength := rapid.IntRange(0, 32).Draw(t, "aliasLength")

        aliasBytes := rapid.StringN(
                0, aliasLength, aliasLength,
        ).Draw(t, "alias")

        copy(alias[:], aliasBytes)

        return alias
}</span>

// RandNetAddrs generates random network addresses.
func RandNetAddrs(t *rapid.T) []net.Addr <span class="cov0" title="0">{
        numAddresses := rapid.IntRange(0, 5).Draw(t, "numAddresses")
        if numAddresses == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">addresses := make([]net.Addr, numAddresses)
        for i := 0; i &lt; numAddresses; i++ </span><span class="cov0" title="0">{
                addressType := rapid.IntRange(0, 1).Draw(
                        t, fmt.Sprintf("addressType-%d", i),
                )

                switch addressType </span>{
                // IPv4.
                case 0:<span class="cov0" title="0">
                        ipBytes := rapid.SliceOfN(rapid.Byte(), 4, 4).Draw(
                                t, fmt.Sprintf("ipv4-%d", i),
                        )
                        port := rapid.IntRange(1, 65535).Draw(
                                t, fmt.Sprintf("port-%d", i),
                        )
                        addresses[i] = &amp;net.TCPAddr{
                                IP:   ipBytes,
                                Port: port,
                        }</span>

                // IPv6.
                case 1:<span class="cov0" title="0">
                        ipBytes := rapid.SliceOfN(rapid.Byte(), 16, 16).Draw(
                                t, fmt.Sprintf("ipv6-%d", i),
                        )
                        port := rapid.IntRange(1, 65535).Draw(
                                t, fmt.Sprintf("port-%d", i),
                        )
                        addresses[i] = &amp;net.TCPAddr{
                                IP:   ipBytes,
                                Port: port,
                        }</span>
                }
        }

        <span class="cov0" title="0">return addresses</span>
}

// RandCustomRecords generates random custom TLV records.
func RandCustomRecords(t *rapid.T,
        ignoreRecords fn.Set[uint64],
        custom bool) (CustomRecords, fn.Set[uint64]) <span class="cov0" title="0">{

        numRecords := rapid.IntRange(0, 5).Draw(t, "numCustomRecords")
        customRecords := make(CustomRecords)

        if numRecords == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">rangeStart := 0
        rangeStop := int(CustomTypeStart)
        if custom </span><span class="cov0" title="0">{
                rangeStart = 70_000
                rangeStop = 100_000
        }</span>

        <span class="cov0" title="0">ignoreSet := fn.NewSet[uint64]()
        for i := 0; i &lt; numRecords; i++ </span><span class="cov0" title="0">{
                recordType := uint64(
                        rapid.IntRange(rangeStart, rangeStop).
                                Filter(func(i int) bool </span><span class="cov0" title="0">{
                                        return !ignoreRecords.Contains(
                                                uint64(i),
                                        )
                                }</span>).
                                Draw(
                                        t, fmt.Sprintf("recordType-%d", i),
                                ),
                )
                <span class="cov0" title="0">recordLen := rapid.IntRange(4, 64).Draw(
                        t, fmt.Sprintf("recordLen-%d", i),
                )
                record := rapid.SliceOfN(
                        rapid.Byte(), recordLen, recordLen,
                ).Draw(t, fmt.Sprintf("record-%d", i))

                customRecords[recordType] = record

                ignoreSet.Add(recordType)</span>
        }

        <span class="cov0" title="0">return customRecords, ignoreSet</span>
}

// RandMusig2Nonce generates a random musig2 nonce.
func RandMusig2Nonce(t *rapid.T) Musig2Nonce <span class="cov0" title="0">{
        var nonce Musig2Nonce
        bytes := rapid.SliceOfN(rapid.Byte(), 32, 32).Draw(t, "nonce")
        copy(nonce[:], bytes)

        return nonce
}</span>

// RandExtraOpaqueData generates random extra opaque data.
func RandExtraOpaqueData(t *rapid.T,
        ignoreRecords fn.Set[uint64]) ExtraOpaqueData <span class="cov0" title="0">{

        // Make some random records.
        cRecords, _ := RandCustomRecords(t, ignoreRecords, false)
        if cRecords == nil </span><span class="cov0" title="0">{
                return ExtraOpaqueData{}
        }</span>

        // Encode those records as opaque data.
        <span class="cov0" title="0">recordBytes, err := cRecords.Serialize()
        require.NoError(t, err)

        return ExtraOpaqueData(recordBytes)</span>
}

// RandOpaqueReason generates a random opaque reason for HTLC failures.
func RandOpaqueReason(t *rapid.T) OpaqueReason <span class="cov0" title="0">{
        reasonLen := rapid.IntRange(32, 300).Draw(t, "reasonLen")
        return rapid.SliceOfN(rapid.Byte(), reasonLen, reasonLen).Draw(
                t, "opaqueReason",
        )
}</span>

// RandFailCode generates a random HTLC failure code.
func RandFailCode(t *rapid.T) FailCode <span class="cov0" title="0">{
        // List of known failure codes to choose from Using only the documented
        // codes.
        validCodes := []FailCode{
                CodeInvalidRealm,
                CodeTemporaryNodeFailure,
                CodePermanentNodeFailure,
                CodeRequiredNodeFeatureMissing,
                CodePermanentChannelFailure,
                CodeRequiredChannelFeatureMissing,
                CodeUnknownNextPeer,
                CodeIncorrectOrUnknownPaymentDetails,
                CodeIncorrectPaymentAmount,
                CodeFinalExpiryTooSoon,
                CodeInvalidOnionVersion,
                CodeInvalidOnionHmac,
                CodeInvalidOnionKey,
                CodeTemporaryChannelFailure,
                CodeChannelDisabled,
                CodeExpiryTooSoon,
                CodeMPPTimeout,
                CodeInvalidOnionPayload,
                CodeFeeInsufficient,
        }

        // Choose a random code from the list.
        idx := rapid.IntRange(0, len(validCodes)-1).Draw(t, "failCodeIndex")

        return validCodes[idx]
}</span>

// RandSHA256Hash generates a random SHA256 hash.
func RandSHA256Hash(t *rapid.T) [sha256.Size]byte <span class="cov0" title="0">{
        var hash [sha256.Size]byte
        bytes := rapid.SliceOfN(rapid.Byte(), sha256.Size, sha256.Size).Draw(
                t, "sha256Hash",
        )
        copy(hash[:], bytes)

        return hash
}</span>

// RandDeliveryAddress generates a random delivery address (script).
func RandDeliveryAddress(t *rapid.T) DeliveryAddress <span class="cov0" title="0">{
        addrLen := rapid.IntRange(1, 34).Draw(t, "addrLen")

        return rapid.SliceOfN(rapid.Byte(), addrLen, addrLen).Draw(
                t, "deliveryAddress",
        )
}</span>

// RandChannelType generates a random channel type.
func RandChannelType(t *rapid.T) *ChannelType <span class="cov0" title="0">{
        vec := RandFeatureVector(t)
        chanType := ChannelType(*vec)

        return &amp;chanType
}</span>

// RandLeaseExpiry generates a random lease expiry.
func RandLeaseExpiry(t *rapid.T) *LeaseExpiry <span class="cov0" title="0">{
        exp := LeaseExpiry(
                uint32(rapid.IntRange(1000, 1000000).Draw(t, "leaseExpiry")),
        )

        return &amp;exp
}</span>

// RandOutPoint generates a random transaction outpoint.
func RandOutPoint(t *rapid.T) wire.OutPoint <span class="cov0" title="0">{
        // Generate a random transaction ID
        var txid chainhash.Hash
        txidBytes := rapid.SliceOfN(rapid.Byte(), 32, 32).Draw(t, "txid")
        copy(txid[:], txidBytes)

        // Generate a random output index
        vout := uint32(rapid.IntRange(0, 10).Draw(t, "vout"))

        return wire.OutPoint{
                Hash:  txid,
                Index: vout,
        }
}</span>
</pre>
		
		<pre class="file" id="file103" style="display: none">package lnwire

import (
        "bytes"
        "fmt"
        "io"

        "github.com/lightningnetwork/lnd/tlv"
)

const (
        // TimestampsRecordType is the TLV number of the timestamps TLV record
        // in the reply_channel_range message.
        TimestampsRecordType tlv.Type = 1

        // timestampPairSize is the number of bytes required to encode two
        // timestamps. Each timestamp is four bytes.
        timestampPairSize = 8
)

// Timestamps is a type representing the timestamps TLV field used in the
// reply_channel_range message to communicate the timestamps info of the updates
// of the SCID list being communicated.
type Timestamps []ChanUpdateTimestamps

// ChanUpdateTimestamps holds the timestamp info of the latest known channel
// updates corresponding to the two sides of a channel.
type ChanUpdateTimestamps struct {
        Timestamp1 uint32
        Timestamp2 uint32
}

// Record constructs the tlv.Record from the Timestamps.
func (t *Timestamps) Record() tlv.Record <span class="cov0" title="0">{
        return tlv.MakeDynamicRecord(
                TimestampsRecordType, t, t.encodedLen, timeStampsEncoder,
                timeStampsDecoder,
        )
}</span>

// encodedLen calculates the length of the encoded Timestamps.
func (t *Timestamps) encodedLen() uint64 <span class="cov0" title="0">{
        return uint64(1 + timestampPairSize*(len(*t)))
}</span>

// timeStampsEncoder encodes the Timestamps and writes the encoded bytes to the
// given writer.
func timeStampsEncoder(w io.Writer, val interface{}, _ *[8]byte) error <span class="cov0" title="0">{
        if v, ok := val.(*Timestamps); ok </span><span class="cov0" title="0">{
                var buf bytes.Buffer

                // Add the encoding byte.
                err := WriteQueryEncoding(&amp;buf, EncodingSortedPlain)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // For each timestamp, write 4 byte timestamp of node 1 and the
                // 4 byte timestamp of node 2.
                <span class="cov0" title="0">for _, timestamps := range *v </span><span class="cov0" title="0">{
                        err = WriteUint32(&amp;buf, timestamps.Timestamp1)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">err = WriteUint32(&amp;buf, timestamps.Timestamp2)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov0" title="0">_, err = w.Write(buf.Bytes())

                return err</span>
        }

        <span class="cov0" title="0">return tlv.NewTypeForEncodingErr(val, "lnwire.Timestamps")</span>
}

// timeStampsDecoder attempts to read and reconstruct a Timestamps object from
// the given reader.
func timeStampsDecoder(r io.Reader, val interface{}, _ *[8]byte,
        l uint64) error <span class="cov0" title="0">{

        if v, ok := val.(*Timestamps); ok </span><span class="cov0" title="0">{
                var encodingByte [1]byte
                if _, err := r.Read(encodingByte[:]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">encoding := QueryEncoding(encodingByte[0])
                if encoding != EncodingSortedPlain </span><span class="cov0" title="0">{
                        return fmt.Errorf("unsupported encoding: %x", encoding)
                }</span>

                // The number of timestamps bytes is equal to the passed length
                // minus one since the first byte is used for the encoding type.
                <span class="cov0" title="0">numTimestampBytes := l - 1

                if numTimestampBytes%timestampPairSize != 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("whole number of timestamps not " +
                                "encoded")
                }</span>

                <span class="cov0" title="0">numTimestamps := int(numTimestampBytes) / timestampPairSize
                timestamps := make(Timestamps, numTimestamps)
                for i := 0; i &lt; numTimestamps; i++ </span><span class="cov0" title="0">{
                        err := ReadElements(
                                r, &amp;timestamps[i].Timestamp1,
                                &amp;timestamps[i].Timestamp2,
                        )
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov0" title="0">*v = timestamps

                return nil</span>
        }

        <span class="cov0" title="0">return tlv.NewTypeForEncodingErr(val, "lnwire.Timestamps")</span>
}
</pre>
		
		<pre class="file" id="file104" style="display: none">package lnwire

import (
        "github.com/lightningnetwork/lnd/tlv"
)

const (
        // DeliveryAddrType is the TLV record type for delivery addreses within
        // the name space of the OpenChannel and AcceptChannel messages.
        DeliveryAddrType = 0

        // deliveryAddressMaxSize is the maximum expected size in bytes of a
        // DeliveryAddress based on the types of scripts we know.
        // Following are the known scripts and their sizes in bytes.
        // - pay to witness script hash: 34
        // - pay to pubkey hash: 25
        // - pay to script hash: 22
        // - pay to witness pubkey hash: 22.
        deliveryAddressMaxSize = 34
)

// DeliveryAddress is used to communicate the address to which funds from a
// closed channel should be sent. The address can be a p2wsh, p2pkh, p2sh or
// p2wpkh.
type DeliveryAddress []byte

// Record returns a TLV record that can be used to encode the delivery
// address within the ExtraData TLV stream. This was introduced in order to
// allow the OpenChannel/AcceptChannel messages to properly be extended with
// TLV types.
func (d *DeliveryAddress) Record() tlv.Record <span class="cov0" title="0">{
        addrBytes := (*[]byte)(d)

        return tlv.MakeDynamicRecord(
                DeliveryAddrType, addrBytes,
                func() uint64 </span><span class="cov0" title="0">{
                        return uint64(len(*addrBytes))
                }</span>,
                tlv.EVarBytes, tlv.DVarBytes,
        )
}
</pre>
		
		<pre class="file" id="file105" style="display: none">package lnwire

import (
        "io"

        "github.com/lightningnetwork/lnd/tlv"
)

const (
        FeeRecordType tlv.Type = 55555
)

// Fee represents a fee schedule.
type Fee struct {
        BaseFee int32
        FeeRate int32
}

// Record returns a TLV record that can be used to encode/decode the fee
// type from a given TLV stream.
func (l *Fee) Record() tlv.Record <span class="cov0" title="0">{
        return tlv.MakeStaticRecord(
                FeeRecordType, l, 8, feeEncoder, feeDecoder, //nolint:gomnd
        )
}</span>

// feeEncoder is a custom TLV encoder for the fee record.
func feeEncoder(w io.Writer, val interface{}, buf *[8]byte) error <span class="cov0" title="0">{
        v, ok := val.(*Fee)
        if !ok </span><span class="cov0" title="0">{
                return tlv.NewTypeForEncodingErr(val, "lnwire.Fee")
        }</span>

        <span class="cov0" title="0">if err := tlv.EUint32T(w, uint32(v.BaseFee), buf); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return tlv.EUint32T(w, uint32(v.FeeRate), buf)</span>
}

// feeDecoder is a custom TLV decoder for the fee record.
func feeDecoder(r io.Reader, val interface{}, buf *[8]byte, l uint64) error <span class="cov0" title="0">{
        v, ok := val.(*Fee)
        if !ok </span><span class="cov0" title="0">{
                return tlv.NewTypeForDecodingErr(val, "lnwire.Fee", l, 8)
        }</span>

        <span class="cov0" title="0">var baseFee, feeRate uint32
        if err := tlv.DUint32(r, &amp;baseFee, buf, 4); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := tlv.DUint32(r, &amp;feeRate, buf, 4); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">v.FeeRate = int32(feeRate)
        v.BaseFee = int32(baseFee)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file106" style="display: none">package lnwire

import (
        "io"

        "github.com/lightningnetwork/lnd/tlv"
)

const (
        // LeaseExpiryType is the type of the experimental record used to
        // communicate the expiration of a channel lease throughout the channel
        // funding process.
        //
        // TODO: Decide on actual TLV type. Custom records start at 2^16.
        LeaseExpiryRecordType tlv.Type = 1 &lt;&lt; 16
)

// LeaseExpiry represents the absolute expiration height of a channel lease. All
// outputs that pay directly to the channel initiator are locked until this
// height is reached.
type LeaseExpiry uint32

// Record returns a TLV record that can be used to encode/decode the LeaseExpiry
// type from a given TLV stream.
func (l *LeaseExpiry) Record() tlv.Record <span class="cov0" title="0">{
        return tlv.MakeStaticRecord(
                LeaseExpiryRecordType, l, 4, leaseExpiryEncoder, leaseExpiryDecoder,
        )
}</span>

// leaseExpiryEncoder is a custom TLV encoder for the LeaseExpiry record.
func leaseExpiryEncoder(w io.Writer, val interface{}, buf *[8]byte) error <span class="cov0" title="0">{
        if v, ok := val.(*LeaseExpiry); ok </span><span class="cov0" title="0">{
                return tlv.EUint32T(w, uint32(*v), buf)
        }</span>

        <span class="cov0" title="0">return tlv.NewTypeForEncodingErr(val, "lnwire.LeaseExpiry")</span>
}

// leaseExpiryDecoder is a custom TLV decoder for the LeaseExpiry record.
func leaseExpiryDecoder(r io.Reader, val interface{}, buf *[8]byte, l uint64) error <span class="cov0" title="0">{
        if v, ok := val.(*LeaseExpiry); ok </span><span class="cov0" title="0">{
                var leaseExpiry uint32
                if err := tlv.DUint32(r, &amp;leaseExpiry, buf, l); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">*v = LeaseExpiry(leaseExpiry)
                return nil</span>
        }

        <span class="cov0" title="0">return tlv.NewTypeForEncodingErr(val, "lnwire.LeaseExpiry")</span>
}
</pre>
		
		<pre class="file" id="file107" style="display: none">package lnwire

import (
        "bytes"
        "io"

        "github.com/btcsuite/btcd/btcec/v2"
        "github.com/lightningnetwork/lnd/tlv"
)

const (
        // OnionPacketSize is the size of the serialized Sphinx onion packet
        // included in each UpdateAddHTLC message. The breakdown of the onion
        // packet is as follows: 1-byte version, 33-byte ephemeral public key
        // (for ECDH), 1300-bytes of per-hop data, and a 32-byte HMAC over the
        // entire packet.
        OnionPacketSize = 1366

        // ExperimentalEndorsementType is the TLV type used for a custom
        // record that sets an experimental endorsement value.
        ExperimentalEndorsementType tlv.Type = 106823

        // ExperimentalUnendorsed is the value that the experimental endorsement
        // field contains when a htlc is not endorsed.
        ExperimentalUnendorsed = 0

        // ExperimentalEndorsed is the value that the experimental endorsement
        // field contains when a htlc is endorsed. We're using a single byte
        // to represent our endorsement value, but limit the value to using
        // the first three bits (max value = 00000111). Interpreted as a uint8
        // (an alias for byte in go), we can just define this constant as 7.
        ExperimentalEndorsed = 7
)

type (
        // BlindingPointTlvType is the type for ephemeral pubkeys used in
        // route blinding.
        BlindingPointTlvType = tlv.TlvType0

        // BlindingPointRecord holds an optional blinding point on update add
        // htlc.
        //nolint:ll
        BlindingPointRecord = tlv.OptionalRecordT[BlindingPointTlvType, *btcec.PublicKey]
)

// UpdateAddHTLC is the message sent by Alice to Bob when she wishes to add an
// HTLC to his remote commitment transaction. In addition to information
// detailing the value, the ID, expiry, and the onion blob is also included
// which allows Bob to derive the next hop in the route. The HTLC added by this
// message is to be added to the remote node's "pending" HTLCs.  A subsequent
// CommitSig message will move the pending HTLC to the newly created commitment
// transaction, marking them as "staged".
type UpdateAddHTLC struct {
        // ChanID is the particular active channel that this UpdateAddHTLC is
        // bound to.
        ChanID ChannelID

        // ID is the identification server for this HTLC. This value is
        // explicitly included as it allows nodes to survive single-sided
        // restarts. The ID value for this sides starts at zero, and increases
        // with each offered HTLC.
        ID uint64

        // Amount is the amount of millisatoshis this HTLC is worth.
        Amount MilliSatoshi

        // PaymentHash is the payment hash to be included in the HTLC this
        // request creates. The pre-image to this HTLC must be revealed by the
        // upstream peer in order to fully settle the HTLC.
        PaymentHash [32]byte

        // Expiry is the number of blocks after which this HTLC should expire.
        // It is the receiver's duty to ensure that the outgoing HTLC has a
        // sufficient expiry value to allow her to redeem the incoming HTLC.
        Expiry uint32

        // OnionBlob is the raw serialized mix header used to route an HTLC in
        // a privacy-preserving manner. The mix header is defined currently to
        // be parsed as a 4-tuple: (groupElement, routingInfo, headerMAC,
        // body).  First the receiving node should use the groupElement, and
        // its current onion key to derive a shared secret with the source.
        // Once the shared secret has been derived, the headerMAC should be
        // checked FIRST. Note that the MAC only covers the routingInfo field.
        // If the MAC matches, and the shared secret is fresh, then the node
        // should strip off a layer of encryption, exposing the next hop to be
        // used in the subsequent UpdateAddHTLC message.
        OnionBlob [OnionPacketSize]byte

        // BlindingPoint is the ephemeral pubkey used to optionally blind the
        // next hop for this htlc.
        BlindingPoint BlindingPointRecord

        // CustomRecords maps TLV types to byte slices, storing arbitrary data
        // intended for inclusion in the ExtraData field of the UpdateAddHTLC
        // message.
        CustomRecords CustomRecords

        // ExtraData is the set of data that was appended to this message to
        // fill out the full maximum transport message size. These fields can
        // be used to specify optional data such as custom TLV fields.
        ExtraData ExtraOpaqueData
}

// NewUpdateAddHTLC returns a new empty UpdateAddHTLC message.
func NewUpdateAddHTLC() *UpdateAddHTLC <span class="cov0" title="0">{
        return &amp;UpdateAddHTLC{}
}</span>

// A compile time check to ensure UpdateAddHTLC implements the lnwire.Message
// interface.
var _ Message = (*UpdateAddHTLC)(nil)

// Decode deserializes a serialized UpdateAddHTLC message stored in the passed
// io.Reader observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (c *UpdateAddHTLC) Decode(r io.Reader, pver uint32) error <span class="cov0" title="0">{
        // msgExtraData is a temporary variable used to read the message extra
        // data field from the reader.
        var msgExtraData ExtraOpaqueData

        if err := ReadElements(r,
                &amp;c.ChanID,
                &amp;c.ID,
                &amp;c.Amount,
                c.PaymentHash[:],
                &amp;c.Expiry,
                c.OnionBlob[:],
                &amp;msgExtraData,
        ); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Extract TLV records from the extra data field.
        <span class="cov0" title="0">blindingRecord := c.BlindingPoint.Zero()

        customRecords, parsed, extraData, err := ParseAndExtractCustomRecords(
                msgExtraData, &amp;blindingRecord,
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Assign the parsed records back to the message.
        <span class="cov0" title="0">if parsed.Contains(blindingRecord.TlvType()) </span><span class="cov0" title="0">{
                c.BlindingPoint = tlv.SomeRecordT(blindingRecord)
        }</span>

        <span class="cov0" title="0">c.CustomRecords = customRecords
        c.ExtraData = extraData

        return nil</span>
}

// Encode serializes the target UpdateAddHTLC into the passed io.Writer
// observing the protocol version specified.
//
// This is part of the lnwire.Message interface.
func (c *UpdateAddHTLC) Encode(w *bytes.Buffer, pver uint32) error <span class="cov0" title="0">{
        if err := WriteChannelID(w, c.ChanID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteUint64(w, c.ID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteMilliSatoshi(w, c.Amount); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteBytes(w, c.PaymentHash[:]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteUint32(w, c.Expiry); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteBytes(w, c.OnionBlob[:]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Only include blinding point in extra data if present.
        <span class="cov0" title="0">var records []tlv.RecordProducer
        c.BlindingPoint.WhenSome(
                func(b tlv.RecordT[BlindingPointTlvType, *btcec.PublicKey]) </span><span class="cov0" title="0">{
                        records = append(records, &amp;b)
                }</span>,
        )

        <span class="cov0" title="0">extraData, err := MergeAndEncode(records, c.ExtraData, c.CustomRecords)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return WriteBytes(w, extraData)</span>
}

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (c *UpdateAddHTLC) MsgType() MessageType <span class="cov0" title="0">{
        return MsgUpdateAddHTLC
}</span>

// TargetChanID returns the channel id of the link for which this message is
// intended.
//
// NOTE: Part of peer.LinkUpdater interface.
func (c *UpdateAddHTLC) TargetChanID() ChannelID <span class="cov0" title="0">{
        return c.ChanID
}</span>

// SerializedSize returns the serialized size of the message in bytes.
//
// This is part of the lnwire.SizeableMessage interface.
func (c *UpdateAddHTLC) SerializedSize() (uint32, error) <span class="cov0" title="0">{
        return MessageSerializedSize(c)
}</span>

// A compile time check to ensure UpdateAddHTLC implements the
// lnwire.SizeableMessage interface.
var _ SizeableMessage = (*UpdateAddHTLC)(nil)
</pre>
		
		<pre class="file" id="file108" style="display: none">package lnwire

import (
        "bytes"
        "io"
)

// OpaqueReason is an opaque encrypted byte slice that encodes the exact
// failure reason and additional some supplemental data. The contents of this
// slice can only be decrypted by the sender of the original HTLC.
type OpaqueReason []byte

// UpdateFailHTLC is sent by Alice to Bob in order to remove a previously added
// HTLC. Upon receipt of an UpdateFailHTLC the HTLC should be removed from the
// next commitment transaction, with the UpdateFailHTLC propagated backwards in
// the route to fully undo the HTLC.
type UpdateFailHTLC struct {
        // ChanID is the particular active channel that this
        // UpdateFailHTLC is bound to.
        ChanID ChannelID

        // ID references which HTLC on the remote node's commitment transaction
        // has timed out.
        ID uint64

        // Reason is an onion-encrypted blob that details why the HTLC was
        // failed. This blob is only fully decryptable by the initiator of the
        // HTLC message.
        Reason OpaqueReason

        // ExtraData is the set of data that was appended to this message to
        // fill out the full maximum transport message size. These fields can
        // be used to specify optional data such as custom TLV fields.
        ExtraData ExtraOpaqueData
}

// A compile time check to ensure UpdateFailHTLC implements the lnwire.Message
// interface.
var _ Message = (*UpdateFailHTLC)(nil)

// A compile time check to ensure UpdateFailHTLC implements the
// lnwire.SizeableMessage interface.
var _ SizeableMessage = (*UpdateFailHTLC)(nil)

// Decode deserializes a serialized UpdateFailHTLC message stored in the passed
// io.Reader observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (c *UpdateFailHTLC) Decode(r io.Reader, pver uint32) error <span class="cov0" title="0">{
        return ReadElements(r,
                &amp;c.ChanID,
                &amp;c.ID,
                &amp;c.Reason,
                &amp;c.ExtraData,
        )
}</span>

// Encode serializes the target UpdateFailHTLC into the passed io.Writer
// observing the protocol version specified.
//
// This is part of the lnwire.Message interface.
func (c *UpdateFailHTLC) Encode(w *bytes.Buffer, pver uint32) error <span class="cov0" title="0">{
        if err := WriteChannelID(w, c.ChanID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteUint64(w, c.ID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteOpaqueReason(w, c.Reason); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return WriteBytes(w, c.ExtraData)</span>
}

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (c *UpdateFailHTLC) MsgType() MessageType <span class="cov0" title="0">{
        return MsgUpdateFailHTLC
}</span>

// SerializedSize returns the serialized size of the message in bytes.
//
// This is part of the lnwire.SizeableMessage interface.
func (c *UpdateFailHTLC) SerializedSize() (uint32, error) <span class="cov0" title="0">{
        return MessageSerializedSize(c)
}</span>

// TargetChanID returns the channel id of the link for which this message is
// intended.
//
// NOTE: Part of peer.LinkUpdater interface.
func (c *UpdateFailHTLC) TargetChanID() ChannelID <span class="cov0" title="0">{
        return c.ChanID
}</span>
</pre>
		
		<pre class="file" id="file109" style="display: none">package lnwire

import (
        "bytes"
        "crypto/sha256"
        "io"
)

// UpdateFailMalformedHTLC is sent by either the payment forwarder or by
// payment receiver to the payment sender in order to notify it that the onion
// blob can't be parsed. For that reason we send this message instead of
// obfuscate the onion failure.
type UpdateFailMalformedHTLC struct {
        // ChanID is the particular active channel that this
        // UpdateFailMalformedHTLC is bound to.
        ChanID ChannelID

        // ID references which HTLC on the remote node's commitment transaction
        // has timed out.
        ID uint64

        // ShaOnionBlob hash of the onion blob on which can't be parsed by the
        // node in the payment path.
        ShaOnionBlob [sha256.Size]byte

        // FailureCode the exact reason why onion blob haven't been parsed.
        FailureCode FailCode

        // ExtraData is the set of data that was appended to this message to
        // fill out the full maximum transport message size. These fields can
        // be used to specify optional data such as custom TLV fields.
        ExtraData ExtraOpaqueData
}

// A compile time check to ensure UpdateFailMalformedHTLC implements the
// lnwire.Message interface.
var _ Message = (*UpdateFailMalformedHTLC)(nil)

// A compile time check to ensure UpdateFailMalformedHTLC implements the
// lnwire.SizeableMessage interface.
var _ SizeableMessage = (*UpdateFailMalformedHTLC)(nil)

// Decode deserializes a serialized UpdateFailMalformedHTLC message stored in the passed
// io.Reader observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (c *UpdateFailMalformedHTLC) Decode(r io.Reader, pver uint32) error <span class="cov0" title="0">{
        return ReadElements(r,
                &amp;c.ChanID,
                &amp;c.ID,
                c.ShaOnionBlob[:],
                &amp;c.FailureCode,
                &amp;c.ExtraData,
        )
}</span>

// Encode serializes the target UpdateFailMalformedHTLC into the passed
// io.Writer observing the protocol version specified.
//
// This is part of the lnwire.Message interface.
func (c *UpdateFailMalformedHTLC) Encode(w *bytes.Buffer,
        pver uint32) error <span class="cov0" title="0">{

        if err := WriteChannelID(w, c.ChanID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteUint64(w, c.ID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteBytes(w, c.ShaOnionBlob[:]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteFailCode(w, c.FailureCode); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return WriteBytes(w, c.ExtraData)</span>
}

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (c *UpdateFailMalformedHTLC) MsgType() MessageType <span class="cov0" title="0">{
        return MsgUpdateFailMalformedHTLC
}</span>

// SerializedSize returns the serialized size of the message in bytes.
//
// This is part of the lnwire.SizeableMessage interface.
func (c *UpdateFailMalformedHTLC) SerializedSize() (uint32, error) <span class="cov0" title="0">{
        return MessageSerializedSize(c)
}</span>

// TargetChanID returns the channel id of the link for which this message is
// intended.
//
// NOTE: Part of peer.LinkUpdater interface.
func (c *UpdateFailMalformedHTLC) TargetChanID() ChannelID <span class="cov0" title="0">{
        return c.ChanID
}</span>
</pre>
		
		<pre class="file" id="file110" style="display: none">package lnwire

import (
        "bytes"
        "io"
)

// UpdateFee is the message the channel initiator sends to the other peer if
// the channel commitment fee needs to be updated.
type UpdateFee struct {
        // ChanID is the channel that this UpdateFee is meant for.
        ChanID ChannelID

        // FeePerKw is the fee-per-kw on commit transactions that the sender of
        // this message wants to use for this channel.
        //
        // TODO(halseth): make SatPerKWeight when fee estimation is moved to
        // own package. Currently this will cause an import cycle.
        FeePerKw uint32

        // ExtraData is the set of data that was appended to this message to
        // fill out the full maximum transport message size. These fields can
        // be used to specify optional data such as custom TLV fields.
        ExtraData ExtraOpaqueData
}

// NewUpdateFee creates a new UpdateFee message.
func NewUpdateFee(chanID ChannelID, feePerKw uint32) *UpdateFee <span class="cov0" title="0">{
        return &amp;UpdateFee{
                ChanID:   chanID,
                FeePerKw: feePerKw,
        }
}</span>

// A compile time check to ensure UpdateFee implements the lnwire.Message
// interface.
var _ Message = (*UpdateFee)(nil)

// A compile time check to ensure UpdateFee implements the
// lnwire.SizeableMessage interface.
var _ SizeableMessage = (*UpdateFee)(nil)

// Decode deserializes a serialized UpdateFee message stored in the passed
// io.Reader observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (c *UpdateFee) Decode(r io.Reader, pver uint32) error <span class="cov0" title="0">{
        return ReadElements(r,
                &amp;c.ChanID,
                &amp;c.FeePerKw,
                &amp;c.ExtraData,
        )
}</span>

// Encode serializes the target UpdateFee into the passed io.Writer
// observing the protocol version specified.
//
// This is part of the lnwire.Message interface.
func (c *UpdateFee) Encode(w *bytes.Buffer, pver uint32) error <span class="cov0" title="0">{
        if err := WriteChannelID(w, c.ChanID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteUint32(w, c.FeePerKw); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return WriteBytes(w, c.ExtraData)</span>
}

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (c *UpdateFee) MsgType() MessageType <span class="cov0" title="0">{
        return MsgUpdateFee
}</span>

// SerializedSize returns the serialized size of the message in bytes.
//
// This is part of the lnwire.SizeableMessage interface.
func (c *UpdateFee) SerializedSize() (uint32, error) <span class="cov0" title="0">{
        return MessageSerializedSize(c)
}</span>

// TargetChanID returns the channel id of the link for which this message is
// intended.
//
// NOTE: Part of peer.LinkUpdater interface.
func (c *UpdateFee) TargetChanID() ChannelID <span class="cov0" title="0">{
        return c.ChanID
}</span>
</pre>
		
		<pre class="file" id="file111" style="display: none">package lnwire

import (
        "bytes"
        "io"
)

// UpdateFulfillHTLC is sent by Alice to Bob when she wishes to settle a
// particular HTLC referenced by its HTLCKey within a specific active channel
// referenced by ChannelPoint.  A subsequent CommitSig message will be sent by
// Alice to "lock-in" the removal of the specified HTLC, possible containing a
// batch signature covering several settled HTLC's.
type UpdateFulfillHTLC struct {
        // ChanID references an active channel which holds the HTLC to be
        // settled.
        ChanID ChannelID

        // ID denotes the exact HTLC stage within the receiving node's
        // commitment transaction to be removed.
        ID uint64

        // PaymentPreimage is the R-value preimage required to fully settle an
        // HTLC.
        PaymentPreimage [32]byte

        // CustomRecords maps TLV types to byte slices, storing arbitrary data
        // intended for inclusion in the ExtraData field.
        CustomRecords CustomRecords

        // ExtraData is the set of data that was appended to this message to
        // fill out the full maximum transport message size. These fields can
        // be used to specify optional data such as custom TLV fields.
        ExtraData ExtraOpaqueData
}

// NewUpdateFulfillHTLC returns a new empty UpdateFulfillHTLC.
func NewUpdateFulfillHTLC(chanID ChannelID, id uint64,
        preimage [32]byte) *UpdateFulfillHTLC <span class="cov0" title="0">{

        return &amp;UpdateFulfillHTLC{
                ChanID:          chanID,
                ID:              id,
                PaymentPreimage: preimage,
        }
}</span>

// A compile time check to ensure UpdateFulfillHTLC implements the
// lnwire.Message interface.
var _ Message = (*UpdateFulfillHTLC)(nil)

// A compile time check to ensure UpdateFulfillHTLC implements the
// lnwire.SizeableMessage interface.
var _ SizeableMessage = (*UpdateFulfillHTLC)(nil)

// Decode deserializes a serialized UpdateFulfillHTLC message stored in the
// passed io.Reader observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (c *UpdateFulfillHTLC) Decode(r io.Reader, pver uint32) error <span class="cov0" title="0">{
        // msgExtraData is a temporary variable used to read the message extra
        // data field from the reader.
        var msgExtraData ExtraOpaqueData

        if err := ReadElements(r,
                &amp;c.ChanID,
                &amp;c.ID,
                c.PaymentPreimage[:],
                &amp;msgExtraData,
        ); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Extract custom records from the extra data field.
        <span class="cov0" title="0">customRecords, _, extraData, err := ParseAndExtractCustomRecords(
                msgExtraData,
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">c.CustomRecords = customRecords
        c.ExtraData = extraData

        return nil</span>
}

// Encode serializes the target UpdateFulfillHTLC into the passed io.Writer
// observing the protocol version specified.
//
// This is part of the lnwire.Message interface.
func (c *UpdateFulfillHTLC) Encode(w *bytes.Buffer, pver uint32) error <span class="cov0" title="0">{
        if err := WriteChannelID(w, c.ChanID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteUint64(w, c.ID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := WriteBytes(w, c.PaymentPreimage[:]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Combine the custom records and the extra data, then encode the
        // result as a byte slice.
        <span class="cov0" title="0">extraData, err := MergeAndEncode(nil, c.ExtraData, c.CustomRecords)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return WriteBytes(w, extraData)</span>
}

// MsgType returns the integer uniquely identifying this message type on the
// wire.
//
// This is part of the lnwire.Message interface.
func (c *UpdateFulfillHTLC) MsgType() MessageType <span class="cov0" title="0">{
        return MsgUpdateFulfillHTLC
}</span>

// SerializedSize returns the serialized size of the message in bytes.
//
// This is part of the lnwire.SizeableMessage interface.
func (c *UpdateFulfillHTLC) SerializedSize() (uint32, error) <span class="cov0" title="0">{
        return MessageSerializedSize(c)
}</span>

// TargetChanID returns the channel id of the link for which this message is
// intended.
//
// NOTE: Part of peer.LinkUpdater interface.
func (c *UpdateFulfillHTLC) TargetChanID() ChannelID <span class="cov0" title="0">{
        return c.ChanID
}</span>
</pre>
		
		<pre class="file" id="file112" style="display: none">package lnwire

import (
        "bytes"
        "fmt"
        "io"
)

// WarningData is a set of bytes associated with a particular sent warning. A
// receiving node SHOULD only print out data verbatim if the string is composed
// solely of printable ASCII characters. For reference, the printable character
// set includes byte values 32 through 127 inclusive.
type WarningData []byte

// Warning is used to express non-critical errors in the protocol, providing
// a "soft" way for nodes to communicate failures.
type Warning struct {
        // ChanID references the active channel in which the warning occurred
        // within. If the ChanID is all zeros, then this warning applies to the
        // entire established connection.
        ChanID ChannelID

        // Data is the attached warning data that describes the exact failure
        // which caused the warning message to be sent.
        Data WarningData
}

// A compile time check to ensure Warning implements the lnwire.Message
// interface.
var _ Message = (*Warning)(nil)

// A compile time check to ensure Warning implements the lnwire.SizeableMessage
// interface.
var _ SizeableMessage = (*Warning)(nil)

// NewWarning creates a new Warning message.
func NewWarning() *Warning <span class="cov0" title="0">{
        return &amp;Warning{}
}</span>

// Warning returns the string representation to Warning.
func (c *Warning) Warning() string <span class="cov0" title="0">{
        errMsg := "non-ascii data"
        if isASCII(c.Data) </span><span class="cov0" title="0">{
                errMsg = string(c.Data)
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("chan_id=%v, err=%v", c.ChanID, errMsg)</span>
}

// Decode deserializes a serialized Warning message stored in the passed
// io.Reader observing the specified protocol version.
//
// This is part of the lnwire.Message interface.
func (c *Warning) Decode(r io.Reader, _ uint32) error <span class="cov0" title="0">{
        return ReadElements(r,
                &amp;c.ChanID,
                &amp;c.Data,
        )
}</span>

// Encode serializes the target Warning into the passed io.Writer observing the
// protocol version specified.
//
// This is part of the lnwire.Message interface.
func (c *Warning) Encode(w *bytes.Buffer, _ uint32) error <span class="cov0" title="0">{
        if err := WriteBytes(w, c.ChanID[:]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return WriteWarningData(w, c.Data)</span>
}

// MsgType returns the integer uniquely identifying an Warning message on the
// wire.
//
// This is part of the lnwire.Message interface.
func (c *Warning) MsgType() MessageType <span class="cov0" title="0">{
        return MsgWarning
}</span>

// SerializedSize returns the serialized size of the message in bytes.
//
// This is part of the lnwire.SizeableMessage interface.
func (c *Warning) SerializedSize() (uint32, error) <span class="cov0" title="0">{
        return MessageSerializedSize(c)
}</span>
</pre>
		
		<pre class="file" id="file113" style="display: none">package lnwire

import (
        "bytes"
        "encoding/binary"
        "errors"
        "fmt"
        "image/color"
        "math"
        "net"

        "github.com/btcsuite/btcd/btcec/v2"
        "github.com/btcsuite/btcd/btcutil"
        "github.com/btcsuite/btcd/wire"
        "github.com/lightningnetwork/lnd/tor"
)

var (
        // ErrNilFeatureVector is returned when the supplied feature is nil.
        ErrNilFeatureVector = errors.New("cannot write nil feature vector")

        // ErrPkScriptTooLong is returned when the length of the provided
        // script exceeds 34.
        ErrPkScriptTooLong = errors.New("'PkScript' too long")

        // ErrNilTCPAddress is returned when the supplied address is nil.
        ErrNilTCPAddress = errors.New("cannot write nil TCPAddr")

        // ErrNilOnionAddress is returned when the supplied address is nil.
        ErrNilOnionAddress = errors.New("cannot write nil onion address")

        // ErrNilNetAddress is returned when a nil value is used in []net.Addr.
        ErrNilNetAddress = errors.New("cannot write nil address")

        // ErrNilOpaqueAddrs is returned when the supplied address is nil.
        ErrNilOpaqueAddrs = errors.New("cannot write nil OpaqueAddrs")

        // ErrNilPublicKey is returned when a nil pubkey is used.
        ErrNilPublicKey = errors.New("cannot write nil pubkey")

        // ErrUnknownServiceLength is returned when the onion service length is
        // unknown.
        ErrUnknownServiceLength = errors.New("unknown onion service length")
)

// ErrOutpointIndexTooBig is used when the outpoint index exceeds the max value
// of uint16.
func ErrOutpointIndexTooBig(index uint32) error <span class="cov0" title="0">{
        return fmt.Errorf(
                "index for outpoint (%v) is greater than "+
                        "max index of %v", index, math.MaxUint16,
        )
}</span>

// WriteBytes appends the given bytes to the provided buffer.
func WriteBytes(buf *bytes.Buffer, b []byte) error <span class="cov0" title="0">{
        _, err := buf.Write(b)
        return err
}</span>

// WriteUint8 appends the uint8 to the provided buffer.
func WriteUint8(buf *bytes.Buffer, n uint8) error <span class="cov0" title="0">{
        _, err := buf.Write([]byte{n})
        return err
}</span>

// WriteUint16 appends the uint16 to the provided buffer. It encodes the
// integer using big endian byte order.
func WriteUint16(buf *bytes.Buffer, n uint16) error <span class="cov0" title="0">{
        var b [2]byte
        binary.BigEndian.PutUint16(b[:], n)
        _, err := buf.Write(b[:])
        return err
}</span>

// WriteUint32 appends the uint32 to the provided buffer. It encodes the
// integer using big endian byte order.
func WriteUint32(buf *bytes.Buffer, n uint32) error <span class="cov0" title="0">{
        var b [4]byte
        binary.BigEndian.PutUint32(b[:], n)
        _, err := buf.Write(b[:])
        return err
}</span>

// WriteUint64 appends the uint64 to the provided buffer. It encodes the
// integer using big endian byte order.
func WriteUint64(buf *bytes.Buffer, n uint64) error <span class="cov0" title="0">{
        var b [8]byte
        binary.BigEndian.PutUint64(b[:], n)
        _, err := buf.Write(b[:])
        return err
}</span>

// WriteSatoshi appends the Satoshi value to the provided buffer.
func WriteSatoshi(buf *bytes.Buffer, amount btcutil.Amount) error <span class="cov0" title="0">{
        return WriteUint64(buf, uint64(amount))
}</span>

// WriteMilliSatoshi appends the MilliSatoshi value to the provided buffer.
func WriteMilliSatoshi(buf *bytes.Buffer, amount MilliSatoshi) error <span class="cov0" title="0">{
        return WriteUint64(buf, uint64(amount))
}</span>

// WritePublicKey appends the compressed public key to the provided buffer.
func WritePublicKey(buf *bytes.Buffer, pub *btcec.PublicKey) error <span class="cov0" title="0">{
        if pub == nil </span><span class="cov0" title="0">{
                return ErrNilPublicKey
        }</span>

        <span class="cov0" title="0">serializedPubkey := pub.SerializeCompressed()
        return WriteBytes(buf, serializedPubkey)</span>
}

// WriteChannelID appends the ChannelID to the provided buffer.
func WriteChannelID(buf *bytes.Buffer, channelID ChannelID) error <span class="cov0" title="0">{
        return WriteBytes(buf, channelID[:])
}</span>

// WriteNodeAlias appends the alias to the provided buffer.
func WriteNodeAlias(buf *bytes.Buffer, alias NodeAlias) error <span class="cov0" title="0">{
        return WriteBytes(buf, alias[:])
}</span>

// WriteShortChannelID appends the ShortChannelID to the provided buffer. It
// encodes the BlockHeight and TxIndex each using 3 bytes with big endian byte
// order, and encodes txPosition using 2 bytes with big endian byte order.
func WriteShortChannelID(buf *bytes.Buffer, shortChanID ShortChannelID) error <span class="cov0" title="0">{
        // Check that field fit in 3 bytes and write the blockHeight
        if shortChanID.BlockHeight &gt; ((1 &lt;&lt; 24) - 1) </span><span class="cov0" title="0">{
                return errors.New("block height should fit in 3 bytes")
        }</span>

        <span class="cov0" title="0">var blockHeight [4]byte
        binary.BigEndian.PutUint32(blockHeight[:], shortChanID.BlockHeight)

        if _, err := buf.Write(blockHeight[1:]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Check that field fit in 3 bytes and write the txIndex
        <span class="cov0" title="0">if shortChanID.TxIndex &gt; ((1 &lt;&lt; 24) - 1) </span><span class="cov0" title="0">{
                return errors.New("tx index should fit in 3 bytes")
        }</span>

        <span class="cov0" title="0">var txIndex [4]byte
        binary.BigEndian.PutUint32(txIndex[:], shortChanID.TxIndex)
        if _, err := buf.Write(txIndex[1:]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Write the TxPosition
        <span class="cov0" title="0">return WriteUint16(buf, shortChanID.TxPosition)</span>
}

// WriteSig appends the signature to the provided buffer.
func WriteSig(buf *bytes.Buffer, sig Sig) error <span class="cov0" title="0">{
        return WriteBytes(buf, sig.bytes[:])
}</span>

// WriteSigs appends the slice of signatures to the provided buffer with its
// length.
func WriteSigs(buf *bytes.Buffer, sigs []Sig) error <span class="cov0" title="0">{
        // Write the length of the sigs.
        if err := WriteUint16(buf, uint16(len(sigs))); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for _, sig := range sigs </span><span class="cov0" title="0">{
                if err := WriteSig(buf, sig); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// WriteFailCode appends the FailCode to the provided buffer.
func WriteFailCode(buf *bytes.Buffer, e FailCode) error <span class="cov0" title="0">{
        return WriteUint16(buf, uint16(e))
}</span>

// WriteRawFeatureVector encodes the feature using the feature's Encode method
// and appends the data to the provided buffer. An error will return if the
// passed feature is nil.
func WriteRawFeatureVector(buf *bytes.Buffer, feature *RawFeatureVector) error <span class="cov0" title="0">{
        if feature == nil </span><span class="cov0" title="0">{
                return ErrNilFeatureVector
        }</span>

        <span class="cov0" title="0">return feature.Encode(buf)</span>
}

// WriteColorRGBA appends the RGBA color using three bytes.
func WriteColorRGBA(buf *bytes.Buffer, e color.RGBA) error <span class="cov0" title="0">{
        // Write R
        if err := WriteUint8(buf, e.R); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Write G
        <span class="cov0" title="0">if err := WriteUint8(buf, e.G); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Write B
        <span class="cov0" title="0">return WriteUint8(buf, e.B)</span>
}

// WriteQueryEncoding appends the QueryEncoding to the provided buffer.
func WriteQueryEncoding(buf *bytes.Buffer, e QueryEncoding) error <span class="cov0" title="0">{
        return WriteUint8(buf, uint8(e))
}</span>

// WriteFundingFlag appends the FundingFlag to the provided buffer.
func WriteFundingFlag(buf *bytes.Buffer, flag FundingFlag) error <span class="cov0" title="0">{
        return WriteUint8(buf, uint8(flag))
}</span>

// WriteChanUpdateMsgFlags appends the update flag to the provided buffer.
func WriteChanUpdateMsgFlags(buf *bytes.Buffer, f ChanUpdateMsgFlags) error <span class="cov0" title="0">{
        return WriteUint8(buf, uint8(f))
}</span>

// WriteChanUpdateChanFlags appends the update flag to the provided buffer.
func WriteChanUpdateChanFlags(buf *bytes.Buffer, f ChanUpdateChanFlags) error <span class="cov0" title="0">{
        return WriteUint8(buf, uint8(f))
}</span>

// WriteDeliveryAddress appends the address to the provided buffer.
func WriteDeliveryAddress(buf *bytes.Buffer, addr DeliveryAddress) error <span class="cov0" title="0">{
        return writeDataWithLength(buf, addr)
}</span>

// WritePingPayload appends the payload to the provided buffer.
func WritePingPayload(buf *bytes.Buffer, payload PingPayload) error <span class="cov0" title="0">{
        return writeDataWithLength(buf, payload)
}</span>

// WritePongPayload appends the payload to the provided buffer.
func WritePongPayload(buf *bytes.Buffer, payload PongPayload) error <span class="cov0" title="0">{
        return writeDataWithLength(buf, payload)
}</span>

// WriteWarningData appends the data to the provided buffer.
func WriteWarningData(buf *bytes.Buffer, data WarningData) error <span class="cov0" title="0">{
        return writeDataWithLength(buf, data)
}</span>

// WriteErrorData appends the data to the provided buffer.
func WriteErrorData(buf *bytes.Buffer, data ErrorData) error <span class="cov0" title="0">{
        return writeDataWithLength(buf, data)
}</span>

// WriteOpaqueReason appends the reason to the provided buffer.
func WriteOpaqueReason(buf *bytes.Buffer, reason OpaqueReason) error <span class="cov0" title="0">{
        return writeDataWithLength(buf, reason)
}</span>

// WriteBool appends the boolean to the provided buffer.
func WriteBool(buf *bytes.Buffer, b bool) error <span class="cov0" title="0">{
        if b </span><span class="cov0" title="0">{
                return WriteBytes(buf, []byte{1})
        }</span>
        <span class="cov0" title="0">return WriteBytes(buf, []byte{0})</span>
}

// WritePkScript appends the script to the provided buffer. Returns an error if
// the provided script exceeds 34 bytes.
func WritePkScript(buf *bytes.Buffer, s PkScript) error <span class="cov0" title="0">{
        // The largest script we'll accept is a p2wsh which is exactly
        // 34 bytes long.
        scriptLength := len(s)
        if scriptLength &gt; 34 </span><span class="cov0" title="0">{
                return ErrPkScriptTooLong
        }</span>

        <span class="cov0" title="0">return wire.WriteVarBytes(buf, 0, s)</span>
}

// WriteOutPoint appends the outpoint to the provided buffer.
func WriteOutPoint(buf *bytes.Buffer, p wire.OutPoint) error <span class="cov0" title="0">{
        // Before we write anything to the buffer, check the Index is sane.
        if p.Index &gt; math.MaxUint16 </span><span class="cov0" title="0">{
                return ErrOutpointIndexTooBig(p.Index)
        }</span>

        <span class="cov0" title="0">var h [32]byte
        copy(h[:], p.Hash[:])
        if _, err := buf.Write(h[:]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Write the index using two bytes.
        <span class="cov0" title="0">return WriteUint16(buf, uint16(p.Index))</span>
}

// WriteTCPAddr appends the TCP address to the provided buffer, either a IPv4
// or a IPv6.
func WriteTCPAddr(buf *bytes.Buffer, addr *net.TCPAddr) error <span class="cov0" title="0">{
        if addr == nil </span><span class="cov0" title="0">{
                return ErrNilTCPAddress
        }</span>

        // Make a slice of bytes to hold the data of descriptor and ip. At
        // most, we need 17 bytes - 1 byte for the descriptor, 16 bytes for
        // IPv6.
        <span class="cov0" title="0">data := make([]byte, 0, 17)

        if addr.IP.To4() != nil </span><span class="cov0" title="0">{
                data = append(data, uint8(tcp4Addr))
                data = append(data, addr.IP.To4()...)
        }</span> else<span class="cov0" title="0"> {
                data = append(data, uint8(tcp6Addr))
                data = append(data, addr.IP.To16()...)
        }</span>

        <span class="cov0" title="0">if _, err := buf.Write(data); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return WriteUint16(buf, uint16(addr.Port))</span>
}

// WriteOnionAddr appends the onion address to the provided buffer.
func WriteOnionAddr(buf *bytes.Buffer, addr *tor.OnionAddr) error <span class="cov0" title="0">{
        if addr == nil </span><span class="cov0" title="0">{
                return ErrNilOnionAddress
        }</span>

        <span class="cov0" title="0">var (
                suffixIndex int
                descriptor  []byte
        )

        // Decide the suffixIndex and descriptor.
        switch len(addr.OnionService) </span>{
        case tor.V2Len:<span class="cov0" title="0">
                descriptor = []byte{byte(v2OnionAddr)}
                suffixIndex = tor.V2Len - tor.OnionSuffixLen</span>

        case tor.V3Len:<span class="cov0" title="0">
                descriptor = []byte{byte(v3OnionAddr)}
                suffixIndex = tor.V3Len - tor.OnionSuffixLen</span>

        default:<span class="cov0" title="0">
                return ErrUnknownServiceLength</span>
        }

        // Decode the address.
        <span class="cov0" title="0">host, err := tor.Base32Encoding.DecodeString(
                addr.OnionService[:suffixIndex],
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Perform the actual write when the above checks passed.
        <span class="cov0" title="0">if _, err := buf.Write(descriptor); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if _, err := buf.Write(host); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return WriteUint16(buf, uint16(addr.Port))</span>
}

// WriteOpaqueAddrs appends the payload of the given OpaqueAddrs to buffer.
func WriteOpaqueAddrs(buf *bytes.Buffer, addr *OpaqueAddrs) error <span class="cov0" title="0">{
        if addr == nil </span><span class="cov0" title="0">{
                return ErrNilOpaqueAddrs
        }</span>

        <span class="cov0" title="0">_, err := buf.Write(addr.Payload)
        return err</span>
}

// WriteNetAddrs appends a slice of addresses to the provided buffer with the
// length info.
func WriteNetAddrs(buf *bytes.Buffer, addresses []net.Addr) error <span class="cov0" title="0">{
        // First, we'll encode all the addresses into an intermediate
        // buffer. We need to do this in order to compute the total
        // length of the addresses.
        buffer := make([]byte, 0, MaxMsgBody)
        addrBuf := bytes.NewBuffer(buffer)

        for _, address := range addresses </span><span class="cov0" title="0">{
                switch a := address.(type) </span>{
                case *net.TCPAddr:<span class="cov0" title="0">
                        if err := WriteTCPAddr(addrBuf, a); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                case *tor.OnionAddr:<span class="cov0" title="0">
                        if err := WriteOnionAddr(addrBuf, a); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                case *OpaqueAddrs:<span class="cov0" title="0">
                        if err := WriteOpaqueAddrs(addrBuf, a); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                default:<span class="cov0" title="0">
                        return ErrNilNetAddress</span>
                }
        }

        // With the addresses fully encoded, we can now write out data.
        <span class="cov0" title="0">return writeDataWithLength(buf, addrBuf.Bytes())</span>
}

// writeDataWithLength writes the data and its length to the buffer.
func writeDataWithLength(buf *bytes.Buffer, data []byte) error <span class="cov0" title="0">{
        var l [2]byte
        binary.BigEndian.PutUint16(l[:], uint16(len(data)))
        if _, err := buf.Write(l[:]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err := buf.Write(data)
        return err</span>
}
</pre>
		
		<pre class="file" id="file114" style="display: none">package multimutex

import (
        "fmt"
        "sync"
)

// cntMutex is a struct that wraps a counter and a mutex, and is used to keep
// track of the number of goroutines waiting for access to the
// mutex, such that we can forget about it when the counter is zero.
type cntMutex struct {
        cnt int
        sync.Mutex
}

// Mutex is a struct that keeps track of a set of mutexes with a given ID. It
// can be used for making sure only one goroutine gets given the mutex per ID.
type Mutex[T comparable] struct {
        // mutexes is a map of IDs to a cntMutex. The cntMutex for a given ID
        // will hold the mutex to be used by all callers requesting access for
        // the ID, in addition to the count of callers.
        mutexes map[T]*cntMutex

        // mapMtx is used to give synchronize concurrent access to the mutexes
        // map.
        mapMtx sync.Mutex
}

// NewMutex creates a new Mutex.
func NewMutex[T comparable]() *Mutex[T] <span class="cov0" title="0">{
        return &amp;Mutex[T]{
                mutexes: make(map[T]*cntMutex),
        }
}</span>

// Lock locks the mutex by the given ID. If the mutex is already locked by this
// ID, Lock blocks until the mutex is available.
func (c *Mutex[T]) Lock(id T) <span class="cov0" title="0">{
        c.mapMtx.Lock()
        mtx, ok := c.mutexes[id]
        if ok </span><span class="cov0" title="0">{
                // If the mutex already existed in the map, we increment its
                // counter, to indicate that there now is one more goroutine
                // waiting for it.
                mtx.cnt++
        }</span> else<span class="cov0" title="0"> {
                // If it was not in the map, it means no other goroutine has
                // locked the mutex for this ID, and we can create a new mutex
                // with count 1 and add it to the map.
                mtx = &amp;cntMutex{
                        cnt: 1,
                }
                c.mutexes[id] = mtx
        }</span>
        <span class="cov0" title="0">c.mapMtx.Unlock()

        // Acquire the mutex for this ID.
        mtx.Lock()</span>
}

// Unlock unlocks the mutex by the given ID. It is a run-time error if the
// mutex is not locked by the ID on entry to Unlock.
func (c *Mutex[T]) Unlock(id T) <span class="cov0" title="0">{
        // Since we are done with all the work for this update, we update the
        // map to reflect that.
        c.mapMtx.Lock()

        mtx, ok := c.mutexes[id]
        if !ok </span><span class="cov0" title="0">{
                // The mutex not existing in the map means an unlock for an ID
                // not currently locked was attempted.
                panic(fmt.Sprintf("double unlock for id %v",
                        id))</span>
        }

        // Decrement the counter. If the count goes to zero, it means this
        // caller was the last one to wait for the mutex, and we can delete it
        // from the map. We can do this safely since we are under the mapMtx,
        // meaning that all other goroutines waiting for the mutex already have
        // incremented it, or will create a new mutex when they get the mapMtx.
        <span class="cov0" title="0">mtx.cnt--
        if mtx.cnt == 0 </span><span class="cov0" title="0">{
                delete(c.mutexes, id)
        }</span>
        <span class="cov0" title="0">c.mapMtx.Unlock()

        // Unlock the mutex for this ID.
        mtx.Unlock()</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
